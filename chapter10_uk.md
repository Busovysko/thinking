# Внутрішні класи

Визначення класу може розміщуватися всередині визначення іншого класу. Такі класи називаються внутрішніми (*inner class*). 

Внутрішні класи дуже корисні, так як вони дозволяють групувати класи, що логічно належать один одному, і управляти доступом до них. Однак слід розуміти, що внутрішні класи помітно відрізняються від композиції. 

На перший погляд складається враження, що внутрішні класи являють собою простий механізм приховування коду. Однак незабаром ви дізнаєтеся, що можливості внутрішніх класів набагато ширші (вони знають про існування зовнішніх класів і можуть працювати з ними), а програмний код з внутрішніми класами часто буває більш елегантним і зрозумілим (хоча звичайно, цього ніхто не гарантує). 

У цьому розділі докладно досліджується синтаксис внутрішніх класів. Ці можливості представлені для повноти матеріалу, хоча, швидше за все, на перших порах вони вам не знадобляться. Можливо, початкові розділи цієї глави містять все, що вам дійсно необхідно знати на цій стадії, а до більш докладного пояснення можна ставитися як до довідкового, додаткового матеріалу.
 
## Створення внутрішніх класів
 
Внутрішні класи створюються в точності так, як і слід було очікувати, - визначення класу розміщується всередині навколишнього класу:
 
``` java
//: innerclasses/Parcel1.java 
// Створення внутрішніх класів. 
 
public class Parcel1 { 
  class Contents { 
    private int i = 11; 
    public int value() { return i; } 
  } 
  class Destination { 
    private String label; 
    Destination(String whereTo) { 
      label = whereTo; 
    } 
    String readLabel() { return label; } 
  }  
  // Використання внутрішніх класів має багато спільного 
  // з використанням будь-яких інших класів в межах Parcel1:
  public void ship(String dest) { 
    Contents c = new Contents(); 
    Destination d = new Destination(dest); 
    System.out.println(d.readLabel()); 
  } 
  public static void main(String[] args) { 
    Parcel1 p = new Parcel1(); 
    p.ship("Tasmania"); 
  } } /* Output: 
Tasmania 
*///:~ 
```

Внутрішні класи, що використовуються в середині ***ship()*** виглядають як звичайні класи. Практично єдина відмінність що вони містяться всередині  ***Parcel1***. Через деякий час ви побачите, що це не єдина відмінність. В загальному, зовнішній клас має методи що повертають посилання на внутрішній клас, як ви можете бачити в методах ***to()*** і ***contents()***:
 
``` java
//: innerclasses/Parcel2.java 
// Returning a reference to an inner class. 
 
public class Parcel2 { 
  class Contents { 
    private int i = 11; 
    public int value() { return i; } 
  } 
  class Destination { 
    private String label; 
    Destination(String whereTo) { 
      label = whereTo; 
    } 
    String readLabel() { return label; } 
  } 
  public Destination to(String s) { 
    return new Destination(s); 
  } 
  public Contents contents() { 
    return new Contents(); 
  } 
  public void ship(String dest) { 
    Contents c = contents(); 
    Destination d = to(dest); 
    System.out.println(d.readLabel()); 
  } 
  public static void main(String[] args) { 
    Parcel2 p = new Parcel2(); 
    p.ship("Tasmania"); 
    Parcel2 q = new Parcel2(); 
    // Defining references to inner classes: 
    Parcel2.Contents c = q.contents(); 
    Parcel2.Destination d = q.to("Borneo"); 
  } 
} /* Output: 
Tasmania 
*///:~ 
```

Якщо вам знадобиться створити об'єкт внутрішнього класу де-небудь, крім як в не-статичному методі зовнішнього класу, тип цього об'єкта повинен задаватися в форматі Ім'яЗовнішньогоКласу.Ім'яВнутрішньогоКласу, що і робиться в методі ***main()***. 

## Зв'язок із зовнішнім класом

Поки що внутрішні класи виглядають як деяка схема для приховування імен та організації коду - корисна, але не особливо вражаюча. Однак є ще один нюанс. Об'єкт внутрішнього класу пов'язаний із зовнішнім об'єктом-творцем і може звертатися до його членів без будь-яких додаткових описів. До того ж для внутрішніх класів доступні всі без винятку елементи зовнішнього класу. Наступний приклад ілюструє сказане:
 
``` java
//: innerclasses/Sequence.java 
// Holds a sequence of Objects. 
 
interface Selector { 
  boolean end(); 
  Object current(); 
  void next(); 
}   
 
public class Sequence { 
  private Object[] items; 
  private int next = 0; 
  public Sequence(int size) { items = new Object[size]; } 
  public void add(Object x) { 
    if(next < items.length) 
      items[next++] = x; 
  } 
  private class SequenceSelector implements Selector { 
    private int i = 0; 
    public boolean end() { return i == items.length; } 
    public Object current() { return items[i]; } 
    public void next() { if(i < items.length) i++; } 
  } 
  public Selector selector() { 
    return new SequenceSelector(); 
  }  
  public static void main(String[] args) { 
    Sequence sequence = new Sequence(10); 
    for(int i = 0; i < 10; i++) 
      sequence.add(Integer.toString(i)); 
    Selector selector = sequence.selector(); 
    while(!selector.end()) { 
      System.out.print(selector.current() + " "); 
      selector.next(); 
    } 
  } 
} /* Output: 
0 1 2 3 4 5 6 7 8 9 
*///:~ 
```

Клас ***Sequence*** - не більше ніж «оболонка» для масиву з елементами ***Object***, що має фіксований розмір. Для додавання нових об'єктів в кінець послідовності (при наявності вільного місця) використовується метод ***add()***. Для вибірки кожного об'єкта в послідовності ***Sequence*** передбачений інтерфейс з ім'ям ***Selector***. Він дозволяє дізнатися, чи досягнуто кінець послідовності (метод ***end()***), звернутися до поточного об'єкту (метод ***current )***) і перейти до наступного об'єкту в послідовності (метод ***next()***). Так як ***Selector*** є інтерфейсом, інші класи вправі реалізувати його по-своєму, а також інші методи можуть використовувати інтерфейс як аргумент - все це підвищує універсальність коду.
 
Тут ***SequenceSelector*** є закритим (***private***) класом, який надає функціональність інтерфейсу ***Selector***. У методі ***main()*** ви можете спостерігати за процесом створення послідовності ***Sequence*** з подальшим заповненням її об'єктами ***String***. Потім викликається метод ***selector()*** для отримання інтерфейсу ***Selector***, який використовується для переміщення по послідовності і вибору її елементів.
 
На перший погляд створення ***SequenceSelector*** нагадує створення звичайного внутрішнього класу. Але придивіться до нього уважніше. Зауважте, що в кожному з методів ***end(), current()*** і ***next()*** присутнє посилання на ***items***, а це не одне з полів класу ***SequenceSelector***, а закрите (***private***) поле навколишнього класу. Внутрішній клас може звертатися до всіх полів і методів зовнішнього класу-оболонки, так ніби вони описані в ньому самому. Це дуже зручно, і ви могли в цьому переконатися, вивчаючи розглянутий приклад.
 
Отже, внутрішній клас автоматично отримує доступ до членів навколишнього класу. Як же це відбувається? Внутрішній клас містить приховане посилання на певний об'єкт навколишнього класу, відповідальний за його створення. При зверненні до члена навколишнього класу використовується це (приховане) посилання.
 
На щастя, всі технічні деталі забезпечуються компілятором, але тепер ви знаєте, що об'єкт внутрішнього класу можна створити тільки в поєднанні з об'єктом зовнішнього класу (як буде показано пізніше, якщо внутрішній клас не є статичним). Конструювання об'єкта внутрішнього класу вимагає наявності посилання на об'єкт зовнішнього класу; якщо посилання недоступне, компілятор видасть повідомлення про помилку. Велику частину часу весь процес відбувається без будь-якої участі з боку програміста. 

## Конструкції .this і .new

Якщо вам знадобиться отримати посилання на об'єкт зовнішнього класу, запишіть ім'я зовнішнього класу, за яким слідує крапка, а потім ключове слово ***this***. Отримана посилання автоматично відноситься до правильного типу, відомого і перевіряється на стадії компіляції, тому додаткові витрати на стадії виконання не потрібні. Наступний приклад показує, як використовувати конструкцію ***.this***:
 
``` java
//: innerclasses/DotThis.java 
// Звернення до об'єкта зовнішнього класу.
 
public class DotThis { 
  void f() { System.out.println("DotThis.f()"); } 
  public class Inner { 
    public DotThis outer() { 
      return DotThis.this; 
      // A plain "this" would be Inner’s "this" 
    } 
  } 
  public Inner inner() { return new Inner(); } 
  public static void main(String[] args) { 
    DotThis dt = new DotThis(); 
    DotThis.Inner dti = dt.inner(); 
    dti.outer().f(); 
  } 
} /* Output: 
DotThis.f() 
*///:~ 
```

Іноді буває потрібно наказати іншому об'єкту створити об'єкт одного з його внутрішніх класів. Для цього перед ***.new*** вказується посилання на інший об'єкт зовнішнього класу:
 
``` java
//: Innerclasses/DotNew.java
// Безпосереднє створення внутрішнього класу в синтаксисі .new
 
public class DotNew { 
  public class Inner {} 
  public static void main(String[] args) { 
    DotNew dn = new DotNew(); 
    DotNew.Inner dni = dn.new Inner(); 
  } 
} ///:~ 
```
 
При створенні об'єкта внутрішнього класу вказується не ім'я зовнішнього класу ***DotNew***, як можна було б очікувати, а ім'я об'єкта зовнішнього класу. Це також вирішує проблему видимості імен для внутрішнього класу, тому ми не використовуємо (а вірніше, не можемо використовувати) запис виду ***dn.new DotNew.Inner()***. Неможливо створити об'єкт внутрішнього класу, не маючи посилання на зовнішній клас. Але якщо створити вкладений клас (статичний внутрішній клас), посилання на об'єкт зовнішнього класу не потрібнt. Розглянемо приклад використання ***.new*** в прикладі ***Parcel3***:
 
``` java
//: Innerclasses/Parcel3.java
// Використання new для створення екземплярів внутрішніх класів
public class Parcel3 { 
  class Contents { 
    private int i = 11; 
    public int value() { return i; } 
  } 
  class Destination { 
    private String label; 
    Destination(String whereTo) { label = whereTo; } 
    String readLabel() { return label; } 
  } 
  public static void main(String[] args) { 
    Parcel3 p = new Parcel3(); 
	// Для створення екземпляра внутрішнього класу
	// Необхідно використовувати екземпляр зовнішнього класу:
    Parcel3.Contents c = p.new Contents(); 
    Parcel3.Destination d = p.new Destination("Tasmania"); 
  } 
} ///:~ 
```

## Внутрішні класи і висхідне перетворення

Міць внутрішніх класів по-справжньому проявляється при виконанні висхідного перетворення до базового класу, і особливо до інтерфейсу. (Отримання посилання на інтерфейс за посиланням на який реалізує його об'єкт нічим принципово не відрізняється від висхідного перетворення до базового класу.) Причина в тому, що внутрішній клас - реалізація інтерфейсу - може бути абсолютно невидимим і недоступним для навколишнього світу, а це дуже зручно для приховування реалізації . Все, що ви при цьому отримуєте, - посилання на базовий клас або інтерфейс. Для початку визначимо інтерфейси для попередніх прикладів:
 
``` java
//: Innerclasses/Destination.java
public interface Destination {
	String readLabel ();
}
 
//: Innerclasses/Contents.java
public interface Contents {
	int value ();
}
```
 
Тепер інтерфейси ***Contents*** і ***Destination*** доступні програмісту-клієнту. (Пам'ятаєте, що в оголошенні ***interface*** всі члени класу автоматично є відкритими (***public***).) При отриманні з методу посилання на базовий клас або інтерфейс можливі ситуації, в яких вам не вдасться визначити її точний тип, як тут:
 
``` java
//: Innerclasses/TestParcel.java
 
//: innerclasses/TestParcel.java 
 
class Parcel4 { 
  private class PContents implements Contents { 
    private int i = 11; 
    public int value() { return i; } 
  } 
  protected class PDestination implements Destination { 
    private String label; 
    private PDestination(String whereTo) { 
      label = whereTo; 
    } 
    public String readLabel() { return label; } 
  } 
  public Destination destination(String s) { 
    return new PDestination(s); 
  } 
  public Contents contents() { 
    return new PContents(); 
  } 
} 
 
public class TestParcel { 
  public static void main(String[] args) { 
    Parcel4 p = new Parcel4(); 
    Contents c = p.contents(); 
    Destination d = p.destination("Tasmania"); 
	// Заборонено - немає доступу до private-класу:
	//! Parcel4.PContents pc = p.new PContents ();
  } 
} ///:~ 
```
 
В клас ***Parcel4*** було додано дещо нове: внутрішній клас ***PContents*** є закритим (***private***), тому він недоступний для всіх, крім зовнішнього класу ***Раrсе14***.
 
Клас ***PDestination*** оголошений як ***protected***, отже, доступ до нього мають тільки клас ***Parcel4***, класи з одного пакета з ***Раrсеl4*** (так як специфікатор ***protected*** також дає доступ в межах пакету) і спадкоємці класу ***Раrсеl4***.
 
Таким чином, програміст-клієнт має обмежену інформацією і доступом до цих членів класу. Більш того, не можна навіть виконати спадне перетворення до закритого (***private***) внутрішньому класу (або ***protected***, крім спадкоємців), оскільки його ім'я недоступно, як показано в класі ***Test** *.
 
Таким чином, закритий внутрішній клас дозволяє розробнику класу повністю заборонити використання певних типів і приховати всі деталі реалізації класу. До того ж, розширення інтерфейсу з точки зору програміста-клієнта не матиме сенсу, оскільки він не зможе отримати доступ до додаткових методів, що не належать до відкритої частини класу. Нарешті, у компілятора *Java* з'явиться можливість оптимізувати код.
 
## Внутрішні класи в методах і областях дії
 
Раніше ми розглянули ряд типових застосувань внутрішніх класів. В основному ваш код буде містити «прості» внутрішні класи, сенс яких зрозуміти неважко. Однак синтаксис внутрішніх класів приховує безліч інших, не настільки тривіальних способів їх використання. Внутрішні класи можна створювати всередині методу або навіть в межах довільного блоку. На те є дві причини:

1. як було показано раніше, ви реалізуєте деякий інтерфейс, щоб потім створювати і повертати посилання його типу;
2. ви створюєте допоміжний клас для вирішення складного завдання, але при цьому не хочете, щоб цей клас був відкритий для сторонніх.

У наступних прикладах щойно розглянута програма буде змінена, завдяки чому у нас з'являться:
1. клас, визначений всередині методу;
2. клас, визначений всередині області дії (блоку), яка знаходиться всередині методу;
3. безіменний клас, який реалізує інтерфейс;
4. безіменний клас, який розширює клас, у якого відсутня конструктор за замовчуванням;
5. безіменний клас, який виконує ініціалізацію полів;
6. безіменний клас, який здійснює конструювання за допомогою ініціалізації примірника (безіменні внутрішні класи не можуть мати конструктори).

Перший приклад демонструє створення цілого класу в контексті методу (замість створення в контексті іншого класу). Такі внутрішні класи називаються локальними:
 
``` java
//: Innerclasses/Parcel5.java
// Вкладення класу в тіло методу. 
 
public class Parcel5 { 
  public Destination destination(String s) { 
    class PDestination implements Destination { 
Inner Classes  249       private String label; 
      private PDestination(String whereTo) { 
        label = whereTo; 
      } 
      public String readLabel() { return label; } 
    } 
    return new PDestination(s); 
  } 
  public static void main(String[] args) { 
    Parcel5 p = new Parcel5(); 
    Destination d = p.destination("Tasmania"); 
  } 
} ///:~ 
```
 
Тепер клас ***PDestination*** є частиною методу ***destination()***, а не частиною класу ***Раrсеl5***. Тому доступ до класу ***PDestination*** можливий тільки з методу ***destination()***.
 
Зверніть увагу на висхідне перетворення, вироблене в команді ***return***, - з методу повертається лише посилання на базовий клас ***Destination***, і нічого більше. Звичайно, той факт, що ім'я класу ***PDestination*** знаходиться всередині методу ***destination()***, не означає, що об'єкт ***PDestination*** після виходу з цього методу стане недоступним.
 
Ідентифікатор ***PDestination*** може використовуватися для внутрішніх класів кожного окремого класу в одному підкаталозі, без породження конфлікту імен. Наступний приклад демонструє, як можна вкласти внутрішній клас в довільну область дії:
 
``` java
//: Innerclasses/Parcel6.java
// Вкладення класу в область дії

public class Parcel6 { 
  private void internalTracking(boolean b) { 
    if(b) { 
      class TrackingSlip { 
        private String id; 
        TrackingSlip(String s) { 
          id = s; 
        } 
        String getSlip() { return id; } 
      } 
      TrackingSlip ts = new TrackingSlip("slip"); 
      String s = ts.getSlip(); 
    } 
	// Тут використовувати клас не можна!
	// Поза областю видимості 
	//! TrackingSlip ts = new TrackingSlip("x");
  }  
  public void track() { internalTracking(true); } 
  public static void main(String[] args) { 
    Parcel6 p = new Parcel6(); 
    p.track(); 
  } 
} ///:~ 
```
 
Клас ***TrackingSlip*** вкладений в область дії команди ***if***. Це не означає, що клас створюється в залежності від умови - він компілюється разом з усім іншим кодом. Однак при цьому він недоступний поза контекстом, в якому його було визначено. В іншому він виглядає точно так само, як і звичайний клас. 

## Безіменні внутрішні класи

Наступний приклад виглядає трохи дивно:
 
``` java
//: Innerclasses/Parcel7.java
// Метод повертає екземпляр безіменного внутрішнього класу

public class Parcel7 { 
  public Contents contents() { 
    return new Contents() { // Вставити визначення класу 
      private int i = 11; 
      public int value() { return i; } 
    }; // У даній ситуації крапка з комою необхідна
  } 
  public static void main(String[] args) { 
    Parcel7 p = new Parcel7(); 
    Contents c = p.contents(); 
  } 
} ///:~ 
```
 
Метод ***contents()*** поєднує створення повертаємого значення з визначенням класу, який це значення, що повертається і представляє!
До того ж, цей клас є безіменним - у нього відсутнє ім'я. Ситуація заплутується ще тим, що спочатку ми нібито приступаємо до створення об'єкта ***Contents***, а потім, зупинившись перед крапкою з комою, говоримо: «Стоп, а сюди я підкину визначення класу».
 
Така незвичайна форма запису означає буквально наступне: «Створити об'єкт безіменного класу, який успадкований від ***Contents***». Посилання, яка повертається при цьому з виразу ***new***, автоматично підвищується до базового типу ***Contents***. Синтаксис запису безіменного внутрішнього класу є укороченою формою запису такої конструкції:
 
``` java
//: Innerclasses/Parcel7b.java
// Розширена версія Parcel7.java

public class Parcel7b { 
  class MyContents implements Contents { 
    private int i = 11; 
    public int value() { return i; } 
  } 
  public Contents contents() { return new MyContents(); } 
  public static void main(String[] args) { 
    Parcel7b p = new Parcel7b(); 
    Contents c = p.contents(); 
  } 
} ///:~ 
```
 
У безіменному внутрішньому класі базовий клас ***Contents*** створюється з використанням конструктора за замовчуванням. Наступна програма показує, як слід чинити, якщо базовий клас вимагає виклику конструктора з аргументами:
 
``` java
//: Innerclasses/Parcel8.java
// Виклик конструктора базового класу.

public class Parcel8 {
  public Wrapping wrapping(int x) { 
    // Base constructor call: 
    return new Wrapping(x) { // передача аргументу конструктора.  
      public int value() { 
        return super.value() * 47; 
      } 
    }; // Потрібна крапка з комою
  }
  public static void main(String[] args) { 
    Parcel8 p = new Parcel8(); 
    Wrapping w = p.wrapping(10); 
  } 
} ///:~ 
```
 
Необхідний аргумент просто передається в конструктор базового класу, як в розглянутому прикладі ***х*** в виразі ***new Wrapping(x)***. Хоча це звичайний клас з реалізацією, ***Wrapping*** також використовується в якості загального «інтерфейсу» для своїх похідних класів:
 
``` java
//: innerclasses/Wrapping.java 
public class Wrapping { 
  private int i; 
  public Wrapping(int x) { i = x; } 
  public int value() { return i; } 
} ///:~ 
```
 
Клас ***Wrapping*** має конструктор з аргументом - просто для того, щоб ситуація стала трохи більш цікавою. Крапка з комою в кінці безіменного внутрішнього класу поставлена ​​зовсім не для того, щоб позначити кінець тіла класу (як робиться в *C++*). Замість цього вона вказує на кінець виразу, в якому міститься внутрішній клас. Таким чином, в даному випадку її використання нічим не відрізняється від звичайного. Ініціалізацію також можна провести в точці визначення полів безіменного класу:
 
``` java
//: Innerclasses/Parcel9.java
// Безіменний внутрішній клас, який виконує ініціалізацію. 
// Більш коротка версія програми Parcel5.java

public class Parcel9 {
    // Для використання в безіменному внутрішньому класі 
    // аргументи повинні бути незмінні (final)
    public Destination destination (final String dest) {
        return new Destination () {
            private String label = dest;
            public String readLabel () {return label; }
        };
    }
    public static void main (String [] args) {
        Parcel9 p = new Parcel9 ();
        Destination d = p.destination ( "Tasmania");
    }
} ///:~ 
```
 
Якщо ви визначаєте безіменний внутрішній клас і хочете при цьому використовувати об'єкти, визначені поза цим внутрішнім класом, компілятор вимагає, щоб передані на них посилання оголошувалися незмінними (***final***), як це зроблено аргументі ***destination()***. Без такого оголошення ви отримаєте повідомлення про помилку при компіляції програми.
 
Поки ми обмежуємося простим привласненням значень полів, зазначений підхід працює. А якщо знадобиться виконати деякі дії, властиві конструкторам? У безіменному класі іменований конструктор визначити не можна (раз у самого класу немає імені!), але ініціалізація примірника (*instance initialization*) фактично дозволяє домогтися бажаного ефекту:
 
``` java
//: Innerclasses/AnonymousConstructor.java
// Створення конструктора для безіменного внутрішнього класу. import static net.mindview.util.Print. *;
 
abstract class Base {
    public Base (int i) {
        print ( "Base constructor, i =" + i);
    }
    public abstract void f ();
}

public class AnonymousConstructor {
    public static Base getBase (int i) {
        return new Base (i) {
            {Print ( "Inside instance initializer"); }
            public void f () {
                print ( "In anonymous f ()");
            }
        };
    }
    public static void main (String [] args) {
        Base base = getBase (47);
        base.f ();
    }
} /* Output: 
Base constructor, i = 47 
Inside instance initializer 
In anonymous f() 
*///:~
```
 
В такому випадку змінна ***i*** не зобов'язана бути незмінною (***final***). І хоча ***i*** передається базовому конструктору безіменного класу, вона ніколи не використовується безпосередньо *всередині* безіменного класу. 

Повернемося до наших об'єктів ***Parcel***, на цей раз виконавши для них ініціалізацію примірника. Відзначте, що параметри методу ***destination()*** повинні бути оголошені незмінними, так як вони використовуються всередині безіменного класу:
 
``` java
//: Innerclasses/Parcel10.java
// Демонстрація "ініціалізації екземпляра" для 
// конструювання безіменного внутрішнього класу 
 
public class Parcel10 { 
  public Destination 
  destination(final String dest, final float price) { 
    return new Destination() { 
      private int cost; 
      // Ініціалізація примірника для кожного об'єкта:
      { 
        cost = Math.round(price); 
        if(cost > 100) 
          System.out.println("Over budget!"); 
      } 
      private String label = dest; 
      public String readLabel() { return label; } 
    }; 
  }  
  public static void main(String[] args) { 
    Parcel10 p = new Parcel10(); 
    Destination d = p.destination("Tasmania", 101.395F); 
  } 
} /* Output: 
Over budget! 
*///:~ 
```
 
Всередині ініціалізатора примірника видно код, недоступний при ініціалізації полів (тобто команду ***if***). Тому ініціалізатор примірника фактично є конструктором безіменного внутрішнього класу. Звичайно, можливості його обмежені; перевантажувати такий ініціалізатор не можна, і тому він буде присутній в класі тільки в однині.
 
Можливості безіменних внутрішніх класів дещо обмежені в порівнянні зі звичайним успадкуванням - вони можуть, або розширювати клас, або реалізовувати інтерфейс, але не те й інше одночасно. А якщо ви виберете другий варіант, реалізувати можна тільки один інтерфейс.
 
### Знову про метод-фабрику
 
Подивіться, наскільки приємніше виглядає приклад ***interfaces/Factories.java*** при використанні безіменних внутрішніх класів:
 
``` java
//: innerclasses/Factories.java 
import static net.mindview.util.Print.*; 
 
interface Service { 
  void method1(); 
  void method2(); 
} 
 
interface ServiceFactory { 
  Service getService(); 
}   
 
class Implementation1 implements Service { 
  private Implementation1() {} 
  public void method1() {print("Implementation1 method1");} 
  public void method2() {print("Implementation1 method2");} 
  public static ServiceFactory factory = 
    new ServiceFactory() { 
      public Service getService() { 
        return new Implementation1(); 
      } 
    }; 
}   
 
class Implementation2 implements Service { 
  private Implementation2() {} 
254  Thinking in Java  Bruce Eckel   public void method1() {print("Implementation2 method1");} 
  public void method2() {print("Implementation2 method2");} 
  public static ServiceFactory factory = 
    new ServiceFactory() { 
      public Service getService() { 
        return new Implementation2(); 
      } 
    }; 
}   
 
public class Factories { 
  public static void serviceConsumer(ServiceFactory fact) { 
    Service s = fact.getService(); 
    s.method1(); 
    s.method2(); 
  } 
  public static void main(String[] args) { 
    serviceConsumer(Implementation1.factory); 
    // Реалізації повністю взаємозамінні;
    serviceConsumer(Implementation2.factory); 
  } 
} /* Output: 
Implementation1 method1 
Implementation1 method2 
Implementation2 method1 
Implementation2 method2 
*///:~ 
```
Тепер конструктори ***Implementation1*** і ***Implementation2*** можуть бути закритими, і фабрику необов'язково оформляти у вигляді іменованого класу. Крім того, часто буває досить одного фабричного об'єкта, тому в даному випадку він створюється як статичне поле в реалізації ***Service***. Нарешті, підсумковий синтаксис виглядає більш осмислено. Приклад ***interfaces/Games.java*** теж можна вдосконалити за допомогою безіменних внутрішніх класів:
 
``` java
//: Innerclasses/Games.java
// Використання анонімних внутрішніх класів в бібліотеці Game

import static net.mindview.util.Print.*; 
 
interface Game { boolean move(); } 
interface GameFactory { Game getGame(); } 
 
class Checkers implements Game { 
  private Checkers() {} 
  private int moves = 0; 
  private static final int MOVES = 3; 
  public boolean move() { 
    print("Checkers move " + moves); 
    return ++moves != MOVES; 
  } 
  public static GameFactory factory = new GameFactory() { 
    public Game getGame() { return new Checkers(); } 
  }; 
}   
 
class Chess implements Game { 
  private Chess() {} 
  private int moves = 0; 
  private static final int MOVES = 4; 
  public boolean move() { 
    print("Chess move " + moves); 
    return ++moves != MOVES; 
Inner Classes  255   } 
  public static GameFactory factory = new GameFactory() { 
    public Game getGame() { return new Chess(); } 
  }; 
}   
 
public class Games { 
  public static void playGame(GameFactory factory) { 
    Game s = factory.getGame(); 
    while(s.move()) 
      ; 
  } 
  public static void main(String[] args) { 
    playGame(Checkers.factory); 
    playGame(Chess.factory); 
  } 
} /* Output: 
Checkers move 0 
Checkers move 1 
Checkers move 2 
Chess move 0 
Chess move 1 
Chess move 2 
Chess move 3 
*///:~
```
 
Згадайте пораду, дану в кінці попередньої глави: *віддавати перевагу класам перед інтерфейсами*. Якщо архітектура системи вимагає застосування інтерфейсу, ви це зрозумієте. В інших випадках не застосовуйте інтерфейси без крайньої необхідності. 

## Вкладені класи

Якщо зв'язок між об'єктом внутрішнього класу і об'єктом зовнішнього класу не потрібен, можна зробити внутрішній клас статичним (оголосити його як ***static***). Часто такий клас називають вкладеним (*nested*).
 
Щоб зрозуміти сенс ключового слова ***static*** щодо внутрішніх класів, слід згадати, що в об'єкті звичайного внутрішнього класу таємно зберігається посилання на об'єкт який створив його доступним для зовнішнього класу. При використанні статичного внутрішнього класу такого посилання не існує. Застосування статичного внутрішнього класу означає наступне:

1. Для створення об'єкта статичного внутрішнього класу не потрібен об'єкт зовнішнього класу;
2. З об'єкта вкладеного класу можна звертатися до нестатичних членів зовнішнього класу.

Є і ще одна відмінність між вкладеними і звичайними внутрішніми класами. Поля і методи звичайного внутрішнього класу визначаються тільки на рівні зовнішнього класу, тому звичайні внутрішні класи не можуть містити статичні дані, поля і класи. Але вкладені класи не мають таких обмежень:
 
``` java
//: Innerclasses/Parcel11.java
// Вкладені (статичні внутрішні) класи

public class Parcel11 { 
  private static class ParcelContents implements Contents { 
    private int i = 11; 
    public int value() { return i; } 
  } 
  protected static class ParcelDestination 
  implements Destination { 
    private String label; 
    private ParcelDestination(String whereTo) { 
      label = whereTo; 
    } 
    public String readLabel() { return label; }   
    // Вкладені класи можуть містити інші статичні елементи:
    public static void f() {} 
    static int x = 10; 
    static class AnotherLevel { 
      public static void f() {} 
      static int x = 10; 
    } 
  } 
  public static Destination destination(String s) { 
    return new ParcelDestination(s); 
  } 
  public static Contents contents() { 
    return new ParcelContents(); 
  } 
  public static void main(String[] args) { 
    Contents c = contents(); 
    Destination d = destination("Tasmania"); 
  } 
} ///:~ 
```
 
У методі ***main()*** не потрібно об'єкта класу ***Parcel11***; замість цього для виклику методів, які повертають посилання на ***Contents*** і ***Destination***, використовується звичайний синтаксис звернення до статичних членів класу. Як було сказано раніше, в звичайному (НЕ-статичному) внутрішньому класі для звернення до об'єкта зовнішнього класу використовується спеціальне посилання ***this***. У вкладеному класі таке посилання недійсне (за аналогією зі статичними методами). 

### Класи всередині інтерфейсів

Зазвичай інтерфейс не може містити програмний код, але вкладений клас може стати його частиною. Будь-клас, розміщений всередині інтерфейсу, автоматично є ***public*** і ***static***. Так як клас є статичним, він не порушує правил поводження з інтерфейсом -
цей вкладений клас просто використовує простір імен інтерфейсу. У внутрішньому класі навіть можна реалізувати навколишній інтерфейс:
 
``` java
//: Innerclasses/ClassInInterface.java
// {main: ClassInInterface$Test} 
 
public interface ClassInInterface { 
  void howdy(); 
  class Test implements ClassInInterface { 
    public void howdy() { 
      System.out.println("Howdy!"); 
    } 
    public static void main(String[] args) { 
      new Test().howdy(); 
    } 
  } 
} /* Output: 
Howdy! 
*///:~ 
```
 
Вкладення класів в інтерфейси може стати в нагоді для створення узагальненого коду, використовуваного з різними реалізаціями цього інтерфейсу. Раніше в книзі я пропонував поміщати в кожен клас метод ***main()***, що дозволяє при необхідності протестувати даний клас. Недоліком такого підходу є додатковий скомпільований код, що збільшує розміри програми. Якщо для вас це небажано, використовуйте статичний внутрішній клас для зберігання тестового коду:
 
``` java
//: Innerclasses/TestBed.java
// Приміщення тестового коду у вкладений клас.
// {main: TestBed$Tester} 
 
public class TestBed { 
  public void f() { System.out.println("f()"); } 
  public static class Tester { 
    public static void main(String[] args) { 
      TestBed t = new TestBed(); 
      t.f(); 
    } 
  } 
} /* Output: 
f() 
*///:~ 
```
 
При компіляції цього файлу створюється окремий клас з ім'ям ***TestBed$Tester*** (для запуску тестового коду наберіть команду ***java TestBed$Tester***). Ви можете використовувати цей клас для тестування, але включати його в остаточну версію програми необов'язково; файл ***TestBed$Tester.class*** можна просто видалити перед остаточною збіркою програми. 

### Доступ зовні з багаторазово вкладених класів

Незалежно від глибини вкладення, внутрішній клас завжди може безпосередньо звертатися до всіх членів всіх класів, в які він вбудований. Наступна програма демонструє цей факт:
 
``` java
//: Innerclasses/MultiNestingAccess.java
// Вкладені класи можуть звертатися до всіх членів всіх
// Класів, в яких вони знаходяться. 

class MNA { 
  private void f() {} 
  class A { 
    private void g() {} 
    public class B { 
      void h() { 
        g(); 
        f(); 
      } 
    } 
  } 
}   
 
public class MultiNestingAccess { 
  public static void main(String[] args) { 
    MNA mna = new MNA(); 
    MNA.A mnaa = mna.new A(); 
    MNA.A.B mnaab = mnaa.new B(); 
    mnaab.h(); 
  } 
} ///:~ 
```
 
Як видно з прикладу, в класі ***MNAAB*** методи ***f()*** і ***g()*** викликаються без додаткових описів (незважаючи на те, що вони оголошені як ***private***). Цей приклад також демонструє синтаксис, який слід використовувати при створенні об'єктів внутрішніх класів довільного рівня вкладеності з іншого класу. Синтаксис ***.new*** забезпечує правильну область дії, і вам не доводиться уточнювати ім'я класу при виклику конструктора. 

## Внутрішні класи: навіщо?

До теперішнього моменту ми докладно розглянули синтаксис і семантику роботи внутрішніх класів, але це не дало відповіді на питання, навіщо вони взагалі потрібні. Що ж змусило творців *Java* додати в мову настільки фундаментальна властивість? Зазвичай внутрішній клас успадковує від класу, або реалізує інтерфейс, а код внутрішнього класу маніпулює об'єктом зовнішнього класу, в якому він був створений. Значить, можна сказати, що внутрішній клас - це щось на кшталт «вікна» в зовнішній клас.
 
Виникає резонне питання: «Якщо мені знадобиться посилання на інтерфейс, чому б зовнішньому класу не реалізувати цей інтерфейс?» Відповідь: «Якщо це все, що вам потрібно, - значить, так і слід вчинити». Але що ж відрізняє внутрішній клас, який реалізує інтерфейс, від зовнішнього класу, що реалізує той же інтерфейс? Далеко не завжди вдається використовувати зручність інтерфейсів - іноді доводиться працювати і з реалізацією. Тому найбільш вагома причина для використання внутрішніх класів така: кожен внутрішній клас здатний незалежно успадковувати певну реалізацію. Таким чином, внутрішній клас не обмежений при успадкуванні в ситуаціях, де зовнішній клас вже успадковує реалізацію.
 
Без можливості внутрішніх класів успадковувати реалізацію більш ніж одного реального чи абстрактного класу деякі завдання планування і програмування стають практично нерозв'язними. Тому внутрішній клас виступає як «доважок» рішення проблеми множинного успадкування. Інтерфейси беруть на себе частину цього завдання, тоді як внутрішні класи фактично забезпечують «множинне успадкування реалізації». Іншими словами, внутрішні класи дозволяють успадковуватись від кількох не-інтерфейсів.
 
Щоб зрозуміти все сказане до кінця, розглянемо ситуацію, де два інтерфейси тим чи іншим способом повинні бути реалізовані в класі. Внаслідок гнучкості інтерфейсів можливий один із двох способів вирішення: окремий одиночний клас, або внутрішній клас:
 
``` java
//: Innerclasses/MultiInterfaces.java
// Два способи реалізації декількох інтерфейсів. 
package innerclasses;

interface A {} 
interface B {} 
 
class X implements A, B {} 
 
class Y implements A { 
  B makeB() { 
    // Безіменний внутрішній клас: 
    return new B() {}; 
  } 
} 
 
public class MultiInterfaces { 
  static void takesA(A a) {} 
  static void takesB(B b) {} 
  public static void main(String[] args) { 
    X x = new X(); 
    Y y = new Y(); 
    takesA(x); 
    takesA(y); 
    takesB(x); 
    takesB(y.makeB()); 
  } 
} ///:~ 
```
 
Звичайно, вибір того чи іншого способу організації коду залежить від конкретної ситуації. Втім, сама розв'язувана вами проблема повинна підказати, що для неї важливо: один окремий, чи внутрішній клас. Але при відсутності інших обмежень обидва підходи, використані в розглянутому прикладі, нічим не відрізняються з точки зору реалізації. Обидва вони працюють. Але якщо замість інтерфейсів є реальні, або абстрактні класи і новий клас повинен якось реалізувати функціональність двох інших, доведеться вдатися до внутрішніх класів:
 
``` java
//: Innerclasses/MultiImplementation.java
// При використанні реальних або абстрактних класів
// "Множинне успадкування реалізації" можливо
// Тільки із застосуванням внутрішніх класів
package innerclasses;
 
class D {}
abstract class E {} 
 
class Z extends D { 
  E makeE() { return new E() {}; } 
} 
 
public class MultiImplementation { 
  static void takesD(D d) {} 
  static void takesE(E e) {} 
  public static void main(String[] args) { 
    Z z = new Z(); 
    takesD(z); 
    takesE(z.makeE()); 
  } 
} ///:~ 
```
 
Якщо немає необхідності вирішувати задачу «множинної реалізації успадкування», швидше за все, ви без особливих зусиль напишите програму, не вдаючись до особливостей внутрішніх класів. Однак внутрішні класи відкривають перед вами ряд додаткових можливостей:

1. У внутрішнього класу може існувати довільна кількість екземплярів, кожен з яких володіє власною інформацією стану, що не залежить від стану об'єкта зовнішнього класу.

2. Один зовнішній клас може містити кілька внутрішніх класів, що по-різному реалізують один і той же інтерфейс, або успадковують від єдиного базового класу. Незабаром ми розглянемо приклад такої конструкції.

3. Місце створення об'єкта внутрішнього класу не прив'язане до місця і часу створення об'єкта зовнішнього класу.

4. Внутрішній клас не використовує тип відносин класів «є тим-то», здатних викликати непорозуміння; він являє собою окрему сутність.

Наприклад, якби в програмі ***Sequence.java*** були відсутні внутрішні класи, довелося б заявити, що «клас ***Sequence*** є класом ***Selector***», і при цьому обмежитися тільки одним об'єктом ***Selector*** для конкретного об'єкта ***Sequence***. А ви можете з легкістю визначити другий метод, ***reverseSelector()***, що створює об'єкт ***Selector*** для перебору елементів ***Sequence*** в зворотному порядку. Таку гнучкість забезпечують тільки внутрішні класи. 

### Замикання і зворотні виклики

Замиканням (*closure*) називається викликається об'єкт, який зберігає інформацію про контекст, в якому він був створений. З цього визначення видно, що внутрішній клас є об'єктно-орієнтованим замиканням, оскільки він не тільки містить інформацію про об'єкт зовнішнього класу («місце створення»), але до того ж має посиланням на весь об'єкт зовнішнього класу, за допомогою якого він може маніпулювати всіма членами цього об'єкту, в тому числі і закритими (***private***).
 
Під час обговорення того, чи варто включати в *Java* якусь подобу покажчиків, найвагомішим аргументом «за» була можливість зворотних викликів (*callback*). У механізмі зворотного виклику деякому сторонньому об'єкту передається інформація, що дозволяє йому потім звернутися з викликом до об'єкта, який справив початковий виклик.
 
Це дуже потужна концепція програмування, до якої ми ще повернемося. З іншого боку, при реалізації зворотного виклику на основі покажчиків вся відповідальність за його правильне використання покладається на програміста. Як було показано раніше, мова *Java* орієнтований на безпечне програмування, тому покажчики в нього включені не були. Замикання, що надається внутрішнім класом, - хороше рішення, набагато більш гнучке і безпечне, ніж покажчик. Розглянемо приклад:
 
``` java
//: innerclasses/Callbacks.java
// Використання внутрішніх класів 
// для реалізації зворотних викликів
package innerclasses; 
import static net.mindview.util.Print.*; 
 
interface Incrementable { 
  void increment(); 
} 
 
// Проста реалізація інтерфейсу:
class Callee1 implements Incrementable { 
  private int i = 0; 
  public void increment() { 
    i++; 
    print(i); 
  } 
}   
 
class MyIncrement { 
  public void increment() { print("Other operation"); } 
  static void f(MyIncrement mi) { mi.increment(); } 
}   
 
// Якщо клас повинен викликати метод increment()
// по-іншому, необхідно використовувати внутрішній клас:
class Callee2 extends MyIncrement { 
  private int i = 0; 
  public void increment() { 
    super.increment(); 
    i++; 
    print(i); 
  } 
  private class Closure implements Incrementable { 
    public void increment() { 
      // Вказується метод зовнішнього класу,
      // в іншому випадку виникає нескінченна рекурсія:
      Callee2.this.increment(); 
    } 
  } 
  Incrementable getCallbackReference() { 
    return new Closure(); 
  } 
}   
 
class Caller { 
  private Incrementable callbackReference; 
  Caller(Incrementable cbh) { callbackReference = cbh; } 
  void go() { callbackReference.increment(); } 
} 
 
public class Callbacks { 
  public static void main(String[] args) { 
    Callee1 c1 = new Callee1(); 
    Callee2 c2 = new Callee2(); 
    MyIncrement.f(c2); 
    Caller caller1 = new Caller(c1); 
    Caller caller2 = new Caller(c2.getCallbackReference()); 
    caller1.go(); 
    caller1.go(); 
    caller2.go(); 
    caller2.go(); 
  }  
} /* Output: 
Other operation 
1 
1 
2 
Other operation 
2 
Other operation 
3 
*///:~ 
```
 
Цей приклад також демонструє відмінності між реалізацією інтерфейсу зовнішнім, або внутрішнім класом. Клас ***Callee1*** - найбільш очевидне рішення задачі з точки зору програмування.
 
Клас ***Callee2*** успадковує від класу ***MyIncrement***, в якому вже є метод ***increment***), що виконує дію, ніяк не пов'язаний з тим, що очікує від нього інтерфейс ***Incrementable***. Коли клас ***MyIncrement*** успадковується в ***Callee2***, метод ***increment()*** не можна перевизначити для використання в якості методу інтерфейсу ***Incrementable***, тому нам доводиться надавати окрему реалізацію у внутрішньому класі. Також відзначте, що створення внутрішнього класу не зачіпає і не змінює існуючий інтерфейс зовнішнього класу.
 
Всі елементи, за винятком методу ***getCallbackReference ()***, в класі ***Callee2*** є закритими. Для будь-якого зв'язку з навколишнім світом необхідний інтерфейс ***Incrementable***. Тут ми бачимо, як інтерфейси дозволяють повністю відокремити інтерфейс від реалізації.
 
Внутрішній клас ***Closure*** просто реалізує інтерфейс ***Incrementable***, надаючи при цьому зв'язок з об'єктом ***Callee2*** - але зв'язок ця безпечний. Хоч би хто отримав посилання на ***Incrementable***, він в змозі викликати тільки метод ***increment()***, і інших можливостей у нього немає (на відміну від покажчика, з яким програміст може витворяти все, що завгодно).
 
Клас ***Caller*** отримує посилання на ***Incrementable*** в своєму конструкторі (хоча надіслання адресу для зворотного виклику може відбуватися в будь-який час), а після цього використовує посилання для «зворотного виклику» об'єкта ***Callee***. Головною перевагою зворотного виклику є його гнучкість - ви можете динамічно вибирати функції, які будуть виконуватись під час роботи програми.
 
### Внутрішні класи і система управління
 
Як більш реальний приклад використання внутрішніх класів ми розглянемо те, що я буду називати тут системою управління (*control
framework*).
 
Каркас додатку (*application framework*) - це клас, або набір класів, розроблених для вирішення певного кола завдань. При роботі з каркасами додатків зазвичай використовується успадкування від одного, або декількох класів, з перевизначенням деяких методів. Код перевизначених методів адаптує типове рішення, що надається каркасом додатка, до ваших конкретних потреб.
 
Система управління являє собою певний тип каркаса додатку, основним рушійним механізмом якого є обробка подій. Такі системи називаються системами, керованими по подіях (*event-driven system*). Однією з найтиповіших завдань в прикладному програмуванні є створення графічного інтерфейсу користувача (*GUI*), цілком і повністю орієнтованого на обробці подій.
 
Щоб на наочному прикладі побачити, як із застосуванням внутрішніх класів досягається простота створення і використання бібліотек, ми розглянемо систему, орієнтовану на обробку подій за їх «готовності». Хоча в практичному сенсі під «готовністю» може розумітися все, що завгодно, в нашому випадку вона буде визначатися за показниками лічильника часу. Далі наводиться загальний опис управляючої системи, що ніяк не залежить від того, чим саме вона управляє. Потрібна інформація надається за допомогою успадкування, при реалізації методу ***action()***.
 
Почнемо з визначення інтерфейсу, що описує будь-яку подію системи. Замість інтерфейсу тут використовується абстрактний клас, оскільки за замовчуванням управління координується за часом. Тому часткова реалізація включена тут:
 
``` java
//: Innerclasses/controller/Event.java
// Загальні для всякого керуючого події методи. 
package innerclasses.controller;

public abstract class Event {
    private long eventTime;
    protected final long delayTime;
    public Event (long delayTime) {
        this.delayTime = delayTime;
        start ();
    }
    public void start () {// Дозволяє перезапуск 
        eventTime = System.nanoTime () + delayTime;
    }
    public boolean ready () {
        return System.nanoTime ()> = eventTime;
    }
    public abstract void action ();
} ///:~ 
```
 
Конструктор просто запам'ятовує час (від моменту створення об'єкта), через який повинна виконуватися подія ***Event***, і після цього викликає метод ***start()***, який додає до поточного часу інтервал затримки, щоб обчислити час виникнення події. Метод ***start()*** відділений від конструктора, завдяки чому стає можливим «перезапуск» події після того, як його час вже минув; таким чином, об'єкт ***Event*** можна використовувати багаторазово. Скажімо, якщо вам знадобиться подія що повторюється, досить додати виклик ***start()*** в метод ***action()***.
 
Метод ***ready()*** повідомляє, що пора діяти - викликати метод ***action()***. Звичайно, метод ***ready()*** може бути перевизначений будь-яким похідним класом, якщо подія ***Event*** активізується не по часу, а по іншій умові.
 
Наступний файл описує саму систему управління, яка розпоряджається подіями і ініціює їх. Об'єкти ***Event*** містяться в контейнері ***List<Event>***. На даний момент досить знати, що метод ***add()*** приєднує об'єкт ***Event*** до кінця контейнера з типом ***List***, метод ***size()*** повертає кількість елементів в контейнері, синтаксис ***foreach()*** здійснює послідовну вибірку елементів ***List***, а метод ***remove()*** видаляє заданий елемент з контейнера:
 
``` java
//: Innerclasses/controller/Controller.java
// Узагальнена система управління
package innerclasses.controller; 
import java.util.*; 
 
public class Controller { 
  // A class from java.util to hold Event objects: 
  private List<Event> eventList = new ArrayList<Event>(); 
  public void addEvent(Event c) { eventList.add(c); } 
  public void run() { 
    while(eventList.size() > 0) 
      // Make a copy so you’re not modifying the list 
      // while you’re selecting the elements in it: 
      for(Event e : new ArrayList<Event>(eventList)) 
        if(e.ready()) { 
          System.out.println(e); 
          e.action(); 
          eventList.remove(e); 
        } 
  } 
} ///:~ 
```
 
Метод ***run()*** в циклі перебирає копію ***eventList*** в пошуках подій ***Event***, готових для виконання. Для кожного знайденого елемента він виводить інформацію про об'єкт методом ***toString ()***, викликає метод ***action()***, а після цього видаляє подію з списку. 

Зауважте, що в цій архітектурі зовсім неважливо, що конкретно виконує якась подія ***Event***. В цьому і полягає «родзинка»
розробленої системи; вона відокремлює постійну складову від зміної. «Вектором змін» є різні дії різноманітних подій ***Event***, що виражаються за допомогою створення різних субклассов ***Event***. На цьому етапі в справу вступають внутрішні класи. Вони дозволяють домогтися двох цілей:

1. Вся реалізація системи управління створюється в одному класі, з повною інкапсуляцією всієї специфіки даної реалізації. Внутрішні класи використовуються для представлення різних різновидів ***action()***, необхідних для вирішення задачі.

2. Внутрішні класи допомагають уникнути громіздкої, незручною реалізації, так як у них є доступ до зовнішнього класу. Без цієї можливості програмний код дуже швидко стане настільки неприємним, що вам захочеться пошукати інші альтернативи.

Розглянемо конкретну реалізацію системи управління, розроблену для управління функціями оранжереї. Всі події - включення світла, води і нагрівачів, дзвінок і перезапуск системи - абсолютно різнорідні. Однак система управління розроблена так, що відмінності в коді легко ізолюються. Внутрішні класи допомагають успадкувати кілька похідних версій одного базового класу ***Event*** в межах одного класу. Для кожного типу події від ***Event*** успадковується новий внутрішній клас, і в його реалізації ***action()*** записується керуючий код. Як це зазвичай буває при використанні каркасів додатків, клас ***GreenhouseControls*** успадковується від класу ***Controller***:
 
``` java
//: Innerclasses/GreenhouseControls.java
// Приклад конкретного додатка на основі системи
// Управління, все знаходиться в одному класі. внутрішні
// Класи дають можливість инкапсулировать різну
// Функціональність для кожного окремого події 
import innerclasses.controller. *;

public class GreenhouseControls extends Controller {
    private boolean light = false;
    public class LightOn extends Event {
        public LightOn (long delayTime) {super (delayTime); }
        public void action () {
            // Сюди поміщається апаратний виклик
            // фізичне включення світла 
            light = true;
        }
        public String toString () {return "Light is on"; }
    }
    public class LightOff extends Event {
        public LightOff (long delayTime) {super (delayTime); }
        public void action () {
            // Сюди поміщається апаратний виклик 
            // фізичне вимикання світла 
            light = false;
        }
        public String toString () {return "Light is off"; }
    }
    private boolean water = false;
    public class WaterOn extends Event {
        public WaterOn (long delayTime) {super (delayTime); }
        public void action () {
            // Сюди поміщається апаратний виклик. 
            // Вимикання системи поливу 
            water = true;
        }
        public String toString () {
            return "Greenhouse water is on";
        }
    }
    public class WaterOff extends Event {
        public WaterOff (long delayTime) {super (delayTime); }
        public void action () {
            // Сюди поміщається апаратний виклик. 
            // Вимикання системи поливу 
            water = false;
        }
        public String toString () {
            return "Greenhouse water is off";
        }
    }
    private String thermostat = "Day";
    public class ThermostatNight extends Event {
        public ThermostatNight (long delayTime) {
            super (delayTime);
        }
        public void action () {
            // Сюди поміщається апаратний виклик. 
            // Thermostat = "Ніч";
            thermostat = "Night";
        }
        public String toString () {
            return "Thermostat on night setting";
        }
    }
    public class ThermostatDay extends Event {
        public ThermostatDay (long delayTime) {
            super (delayTime);
        }
        public void action () {
            // Сюди поміщається апаратний виклик. 
            // Thermostat = "День"
            thermostat = "Day";
        }
        public String toString () {
            return "Thermostat on day setting";
        }
    }
    // Приклад методу action(), що вставляє 
    // самого себе в список подій. 
    public class Bell extends Event {
        public Bell (long delayTime) {super (delayTime); }
        public void action () {
            addEvent (new Bell (delayTime));
        }
        public String toString () {return "Bing!"; }
    }
    public class Restart extends Event {
        private Event [] eventList;
        public Restart (long delayTime, Event [] eventList) {
            super (delayTime);
            this.eventList = eventList;
            for (Event e   : eventList)
                addEvent (e);
        }
        public void action () {
            for (Event e   : eventList) {
                e.start (); // Перезапуск кожен раз 
                addEvent (e);
            }
            start (); // Перезапуск цієї події
            addEvent (this);
        }
        public String toString () {
            return "Restarting system";
        }
    }
    public static class Terminate extends Event {
        public Terminate (long delayTime) {super (delayTime); }
        public void action () {System.exit (0); }
        public String toString () {return "Terminating"; }
    }
}
```
 
Зауважте, що поля ***light, thermostat*** і ***ring*** належать зовнішньому класу ***GreenhouseControls***, і все ж внутрішні класи мають можливість звертатися до них, не використовуючи особливих ​​записів і не запитуючи особливих дозволів. Більшість методів ***action()*** вимагає управління обладнанням оранжереї, що, швидше за все, приверне в програму сторонні низькорівневі виклики.
 
В основному класи ***Event*** схожі один на одного, проте класи ***Bell*** і ***Restart*** представляють собою особливі випадки. ***Bell*** видає звуковий сигнал і додає себе в список подій, щоб дзвінок пізніше спрацював знову. Зауважте, що внутрішні класи діють майже як множинне успадкування: класи ***Bell*** і ***Restart*** мають доступ до всіх методів класу ***Event***, а також до всіх методів зовнішнього класу ** *GreenhouseControls***.
 
Класу ***Restart*** передається масив об'єктів ***Event***, які він додає в контролер. Так як ***Restart*** також є об'єктом ***Event***, ви можете додати цей об'єкт в список подій в методі ***Restart.action()***, щоб система регулярно перезапускати.
 
Наступний клас налаштовує систему, створюючи об'єкт ***GreenhouseControls*** і додаючи в нього різноманітні типи об'єктів ***Event***. Це приклад шаблону проектування «команда» - кожен об'єкт в ***EventList*** являє собою запит, інкапсульований в об'єкті:
 
``` java
//: innerclasses/GreenhouseController.java 
// Configure and execute the greenhouse system. 
// {Args: 5000} 
import innerclasses.controller.*; 
 
public class GreenhouseController { 
  public static void main(String[] args) { 
    GreenhouseControls gc = new GreenhouseControls(); 
    // Замість жорсткого кодування фіксованих даних
    // Можна було б вважати інформацію для налаштування
    // З текстового файлу:
    gc.addEvent(gc.new Bell(900)); 
    Event[] eventList = { 
      gc.new ThermostatNight(0), 
      gc.new LightOn(200), 
      gc.new LightOff(400), 
      gc.new WaterOn(600), 
      gc.new WaterOff(800), 
      gc.new ThermostatDay(1400) 
    };   
    gc.addEvent(gc.new Restart(2000, eventList)); 
    if(args.length == 1) 
      gc.addEvent( 
        new GreenhouseControls.Terminate( 
          new Integer(args[0]))); 
    gc.run(); 
  } 
} /* Output: 
Bing! 
Thermostat on night setting 
Light is on 
Light is off 
Greenhouse water is on 
Greenhouse water is off 
Thermostat on day setting 
Restarting system 
Terminating 
*///:~ 
```
 
Клас ініціалізує систему, включаючи в неї потрібні події. Якщо передати програмі параметр командного рядка, вона завершується після закінчення заданого кількості мілісекунд (використовується при тестуванні). Звичайно, щоб програма стала більш гнучкою, опис подій слід було б не включати в програмний код, а завантажувати з файлу. Цей приклад допоможе зрозуміти всю цінність механізму внутрішніх класів, особливо у випадку з системами управління. 

## Успадкування від внутрішніх класів

Так як конструктор внутрішнього класу зв'язується з посиланням на навколишній зовнішній об'єкт, успадкування від внутрішнього класу виходить трохи складніше, ніж звичайне. Проблема полягає в тому, що «приховане» посилання на об'єкт зовнішнього класу повинне бути ініціалізоване, а в похідному класі більше не існує осяжний об'єкта за замовчуванням. Для явного вказівника осяжного зовнішнього об'єкта застосовується спеціальний синтаксис:
 
``` java
//: Innerclasses/InheritInner.java
// Успадкування від внутрішнього класу.
class WithInner {
    class Inner {}
}

public class InheritInner extends WithInner.Inner {
    //! InheritInner () {} // He компілюється
    InheritInner (WithInner wi) {
        wi.super ();
    }
    public static void main (String [] args) {
        WithInner wi = new WithInner ();
        InheritInner ii = new InheritInner (wi);
    }
} ///:~ 
```
 
Тут клас ***InheritInner*** розширює тільки внутрішній клас, а не зовнішній. Але коли справа доходить до створення конструктора, пропонований за замовчуванням конструктор не підходить, і ви не можете просто передати посилання на зовнішній об'єкт. Необхідно включити в тіло конструктора вираз 

ссилкаНаОб'емлющійКласс.super();
enclosingClassReference.super();

в тілі конструктора. Воно забезпечить необхідне посилання, і програма відкомпілюється.
 
## Чи можна перевизначити внутрішній клас?
 
Що відбувається, якщо ви створюєте внутрішній клас, потім успадковуєте від його зовнішнього класу, а після цього заново описуєте внутрішній клас в похідному класі? Іншими словами, чи можна перевизначити внутрішній клас? Це було б досить цікаво, але «перевизначення» внутрішнього класу, як якщо б він був ще одним методом зовнішнього класу, фактично не має ніякого ефекту:
 
``` java
//: Innerclasses/BigEgg.java
// Внутрішній клас не можна перевизначити
// подібно до звичайного методу

import static net.mindview.util.Print.*; 
 
class Egg { 
  private Yolk y; 
  protected class Yolk { 
    public Yolk() { print("Egg.Yolk()"); } 
  } 
  public Egg() { 
    print("New Egg()"); 
    y = new Yolk(); 
  } 
}   
 
public class BigEgg extends Egg { 
  public class Yolk { 
    public Yolk() { print("BigEgg.Yolk()"); } 
  } 
  public static void main(String[] args) { 
    new BigEgg(); 
  } 
} /* Output: 
New Egg() 
Egg.Yolk() 
*///:~ 
```
 
Конструктор за замовчуванням автоматично синтезується компілятором, а в ньому викликається конструктор за замовчуванням з базового класу. Можна подумати, що при створенні об'єкта ***BigEgg*** повинно використовуватися «перевизначений» клас ***Yolk***, але це аж ніяк не так, як видно з результату роботи програми.
 
Цей приклад просто показує, що при успадкуванні від зовнішнього класу нічого особливого з внутрішніми класами не відбувається. Два внутрішніх класу - абсолютно окремі складові, з незалежними просторами імен. Втім, можливість явного успадкування від внутрішнього класу збереглася:
 
``` java
//: Innerclasses/BigEgg2.java
// Правильне успадкування внутрішнього класу. 
import static net.mindview.util.Print.*; 
 
class Egg2 { 
  protected class Yolk { 
    public Yolk() { print("Egg2.Yolk()"); } 
    public void f() { print("Egg2.Yolk.f()");} 
  } 
  private Yolk y = new Yolk(); 
  public Egg2() { print("New Egg2()"); } 
  public void insertYolk(Yolk yy) { y = yy; } 
  public void g() { y.f(); } 
}   
 
public class BigEgg2 extends Egg2 { 
  public class Yolk extends Egg2.Yolk { 
    public Yolk() { print("BigEgg2.Yolk()"); } 
    public void f() { print("BigEgg2.Yolk.f()"); } 
  } 
  public BigEgg2() { insertYolk(new Yolk()); } 
  public static void main(String[] args) { 
    Egg2 e2 = new BigEgg2(); 
    e2.g(); 
  } 
} /* Output: 
Egg2.Yolk() 
New Egg2() 
Egg2.Yolk() 
BigEgg2.Yolk() 
BigEgg2.Yolk.f() 
*///:~
```
 
Тепер клас ***BigEgg2.Yolk*** явно розширює клас ***Egg2.Yolk*** і перевизначає його методи. Метод ***insertYolk()*** дозволяє класу ***BigEgg2*** підвищити один зі своїх об'єктів ***Yolk*** до посилання у в класі ***Egg2***, тому при виклику ***y.f()*** в методі ***g()*** використовується перевизначена версія ***f()***. Другий виклик *** Egg2.Yolk()*** - це виклик конструктора базового класу з конструктора класу ***BigEgg2.Yolk***. Ми також бачимо, що при виклику методу ***g()*** використовується «оновлена» версія методу. 

## Локальні внутрішні класи

Як було відмічено раніше, внутрішні класи також можуть створюватися в блоках коду - найчастіше в тілі методу. Локальний внутрішній клас не може мати специфікатор доступу, так як він не є частиною зовнішнього класу, але для нього доступні всі незмінні (***final***)
змінні поточного блоку і всі члени зовнішнього класу. Наступний приклад порівнює процеси створення локального внутрішнього класу і безіменного внутрішнього класу:
 
``` java
//: Innerclasses/LocalInnerClass.java
// Зберігає послідовність об'єктів 
import static net.mindview.util.Print.*; 
 
interface Counter { 
  int next(); 
}   
 
public class LocalInnerClass { 
  private int count = 0; 
  Counter getCounter(final String name) { 
    // Локальний внутрішній клас: 
    class LocalCounter implements Counter { 
      public LocalCounter() { 
        // У локального внутрішнього класу
        // може бути власний конструктор:
        print("LocalCounter()"); 
      } 
      public int next() { 
        printnb(name); // Access local final 
        return count++; 
      } 
    } 
    return new LocalCounter(); 
  }  
  // Tе ж саме з безіменним внутрішнім класом:
  Counter getCounter2(final String name) { 
    return new Counter() { 
      // У безіменного внутрішнього класу не може бути 
      // іменованого конструктора, «легальна» тільки 
      // ініціалізація екземпляром:
      { 
        print("Counter()"); 
      } 
      public int next() { 
        printnb(name); // Access local final 
        return count++; 
      } 
    }; 
  }  
  public static void main(String[] args) { 
    LocalInnerClass lic = new LocalInnerClass(); 
    Counter 
      c1 = lic.getCounter("Local inner "), 
      c2 = lic.getCounter2("Anonymous inner "); 
    for(int i = 0; i < 5; i++) 
      print(c1.next()); 
    for(int i = 0; i < 5; i++) 
      print(c2.next()); 
  } 
} /* Output: 
LocalCounter() 
Counter() 
Local inner 0 
Local inner 1 
Local inner 2 
Local inner 3 
Local inner 4 
Anonymous inner 5 
Anonymous inner 6 
Anonymous inner 7 
Anonymous inner 8 
Anonymous inner 9 
*///:~ 
```
 
Об'єкт ***Counter*** повертає наступне по порядку значення. Він реалізований і як локальний клас, і як безіменний внутрішній клас, з однаковими поведінкою і характеристиками. Оскільки ім'я локального внутрішнього класу недоступно за межами методу, доводом для застосування локального класу замість безіменного внутрішнього може бути необхідність в іменованому конструкторі і/або
перевантажених конструкторах; безіменні внутрішні класи допускають тільки ініціалізацію екземпляром. Інша причина для використання локального внутрішнього класу замість безіменного внутрішнього - необхідність створення більш ніж одного об'єкта такого класу.
 
## Ідентифікатори внутрішніх класів
 
Так як кожен клас компілюється в файл з розширенням ***.class***, що містить повну інформацію про створення його примірників (ця інформація міститься в «мета-класі», що званий як об'єкт ***Class***), напрошується припущення, що внутрішні класи також створюють файли ***.class*** для зберігання інформації про свої об'єкти ***Class***. Імена цих файлів-класів будуються за жорстко заданою схемою: ім'я осяжного зовнішнього класу, потім символ ***$*** і ім'я внутрішнього класу. Наприклад, для програми ***LocallnnerClass.java*** створюються такі файли з розширенням ***.class***:

```
Counter.class
LocalInnerClass$2.class
LocalInnerClass$lLocalCounter.class
LocalInnerClass.class
```

Якщо внутрішні класи є безіменними, компілятор використовує в якості їх ідентифікаторів номера. Якщо внутрішні класи вкладені в інші внутрішні класи, їх імена просто приєднуються після символу ***$*** і ідентифікаторів всіх зовнішніх класів. Хоча така схема побудови внутрішніх імен проста і прямолінійна, вона цілком надійна і працює практично в будь-яких ситуаціях. Так як вона є стандартною для мови *Java*, усі отримані файли автоматично стають платформно-незалежними.
 
## Резюме
 
Інтерфейси і внутрішні класи - вельми нетривіальні концепції, і в багатьох інших об'єктно-орієнтованих мовах ви їх не знайдете. Наприклад, в *C++* немає нічого схожого. Разом вони вирішують ті завдання, які *C++* намагається вирішити із застосуванням множинного успадкування. Однак множинне успадкування *C++* створює масу проблем; в порівнянні з ним інтерфейси і внутрішні класи *Java* набагато доступніші.
 
Хоча самі по собі ці механізми не так вже й складні, рішення про їх використання приймається на рівні проектування (як і у випадку з поліморфізмом). Згодом ви навчитеся відразу оцінювати, де велику вигоду дасть інтерфейс, де внутрішній клас, а де потрібні обидві можливості відразу. А поки досить хоча б в загальних рисах ознайомитися з їх синтаксисом і семантикою.
 