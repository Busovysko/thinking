# Все є об'єктом
 
Хоча мова *Java* заснована на *C++*, вона є більш «чистокровною» об'єктно-орієнтованою мовою програмування. Як *C++*, так і *Java* відносяться до сімейства змішаних мов, але для творців *Java* ця неоднорідність була не так важлива, якщо порівнювати з *C++*. Змішана мова дозволяє використовувати кілька стилів програмування; причиною змішаної природи *C++* стало бажання зберегти сумісність з мовою *C*. Так як мова *C++* є надбудовою мови *C*, вона включає в себе багато небажаних характеристик свого попередника, що призводить до зайвого ускладнення деяких аспектів цієї мови. Мова програмування *Java* має на увазі, що ви займаєтеся тільки об'єктно-орієнтованим програмуванням. А це означає, що перш, ніж почати з нею працювати, потрібно «переключитися» на поняття об'єктно-орієнтованого світу (якщо ви вже цього не зробили). Вигода від цього початкового зусилля - можливість програмувати на мові, яка по простоті вивчення і використання перевершує всі інші мови ООП. У цьому розділі ми розглянемо основні компоненти *Java*-програми і дізнаємося, що в *Java* (майже) все є об'єктом.
 
## Для роботи з об'єктами використовуються посилання
 
Кожна мова програмування має свої засоби маніпуляції даними. Іноді програмісту доводиться бути постійно в курсі, які саме маніпуляції проводяться в програмі. Ви працюєте з самим об'єктом, або ж з якимось видом його непрямого представленням (вказівник в *C*, або в *C++*), що потребує особливого синтаксису. 

Всі ці відмінності спрощені в *Java*. Ви трактуєте все як з об'єкт, і тому всюди використовується єдиний послідовний синтаксис. Хоча ви трактуєте все як об'єкт, ідентифікатор, яким ви маніпулюєте, насправді являє собою посилання на об'єкт. Уявіть собі телевізор (об'єкт) з пультом дистанційного керування (посилання). Під час володіння цим посиланням у вас є зв'язок з телевізором, але при перемиканні каналу, або зменшенні гучності ви розпоряджаєтесь посиланням, яке, в свою чергу, маніпулює об'єктом. А якщо вам захочеться перейти в інше місце кімнати, все ще керуючи телевізором, ви берете з собою «посилання», а не сам телевізор. Також пульт може існувати сам по собі, без телевізора. Таким чином, сам факт наявності посилання ще не означає наявності приєднаного до неї об'єкта. Наприклад, для зберігання слова, або речення створюється посилання **String**:
 
``` java
String s;
```
 
Однак тут визначається тільки посилання, але не об'єкт. Якщо ви вирішите надіслати повідомлення **s**, відбудеться помилка, тому що посилання **s** насправді ні до чого не приєднано (телевізора немає). Значить, безпечніше завжди форматувати посилання при його створенні:
 
``` java
String s = "asdf";
```
 
В даному прикладі використовується спеціальна можливість *Java*: ініціалізація рядків текстом в лапках. Зазвичай ви будете використовувати більш загальний спосіб ініціалізації об'єктів.
 
## Всі об'єкти повинні створюватися явно
 
Коли ви визначаєте посилання, бажано приєднати його до нового об'єкту. В основному це робиться за допомогою ключового слова **new**. Фактично воно означає: «Створіть мені новий об'єкт». У попередньому прикладі можна написати:
 
``` java
String s = new String ( "asdf");
```
 
Це не тільки означає «надайте мені новий об'єкт **String**», але також вказує, як створити рядок за допомогою передачі початкового набору символів. Звичайно, крім **String**, в *Java* є безліч готових типів. Важливіше те, що ви можете створювати свої власні типи. Взагалі кажучи, саме створення нових типів стане вашим основним заняттям при програмуванні на *Java*, і саме його ми будемо розглядати в книзі.
 
### Де зберігаються дані
 
Корисно чітко уявляти, що відбувається під час роботи програми - і зокрема, як дані розміщуються в пам'яті. Існує п'ять різних місць для зберігання даних:
 
1. **Регістри.** Це найшвидше сховище, тому що дані зберігаються прямо всередині процесора. Однак кількість регістрів жорстко обмежена, тому регістри використовуються компілятором в міру необхідності. У вас немає прямого доступу до регістрів, ви не зможете знайти і найменших слідів їх підтримки в мові. (З іншого боку, мови *C* і *C++* дозволяють порекомендувати компілятору зберігати дані в регістрах.)
2. **Стек.** Ця область зберігання даних знаходиться в загальній оперативної пам'яті (RAM), але процесор надає прямий доступ до неї з використанням покажчика стека. Покажчик стека переміщається вниз для виділення пам'яті, або вгору, щоб вона вийшла. Це надзвичайно швидкий і ефективний спосіб розміщення даних, за швидкістю поступається тільки регістрам. Під час обробки програми компілятор *Java* повинен знати життєвий цикл даних, що розміщуються в стек. Це обмеження зменшує гнучкість ваших програм, тому, хоча деякі дані *Java* зберігаються в стеку (особливо посилання на об'єкти), самі об'єкти *Java* не поміщаються в стек.
3. **Куча.** Пул пам'яті загального призначення (знаходиться також в RAM), в якому розміщуються всі об'єкти *Java*. Перевага купи полягає в тому, що компілятору не обов'язково знати, як довго проіснують об'єкти, що там знаходяться. Таким чином, робота з купою дає значну перевагу в гнучкості. Коли вам потрібно створити об'єкт, ви пишете код з використанням **new**, і пам'ять виділяється з купи під час виконання програми. Звичайно, за гнучкість доводиться розплачуватися: виділення пам'яті з купи займає більше часу, ніж в стеці (навіть якби ви могли явно створювати об'єкти в стеку, як в *C++*).
4. **Постійна пам'ять.** Значення констант часто вбудовуються прямо в код програми, так як вони незмінні. Іноді такі дані можуть розміщуватися в постійній пам'яті (ROM), якщо мова йде про «вбудовані» системи.
5. **Не-оперативна пам'ять.** Якщо дані розташовуються поза програмою, вони можуть існувати і тоді, коли вона не виконується. Два основних приклади: потокові об'єкти (*streamed objects*), в яких об'єкти представлені у вигляді потоку байтів, зазвичай використовуються для передачі на інші машини, і довгоживучі (*persistent*) об'єкти, які запам'ятовуються на диску і зберігають свій стан навіть після закінчення роботи програми. Особливістю цих видів зберігання даних є можливість переведення об'єктів в щось, що може бути збережено на іншому носії інформації, а потім відновлено у вигляді звичайного об'єкта, що зберігається в оперативній пам'яті. В *Java* організована підтримка легкого (*lightweight*) збереження стану, а такі механізми, як JDBC і Hibernate, надають більш досконалу підтримку збереження та вибірки інформації про об'єкти з баз даних.
 
 
### Особливий випадок: примітивні типи
 
Одна з груп типів, часто застосовуються при програмуванні, вимагає особливого поводження. Їх можна назвати «примітивними» типами (табл. 2.1). Причина для особливого поводження полягає в тому, що створення об'єкта за допомогою **new** - особливо маленької простий змінної - недостатньо ефективно, так як **new** поміщає об'єкти в купу. У таких випадках *Java* наслідує приклад мов *C* і *C++*. Тобто замість створення змінної за допомогою **new** створюється «автоматична» змінна, *ще не являється посиланням*. Змінна безпосередньо зберігає значення і розташовується в стеці, так що операції з нею набагато продуктивніші.
 
В *Java* розміри всіх примітивних типів жорстко фіксовані. Вони не змінюються з переходом на іншу машинну архітектуру, як це відбувається в багатьох інших мовах. Непорушність розміру - одна з причин поліпшеною переносимості *Java*-npoгpaмм.
 
** Таблиця 2.1. Примітивні типи **
 
| Примітивний тип                      | Розмір, біт    | мінімум   | максимум  | Тип упаковки    |
|: ----------------------------------- |: ------------- |: -------- | --------- |: -------------- |
| boolean (логічні значення)           | -              | -         | -         | Boolean         |
| char (символьні значення)            | 16             | Unicode 0 | Unicode 2\^16-1 | Character |
| byte (байт)                          | 8              | -128      | +127      | Byte            |
| short (короткий ціле)                | 16             | -2\^15    | +2\^15-1  | Short           |
| int (ціле)                           | 32             | -2\^31    | +2\^31-1  | Integer         |
| long (довге ціле)                    | 64             | -2\^63    | +2\^63-1  | Long            |
| float (число з плаваючою комою)      | 32             | IEEE754   | IEEE754   | Float           |
| double (число з підвищеною точністю) | 64             | IEEE754   | IEEE754   | Double          |
| void (пусте значення)                | -              | -         | -         | Void            |
 
Всі числові значення є знаковими, так що не шукайте слова *unsigned*.
 
Розмір типу **boolean** явно не визначається; вказується лише те, що цей тип може набувати значень **true** і **false**.
 
«Класи-обгортки» дозволяють створити в кучі не-примітивний об'єкт для подання примітивного типу. Наприклад:
 
``` java
char c = 'х';
Character ch = new Character (c);
```
 
Також можна використовувати такий синтаксис:
 
``` java
Character ch = new Character ( 'x');
```
 
Механізм *автоматичної упаковки* Java SE5 автоматично перетворює примітивний тип в об'єктну «обгортку»:
 
``` java
Character ch = 'х';
```
 
і назад:
 
``` java
char з = ch;
```
 
Причини створення подібних конструкцій будуть пояснені в наступних розділах.
 
#### Числа підвищеної точності
 
В *Java* існує два класи для проведення арифметичних операцій підвищеної точності: **BigInteger** і **BigDecimal**. Хоча ці класи приблизно підходять під визначення «класів-обгорток», жоден з них не має аналога серед примітивних типів. Обидва класи містять методи, що виконують операції, аналогічні тим, що виконуються над примітивними типами. Інакше кажучи, з класами **Biglnteger** і **BigDecimal** можна робити те ж, що з **int**, або **float**, просто для цього використовуються виклики методів, а не вбудовані операції. Також через використання збільшеного обсягу даних операції займають більше часу. Доводиться жертвувати швидкістю заради точності.
 
Клас **BigInteger** підтримує цілі числа довільної точності. Це означає, що ви можете використовувати цілочисельні значення будь-якої величини без втрати даних під час операцій.
 
Клас **BigDecimal** представляє числа з фіксованою комою довільної точності; наприклад, вони можуть застосовуватися для фінансових обчислень. За подробицями про конструкторах і методах цих класів звертайтеся до документації *JDK*.
 
### Масиви в *Java*
 
Фактично всі мови програмування підтримують масиви. Використання масивів у *C* і *C++* небезпечно, тому що масиви в цих мовах є звичайними блоки пам'яті. Якщо програма спробує отримати доступ до масиву за межами його блоку пам'яті, або використовувати пам'ять без попередньої ініціалізації (типові помилки при програмуванні), наслідки можуть бути непередбачувані.
 
Однією з основних цілей *Java* є безпека, тому багато проблем, що докучали програмістам на *C* і *C++*, не існує в *Java*. Масив в *Java* гарантовано ініціалізується, до нього не можна отримати доступ за його межами. Перевірка меж масиву обходиться відносно дорого, як і перевірка індексу під час виконання, але передбачається, що підвищення безпеки і зростання продуктивності варті того (до того ж *Java* іноді може оптимізувати ці операції). При оголошенні масиву об'єктів насправді створюється масив посилань, і кожне з цих посилань автоматично ініціалізується спеціальним значенням, представленим ключовим словом **null**. Воно означає, що посилання насправді не вказує на об'єкт. Вам необхідно приєднувати об'єкт до кожного посилання перед тим, як його використовувати, або при спробі звернення за посиланням **null** під час виконання програми відбудеться помилка. Таким чином, типовим помилкам при роботі з масивами в *Java* запобігають завчасно.
 
Також можна створювати масиви найпростіших типів. І знову компілятор гарантує ініціалізацію - виділена для нового масиву пам'ять заповнюється нулями. Масиви будуть докладніше описані в наступних розділах.
 
# Вам ніколи не потрібно видаляти об'єкт
 
У більшості мов програмування концепція життєвого циклу змінної вимагає помітних зусиль з боку програміста. Скільки «живе» змінна? Якщо її необхідно видалити, коли це слід робити? Плутанина з термінами існування змінних може призвести до багатьох помилок, і цей розділ показує, наскільки *Java* спрощує вирішення даного питання, виконуючи всю роботу по видаленню за вас.
 
## Обмеження області дії
 
У більшості процедурних мов існує поняття області дії (*scope*). Область дії визначає як видимість, так і термін життя імен, визначених всередині неї. В *C*, *C ++* і *Java* область дії встановлюється положенням фігурних дужок **{}**. Наприклад:
 
``` java
{
	int х = 12;
	// Доступно тільки х
		{
		int q = 96;
		// Доступні як х, так і q
		}
	// Доступно ТІЛЬКИ x
	// q знаходиться "за межами видимості"
}
```
 
Змінна, визначена всередині області дії, доступна тільки в межах цієї області. Весь текст після символів **//** і до кінця рядка є коментарем. Відступи спрощують читання програми на *Java*. Так як *Java* відноситься до мов з вільним форматом, додаткові пробіли, табуляція і переклади рядків не впливають на результуючу програму.
 
Врахуйте, що наступна конструкція не дозволена, хоча в *C* і *C++* вона можлива:
 
``` java
{
int х = 12;
	{
	int х = 96;
	// невірно
	}
}
```
 
Компілятор видасть, що змінна **х** вже була визначена. Таким чином, можливість мов *C* і *C++* «ховати» змінні у зовнішній області дії не підтримується. Творці *Java* порахували, що вона призводить до зайвого ускладнення програм.
 
## Область дії об'єктів
 
Об'єкти *Java* мають інший час життя в порівнянні з примітивами. Об'єкт, створений оператором *Java* **new**, буде доступний аж до кінця області дії. Якщо ви напишете:
 
``` java
{
String s = new String ( "рядок");
} // Кінець області дії
```
 
то посилання **s** зникне в кінці області дії. Однак об'єкт типу **String**, на який вказувало **s**, все ще буде займати пам'ять. У показаному фрагменті коду неможливо отримати доступ до об'єкту, тому що єдине посилання вийшло за межі видимості. У наступних розділах ви дізнаєтеся, як передаються посилання на об'єкти і як їх можна копіювати під час роботи програми.
 
Завдяки тому, що об'єкти, створені **new**, існують рівно стільки, скільки вам потрібно, в *Java* зникає цілий пласт проблем, властивих *C++*. В *C++* доводиться не тільки стежити за тим, щоб об'єкти продовжували існувати протягом свого життєвого циклу, але і видаляти об'єкти після завершення роботи з ними.
 
Виникає цікаве питання. Якщо в *Java* об'єкти залишаються в пам'яті, що ж заважає їм поступово зайняти всю пам'ять і зупинити виконання програми? Саме це сталося б у даному випадку в *C++*. Однак в *Java* існує збирач сміття (*garbage collector*), який спостерігає за об'єктами, створеними оператором **new**, і визначає, на які з них більше немає посилань. Тоді він звільняє пам'ять від цих об'єктів, яка стає доступною для подальшого використання. Таким чином, вам ніколи не доведеться «очищати» пам'ять вручну. Ви просто створюєте об'єкти, і як тільки потреба в них відпаде, ці об'єкти зникають самі по собі. При такому підході зникає цілий клас проблем програмування: так званого «витоку пам'яті», коли програміст забуває звільняти зайняту пам'ять.
 
# Створення нових типів даних
 
Якщо все є об'єктом, що визначає будова і поведінка класу об'єктів? Іншими словами, як встановлюється тип об'єкта? Напевно, для цієї мети можна було б використовувати ключове слово *type* («тип»); це було б цілком розумно. Втім, з давніх часів повелося, що більшість об'єктно-орієнтованих мов використовували ключове слово **class** в сенсі «Я збираюся описати новий тип об'єктів». За ключовим словом **class** слідує ім'я нового типу. Наприклад:
 
``` java
class ATypeName
{
/* Тіло класу */
}
```
 
Ця конструкція вводить новий тип, і тому ви можете тепер створювати об'єкт цього типу ключовим словом **new**:
 
``` java
ATypeName а = new ATypeName();
```
 
Втім, об'єкту не можна «наказати» щось зробити (тобто послати йому необхідні повідомлення) до тих пір, поки для нього не будуть визначені методи.
 
## Поля і методи
 
При визначенні класу (строго кажучи, вся ваша робота на *Java* зводиться до визначення класів, створення об'єктів цих класів і отриманих повідомлень цих об'єктів) в нього можна включити два різновиди елементів: поля (*fields*) (іноді звані змінними класу) і методи (*methods*) (ще звані функціями класу). Поле являє собою об'єкт будь-якого типу, з яким можна працювати за посиланням, або об'єкт примітивного типу. Якщо використовується посилання, його необхідно ініціалізувати, щоб зв'язати з реальним об'єктом (ключовим словом **new**, як було показано раніше).
 
Кожен об'єкт використовує власний блок пам'яті для своїх полів даних; спільне використання звичайних полів різними об'єктами класу неможливе. Приклад класу з полями:
 
``` java
class DataOnly
{
int i;
double d;
boolean b;
}
```
 
Такий клас нічого не робить, крім зберігання даних, але ви можете створити об'єкт цього класу:
 
``` java
DataOnly data = new DataOnly();
```
 
Полям класу можна присвоювати значення, але для початку необхідно дізнатися, як звертатися до членів об'єкта. Для цього спочатку вказується ім'я посилання на об'єкт, потім слідує крапка, а далі - ім'я члена, що належить об'єкту:
 
```
посилання.член
```
 
наприклад:
 
``` java
data.і = 47;
data.d = 1.1;
data.b = false;
```
 
Також ваш об'єкт може містити інші об'єкти, дані яких ви хотіли б змінити. Для цього просто продовжуйте «ланцюжок з точок». Наприклад:
 
``` java
myPlane.leftTank.capacity = 100;
```
 
Клас **DataOnly** не здатний ні на що, крім зберігання даних, так як в ньому відсутні методи. Щоб зрозуміти, як вони працюють, необхідно розібратися, що таке аргументи і повертаємі значення. Незабаром ми повернемося до цієї теми.
 
### Значення за замовчуванням для полів примітивних типів
 
Якщо поле даних відноситься до примітивного типу, йому гарантовано присвоюється значення за замовчуванням, навіть якщо воно не було ініціалізоване явно (табл. 2.2).
 
** Таблиця 2.2. Значення за замовчуванням для полів примітивних типів **
 
| Примітивний тип | Значення за замовчуванням |
|: -------------- |: ------------------------ |
| boolean         | false                     |
| char            | '\ U0000' (null)          |
| byte            | (Byte) 0                  |
| short           | (Short) 0                 |
| int             | 0                         |
| long            | 0L                        |
| float           | 0.0f                      |
| double          | 0.0d                      |
 
Значення за замовчуванням гарантуються *Java* тільки в тому випадку, якщо змінна використовується як член класу. Тим самим забезпечується обов'язкова ініціалізація елементарних типів (що не робиться в *C++*), яка зменшує ймовірність помилок. Однак значення за замовчуванням може бути невірним?, або навіть неприпустимим для вашої програми. Змінні завжди краще ініціалізувати явно.
 
Така гарантія не відноситься до локальних змінних, які не є полями класу. Припустимо, у визначенні методу зустрічається оголошення змінної
 
``` java
int х;
```
 
Змінній **х** буде присвоєно випадкове значення (як в *C* і *C++*); вона не буде автоматично ініціалізована нулем. Ви відповідаєте за присвоєння правильного значення перед використанням **х**. Якщо ж ви забудете це зробити, в *Java* існує очевидна перевага в порівнянні з *C++*: компілятор видасть помилку, в якій зазначено, що змінна не була ініціалізована. (Багато компіляторів *C++* попереджають про такі змінні, але в *Java* це вважається помилкою.)
 
# Методи, аргументи і повертаємі значення
 
У багатьох мовах (таких як *C* і *C++*) для позначення іменованої підпрограми вживається термін функція. В *Java* частіше віддають перевагу терміну метод, який якби означає «спосіб щось зробити». Якщо вам хочеться, ви можете продовжувати використовувати термін «функція». Різниця тільки в написанні, але в подальшому в книзі буде вживатися переважно термін «метод». Методи в *Java* визначають повідомлення, що приймаються об'єктом. Основні частини методу - ім'я, аргументи, що повертається тип і тіло. Ось зразок форми:
 
```
повертаємийТип Ім'яМетоду (/ * список аргументів * /) {
/ * Тіло методу * /
}
```
 
Повертаємий тип - це тип об'єкта, «повертаємий» методом після його виклику. Список аргументів визначає типи і імена для інформації, яку ви хочете передати в метод. Ім'я методу і його список аргументів (об'єднуються терміном сигнатура) забезпечують однозначну ідентифікацію методу.
 
Методи в *Java* створюються тільки як частини класу. Метод може викликатися тільки для об'єкта, і цей об'єкт повинен мати можливість зробити такий виклик. Якщо ви спробуєте викликати для об'єкта неіснуючий метод, то отримаєте помилку компіляції. Виклик методу здійснюється наступним чином: спочатку записується ім'я об'єкта, за ним точка, за нею йдуть ім'я методу і його список аргументів:
 
```
імяОб'екта.імяМетода (арг1, арг2, арг3);
```
 
Наприклад, уявіть, що у вас є метод **f()**, що викликається без аргументів, який повертає значення типу **int**. Якщо у вас є в наявності об'єкт **а**, для якого може бути викликаний метод **f()**, ми можемо використовувати наступну конструкцію:
 
``` java
int х = a.f();
```
 
Тип значення, що повертається повинен бути сумісний з типом **х**.
 
Така дія виклику методу часто називається посиланням повідомлення об'єкту. В наведеному вище прикладі повідомленням є виклик **f()**, а об'єктом - **а**. Об'єктно-орієнтоване програмування нерідко характеризується узагальнюючою формулою «посиланням повідомлень об'єктам».
 
## Список аргументів
 
Список аргументів визначає, яка інформація передається методу. Як легко здогадатися, ця інформація - як і все в *Java* - втілюється в формі об'єктів, тому в списку повинні бути вказані як типи об'єктів, що передаються, так і їх імена. Як і в будь-який інший ситуації в *Java*, де ми начебто працюємо з об'єктами, насправді використовуються посилання. Втім, тип посилання повинен відповідати типу переданих даних. Якщо передбачається, що аргумент є рядком (тобто об'єктом **String**), ви повинні передати саме рядок, або чекайте повідомлення про помилку.
 
Розглянемо метод, який одержує в якості аргументу рядок (**String**). Наступне визначення повинне розміщуватись всередині класу, для якого створюється метод:
 
``` java
int storage (String s) {
return s.length()*2;
}
```
 
Метод вказує, скільки байтів потрібно для зберігання даних певного рядка. (Рядки складаються з символів **char**, розмір яких - 16 біт, або 2 байта; це зроблено для підтримки набору символів *Unicode*.) Аргумент має тип **String** і називається **s**.
Отримавши об'єкт **s**, метод може працювати з ним точно так само, як і з будь-яким іншим об'єктом (тобто посилати йому повідомлення). В даному випадку викликається метод **length()**, один з методів класу **String**, який повертає кількість символів в рядку.
 
Також зверніть увагу на ключове слово **return**, яке виконує дві дії. По-перше, воно означає: «вийти з методу, все зроблено». По-друге, якщо метод повертає значення, це значення вказується відразу ж за командою **return**. У нашому випадку повертається значення - це результат обчислення **s.length()\*2**.
 
Метод може повертати будь-який тип, але, якщо ви не хочете користуватися цією можливістю, слід вказати, що метод повертає **void**. Нижче наведено кілька прикладів:
 
``` java
boolean flag() {return true; }
float naturalLogBase() {return 2.718; }
void nothing() {return; }
void nothing2() {}
```
 
Коли повертаємим типом є **void**, ключове слово **return** потрібно лише для завершення методу, тому при досягненні кінця методу його присутність необов'язкова. Ви можете залишити метод в будь-який момент, але якщо при цьому вказується що повертається тип, відмінний від **void**, то компілятор змусить вас (повідомленнями про помилку) повернути відповідний тип незалежно від того, в якому місці методу було перервано виконання.
 
До цього моменту може скластися враження, що програма - це просто «звалище» об'єктів зі своїми методами, які приймають інші об'єкти в якості аргументів і посилають їм повідомлення. За великим рахунком так воно і є, але в наступному розділі ви дізнаєтеся, як робити клопітку низкорівневу роботу з прийняттям рішень всередині методу. В цьому розділі досить розгляду на рівні посилки повідомлень.
 
# Створення програми на *Java*
 
Є ще кілька питань, які необхідно зрозуміти перед створенням першої програми на *Java*.
 
## Видимість імен
 
Проблема управління іменами властива будь-якій мові програмування. Якщо ім'я використовується в одному з модулів програми і воно випадково співпало з ім'ям в іншому модулі в іншого програміста, то як відрізнити одне ім'я від іншого і запобігти їх конфлікту? В *C* це безперечно є проблемою, тому що програма ніяк не піддається контролю в умовах «моря» імен. Класи *C++* (на яких засновані класи *Java*) приховують функції всередині класів, тому їх імена не перетинаються з іменами функцій інших класів. Однак в *C++* дозволяється використання глобальних даних і глобальних функцій, відповідно, конфлікти повністю не виключені. Для вирішення зазначеної проблеми в *C++* введені простори імен (*namespaces*), які використовують додаткові ключові слова.
 
У мові *Java* для вирішення цієї проблеми було використано свіже рішення. Для створення унікальних імен бібліотек розробники *Java* пропонують використовувати доменне ім'я, записане «навпаки», так як ці імена завжди унікальні. Моє доменне ім'я - *MindView.net*, і утиліти моєї програмної бібліотеки могли б називатися net.mindview.utility.foibles. За перевернутим доменним ім'ям слідує перелік каталогів, між якими ставлять крапку.
 
У версіях *Java* 1.0 і 1.1 доменні суфікси *com, edu, org, net* за замовчуванням записувалися великими літерами, таким чином, ім'я бібліотеки виглядало так: **NET.mindview.utility.foibles**. В процесі розробки *Java 2* було виявлено, що прийнятий підхід створює проблеми, і з тих пір ім'я пакета записується малими літерами.
 
Такий механізм означає, що всі ваші файли автоматично розташовуються в своїх власних просторах імен, і кожен клас в файлі повинен мати унікальний ідентифікатор. Мова сам запобігає конфліктам імен.
 
## Використання зовнішніх компонентів
 
Коли вам знадобиться використовувати вже визначений клас у вашій програмі, компілятор повинен знати, як цей клас виявити. Звичайно, клас може вже перебувати в тому ж самому початковому файлі, звідки він викликається. В такому випадку ви просто його використовуєте - навіть якщо визначення класу існує десь далі в файлі (В *Java* не існує проблеми «випереджальних посилань».)
 
Але що, якщо клас знаходиться в якомусь зовнішньому файлі? Здавалося б, компілятор повинен запросто знайти його, але тут існує проблема. Уявіть, що вам необхідний клас з якимсь ім'ям, для якого є більше одного визначення (ймовірно, що відрізняються один від одного).
Або, що ще гірше, уявіть, що ви пишете програму і при її створенні в бібліотеку додається новий клас, який конфліктує з ім'ям вже існуючого класу.
 
Для вирішення проблеми вам необхідно усунути всі можливі неоднозначності. Завдання вирішується за допомогою ключового слова **import**, яке говорить компілятору *Java*, які точно класи вам потрібні. Слово **import** наказує компілятору завантажити пакет (**package**), що представляє собою бібліотеку класів. (В інших мовах бібліотека може складатися як з класів, так і з функцій і даних, але в *Java* весь код належить класам.)
 
Велику частину часу ви будете працювати з компонентами зі стандартних бібліотек *Java*, що поставляються з компілятором. Для них не потрібні довгі звернені доменні імена; ви просто записуєте:
 
``` java
import java.util.ArrayList;
```
 
щоб сказати компілятору, що ви хочете використовувати клас **ArrayList**. Втім, пакет **util** містить безліч класів, і вам можуть знадобитися кілька з них. Щоб уникнути послідовного перерахування класів, використовуйте підстановлювальний символ **\***:
 
``` java
import java.util.*;
```
 
Як правило, імпортується цілий набір класів саме таким чином, а не виписується кожен клас окремо.
 
### Ключове слово static
 
Зазвичай при створенні класу ви описуєте, як об'єкти цього класу ведуть себе і як вони виглядають. Об'єкт з'являється тільки після того, як він буде створений ключовим словом **new**, і тільки починаючи з цього моменту для нього виділяється пам'ять і з'являється можливість виклику методів.
 
Але є дві ситуації, в яких такий підхід є недостатнім. Перша - це коли деякі дані повинні зберігатися «в однині» незалежно від того, скільки було створено об'єктів класу. Друга - коли вам буде потрібен метод, не прив'язаний ні до якого конкретного об'єкту класу (тобто метод, який можна викликати навіть при повній відсутності об'єктів класу).
 
Такий ефект досягається використанням ключового слова **static**, що робить елемент класу статичним. Коли ви оголошуєте що-небудь як **static**, це означає, що дані, або метод не прив'язані до певного примірника цього класу. Тому, навіть якщо ви ніколи не створювали об'єктів класу, ви можете викликати статичний метод, або отримати доступ до статичних даних. З звичайним об'єктом вам необхідно спочатку створити його і використовувати для виклику методу, або доступу до інформації, так як нестатичні дані і методи повинні точно знати об'єкт, з яким працюють.
 
Деякі об'єктно-орієнтовані мови використовують терміни дані рівня класу і методи рівня класу, маючи на увазі, що дані і методи існують тільки на рівні класу в цілому, а не для окремих об'єктів цього класу. Іноді ці терміни зустрічаються в літературі по *Java*.
 
Щоб зробити дані, або метод статичними, просто помістіть ключове слово **static** перед їх визначенням. Наприклад, наступний код створює статичне поле класу і ініціалізує його:
 
``` java
class StaticTest {
static int і = 47;
}
```
 
Тепер, навіть при створенні двох об'єктів **StaticTest**, для елемента **StaticTest.i** виділяється єдиний блок пам'яті. Обидва об'єкти спільно використовують одне значення **i**. Приклад:
 
``` java
StaticTest stl = new StaticTest();
StaticTest st2 = new StaticTest();
```
 
В даному прикладі як **st1.i**, так і **st2.i** мають однакові значення, рівні *47*, тому що розташовані вони в одному блоці пам'яті. Існує два способи звернутися до статичної змінної. Як було видно вище, ви можете вказати її за допомогою об'єкта, наприклад **st2.i**. Також можна звернутися до неї прямо по імені класу (для нестатичних членів класу така можливість відсутня):
 
``` java
StaticTest.i ++;
```
 
Оператор **++** збільшує значення на одиницю (інкремент). Після виконання цієї команди значення **st1.i** і **st2.i** дорівнюватимуть *48*.
 
Синтаксис з ім'ям класу є кращим, тому що він не тільки підкреслює, що змінна описана як **static**, але і в деяких випадках надає компілятору більше можливостей для оптимізації.
 
Та ж логіка вірна і для статичних методів. Ви можете звернутися до такого методу, або через об'єкт, як це робиться для всіх методів, або в спеціальному синтаксисі **імяКласа.метод()**. Статичні методи визначаються за аналогією зі статичними даними:
 
``` java
class Incrementable {
	static void increment() {StaticTest.i ++; }
}
```
 
Неважко помітити, що метод increment() класу Incrementable збільшує значення статичного поля **i**. Метод можна викликати стандартно, через об'єкт:
 
``` java
Incrementable sf = new Incrementable ();
sf.increment ();
```
 
Або, оскільки **increment()** є статичним, можна викликати його з прямим вказанням класу:
 
``` java
Incrementable.increment();
```
 
Стосовно полів, то ключове слово **static** радикально змінює спосіб визначення даних: статичні дані існують на рівні класу, в той час як нестатичні дані існують на рівні об'єктів, але щодо методів, то відмінності не такі принципові. Одним з важливих застосувань **static** є визначення методів, які можуть викликатися без об'єктів. Зокрема, це абсолютно необхідно для методу **main()**, який представляє собою точку входу в додаток.
 
# Наша перша програма на *Java*
 
Нарешті, довгоочікувана програма. Вона запускається, виводить на екран рядок, а потім поточну дату, використовуючи стандартний клас **Date** зі стандартної бібліотеки *Java*:
 
``` java
// НеlloDate.java 
import java.util. *;
public class HelloDate {
	public static void main (String [] args) {
		System.out.println ( "Привіт, сьогодні:");
		System out println (new Date ());
	}
}
```
 
Після запуску програми отримаємо текст типу:
 
```
Привіт, сьогодні: Wed Oct 05 14:39:36 MDT 2005
```
 
На початку кожного файлу з програмою повинні знаходитися директиви **import**, в яких перераховуються всі додаткові класи, необхідні вашій програмі. Зверніть увагу на слово «додаткові» - існує ціла бібліотека класів, яка приєднується автоматично до кожного файлу *Java*: **java.lang**. Запустіть ваш браузер і перегляньте документацію фірми *Sun*. (Якщо ви не завантажили документацію *JDK* з сайту <http://java.sun.com>, або не отримали її іншим способом, обов'язково це зробіть.) Врахуйте, що документація не входить в комплект *JDK*, її необхідно завантажити окремо. Поглянувши на список пакетів, ви знайдете в ньому різні бібліотеки класів, що поставляються з *Java*.
 
Виберіть **java.lang**. Тут ви побачите список всіх класів, що складають цю бібліотеку. Так як пакет **java.lang** автоматично включається в кожну програму на *Java*, то ці класи завжди доступні для використання. Класу **Date** в ньому немає, а це означає, що для його використання доведеться імпортувати іншу бібліотеку.
 
Якщо ви не знаєте, в якій бібліотеці знаходиться потрібний клас, або якщо вам знадобиться побачити всі класи, виберіть **Tree** (дерево класів) в документації. У ньому можна знайти будь-який з доступних класів *Java*. Функція пошуку тексту в браузері допоможе знайти клас **Date**.

Результат пошуку показує, що клас називається **java.util.Date**, тобто знаходиться в бібліотеці **util**, і для отримання доступу до класу **Date** необхідно буде використовувати директиву import для завантаження пакета **java.util.\***.
 
Якщо ви повернетеся до початку, виберете пакет **java.lang**, а потім клас **System**, то побачите, що він має кілька полів. При виборі поля **out** виявляється, що воно являє собою статичний об'єкт **PrintStream**. Так як поле описане з ключовим словом **static**, вам не знадобиться створювати об'єкти. Дії, які можна виконувати з об'єктом **out**, визначаються його типом: **PrintStream**.
 
Для зручності в опис цього типу включено гіперпосилання, і, якщо клацнути по ньому, ви виявите список всіх доступних методів. Цих методів досить багато, і вони будуть пізніше розглянуті в книзі. Зараз нас цікавить тільки метод **println()**, виклик якого фактично означає: «вивести те, що передано методу, на консоль і перейти на новий рядок». Таким чином, в будь-яку програму на *Java* можна включити виклик типу **System.out.println** ("щось"), щоб вивести повідомлення на консоль.
 
Ім'я класу збігається з ім'ям файлу. Коли ви створюєте окрему програму, подібну до цієї, один з класів, описаних у файлі, повинен мати назву, що збігається з назвою класу. (Якщо ця умова порушена, компілятор повідомить про помилку.) Однойменний клас повинен містити метод з ім'ям **main()** з наступною сигнатурою і повертаємим типом:
 
``` java
public static void main (String [] args)
```
 
Ключове слово **public** позначає, що метод доступний для зовнішнього світу (про це докладно розповідає глава 5). Аргументом методу **main()** є масив рядків. У даній програмі масив **args** не використовується, але компілятор *Java* наполягає на його присутності, так як масив містить параметри, передані програмі в командному рядку.
 
Рядок, в якому роздруковується число, досить цікавий:
 
``` java
System.out.println(new Date());
```
 
Аргумент є об'єктом **Date**, який створюється лише для того, щоб передати своє значення (автоматично конвертувати в **String**) методу **println()**. Як тільки команда буде виконана, об'єкт **Date** стає непотрібним, збирач сміття помітить це, і врешті-решт сам знищить його. Нам не потрібно турбуватися про його видаленні самим.
 
## Компіляція і виконання
 
Щоб скомпілювати і виконати цю програму, а також всі інші програми в книзі, вам знадобиться середовище розробки *Java*. Існує безліч різних середовищ розробок від сторонніх виробників, але в цій книзі ми припускаємо, що ви обрали безкоштовне середовище *JDK Java
Developer's Kit*) від фірми *Sun*. Якщо ж ви використовуєте інші системи розробки програм, вам доведеться переглянути їх документацію, щоб дізнатися, як компілювати і запускати програми.
 
З'єднайтесь з Інтернетом і відвідайте сайт <http://java.sun.com>. Там ви знайдете інформацію і необхідні посилання, щоб завантажити і встановити *JDK* для вашої платформи.
 
Як тільки ви встановите *JDK* і правильно встановите шляхи запуску, в результаті чого система зможе знайти утиліти **javac** і **Java**, завантажте і розпакуйте вихідні тексти програм для цієї книги (їх можна завантажити з сайту <http://www.MindView.net>). Там ви виявите каталоги (папки) для кожного розділу книги. Перейдіть в папку **objects** і виконайте команду

``` 
javac HelloDate java
```
 
Команда не повинна виводити будь-яких повідомлень. Якщо ви отримали повідомлення про помилку, значить, ви невірно встановили *JDK* і вам потрібно розібратися зі своїми проблемами.
 
І навпаки, якщо все пройшло успішно, виконайте наступну команду:
 
```
java НеlloDate
```
 
і ви побачите повідомлення і дату як результат роботи програми.
 
Ця послідовність дій дозволяє відкомпілювати і виконати будь-яку програму-приклад з цієї книги. Однак також ви побачите, що кожна папка містить файл **build.xml** з командами для інструменту ant, для автоматичного складання файлів для цього розділу. Після установки **ant** з сайту <http://jakarta.apache.org/ant> можна буде просто набрати команду **ant** в командному рядку, щоб скомпілювати і запустити програму з будь-якого прикладу. Якщо **ant** на вашому комп'ютері ще не встановлено, команди **javac** і **Java** доведеться вводити вручну.
 
# Коментарі та вбудована документація
 
В *Java* прийняті два види коментарів. Перший - традиційні коментарі в стилі *C*, також успадковані мовою *C++*. Такі коментарі починаються з комбінації **/\*** і поширюються іноді на безліч рядків, після чого закінчуються символами **\*/**.
Зауважте, що багато програмістів починають кожен новий рядок таких коментарів символом **\***, відповідно, часто можна побачити наступне:
 
``` java
/*  Цей коментар,
*   поширюється на
*   кілька рядків */
```
 
Втім, всі символи між **/\*** і **\*/** ігноруються, і з таким же успіхом можна використовувати запис
 
``` java
/ * Це коментар, що поширюється на кілька рядків * /
```
 
Другий вид коментаря прийшов з мови *C++*. Однорядковий коментар починається з комбінації **//** і триває до кінця рядка. Такий стиль дуже зручний і простий, тому широко використовується на практиці. Вам не доведеться шукати на клавіатурі спочатку символ **/\***, а потім **\*/** (замість цього ви двічі натискаєте одну і ту ж клавішу), і не потрібно закривати коментар. Тому часто можна побачити такі приклади:
 
``` java
// Це коментар в один рядок
```
 
## Документація в коментарях
 
Мабуть, основні проблеми з документуванням коду пов'язані з його супроводом. Якщо код і його документація існують окремо, коригувати опис програми при кожній її зміні стає завданням не з легких. Рішення виглядає дуже просто: поєднати код і документацію. Найпростіше об'єднати їх в одному файлі. Але для повноти картини знадобиться спеціальний синтаксис коментарів, щоб позначати документацію, і інструмент, який витягував би ці коментарі і оформляв їх в потрібному вигляді. Саме це було зроблено в *Java*.
 
Інструмент для витягання коментарів називається **javadoc**, він є частиною пакета *JDK*. Деякі можливості компілятора *Java* використовуються в ньому для пошуку позначок в коментарях, включених в ваші програми. Він не тільки витягує позначену інформацію, але також дізнається ім'я класу, або методу, до якого належить даний фрагмент документації. Таким чином, з мінімумом витрачених зусиль можна створити цілком пристойну супровідну документацію для вашої програми.
 
Результатом роботи програми **javadoc** є *HTML*-файл, який можна переглянути в браузері. Таким чином, утиліта **javadoc** дозволяє створювати і підтримувати єдиний файл з вихідним текстом і автоматично будувати корисну документацію. У результаті виходить простий і практичний стандарт по створенню документації, тому ми можемо очікувати (і навіть вимагати) наявності документації для всіх бібліотек *Java*.
 
До того ж, ви можете доповнити **javadoc** своїми власними розширеннями, званими доклетами (*doclets*), в яких можна проводити спеціальні операції над робочими даними (наприклад, виводити їх в іншому форматі).
 
Далі слідує лише короткий вступ і огляд основних можливостей **javadoc**. Більш докладний опис можна знайти в документації *JDK*. Розпакувавши документацію, загляньте в папку **tooldocs** (або перейдіть за посиланням **tooldocs**).
 
### Синтаксис
 
Всі команди **javadoc** знаходяться тільки всередині коментарів **/\*\***. Коментарі, як зазвичай, завершуються послідовністю **\*/**. Існує два основних способи роботи з **javadoc**: вбудовування *HTML*-тексту, або використання розмітки документації (тегів). Самостійні теги документації - це команди, які починаються символом **@** і починаються з нового рядка коментаря.
 
> Початковий символ **\*** ігнорується.
 
Вбудовані теги документації можуть розташовуватися в будь-якому місці коментаря **javadoc**, також починаються зі знака **@**, але повинні заключатись в фігурні дужки.
 
Існує три види документації в коментарях для різних елементів коду: класу, змінної і методу. Коментар до класу записується прямо перед його визначенням; коментар до змінної розміщується безпосередньо перед її визначенням, а коментар до методу теж записується прямо перед його визначенням. Простий приклад:
 
``` java
//: Object/Documentation1.java
/** Коментар до класу */
public class Documentation1 {
	/ ** Коментар до змінної * /
	public int i;
	/ ** Коментар до методу * /
	public void f() {}
}
///: ~
```
 
Зауважте, що **javadoc** обробляє документацію в коментарях тільки для членів класу з рівнем доступу **public** і **protected**. Коментарі для членів **private** і членів з доступом в межах пакету ігноруються, і документація по ним не будується. (Втім, прапорець -**private** включає обробку і цих членів). Це цілком логічно, оскільки тільки **public** і **protected** - члени доступні поза межами файлу, і саме вони цікавлять програміста-клієнта.
 
Результатом роботи програми є *HTML*-файл в тому ж форматі, що і решта документація для *Java*, так що користувачам буде звично і зручно переглядати і вашу документацію. Спробуйте набрати текст попереднього прикладу, «пропустіть» його через **javadoc** і перегляньте отриманий *HTML*-файл, щоб побачити результат.
 
### Вбудований *HTML*
 
**Javadoc** вставляє команди *HTML* в підсумковий документ. Це дозволяє повністю використовувати всі можливості *HTML*; втім, дана можливість перш за все орієнтована на форматування коду:
 
``` java
//: Object/Documentation2.java
/**
*    <Pre>
*    System.out.println(new Date());
*    </Pre>
*/
///: ~
```
 
Ви можете використовувати *HTML* точно так само, як в звичайних сторінках, щоб привести опис до потрібного формату:
 
``` java
//: Object/Documentation3.java
/**
*    You can <em> even </em> insert a list:
*    <Ol>
*    <Li> Пункт перший
*    <Li> Пункт другий
*    <Li> Пункт третій
*    </Ol>
*/
///: ~
```
 
**Javadoc** ігнорує зірочки на початку рядків, а також початкові пропуски. Текст переформатується таким чином, щоб він відповідав вигляду стандартної документації. Не використовуйте заголовки типу <**h1**>, або <**hr**> у вбудованому *HTML*, тому що **javadoc** вставляє свої власні заголовки і ваші можуть з ними «перетнутися».
 
Вбудований *HTML*-код підтримується всіма типами документації в коментарях - для класів, змінних, або методів.
 
### Приклади тегів
 
Далі описані деякі з тегів **javadoc**, використовуваних при документуванні програми. Перш ніж застосовувати **javadoc** для будь-яких серйозних цілей, перегляньте посібник з нього в документації пакета *JDK*, щоб отримати повну інформацію про його використання.
 
**@see**: посилання на інші класи
 
Тег дозволяє посилатися на документацію інших класів. **Javadoc** там, де були записані теги **@see**, створює *HTML*-посилання на інші документи. Основні форми використання тега:
 
``` 
@see ім'я-класу 
@see повне-ім'я-класу 
@see повне-ім'я-класу#ім'я-методу
```
 
Кожна з цих форм включає в генерується документацію зауваження *See Also* ( «див. також») з посиланням на зазначені класи. **Javadoc** не перевіряє передані йому гіперпосилання.
 
**{@link Пакет.класс # член_класса мітка}**
 
Тег дуже схожий на **@see**, не рахуючи того, що він може використовуватися як вбудований, а замість стандартного тексту *See Also* на засланні розміщується текст, вказаний в полі мітка.
 
**{@docRoot}**
 
Дозволяє отримати відносний шлях до кореневої папці, в якій знаходиться документація. Корисний при явному завданні посилань на сторінки з дерева документації.
 
**{@inheritDoc}**
 
Успадковує документацію базового класу, найближчого до документованої класу, в поточний файл з документацією.
 
**@version**
 
Має наступну форму:
 
```
@version інформація-про-версії
```
 
Поле інформації про версії містить ту інформацію, яку ви вважали за потрібне включити. Коли в командному рядку **javadoc** вказується опція **-version**, в створеній документації спеціально відводиться місце, що заповнюються інформацією про версії.
 
**@author**
 
Записується у вигляді
 
``` 
@author інформація-про-автора
```
 
Передбачається, що полі інформація-про-автора є ім'я автора, хоча в нього також можна включити адрес електронної пошти та будь-яку іншу інформацію. Коли в командному рядку **javadoc** вказується опція **- author**, в створеній документації зберігається інформація про автора.
 
Для створення списку авторів можна записати відразу кілька таких тегів, але вони повинні розміщуватися послідовно. Вся інформація про авторів об'єднується в один розділ в створеному коді *HTML*.
 
**@since**
 
Тег дозволяє задати версію коду, з якої почалося використання деякої можливості. Зокрема, він присутній в *HTML*-документаціі по *Java*, де служить для вказання версії *JDK*.
 
**@param**
 
Корисний при документуванні методів. Форма використання:
 
**@param ім'я-параметра опис**
 
де ім'я-параметра - це ідентифікатор в списку параметрів методу, а опис - текст опису, який можна продовжити на кілька рядків. Опис вважається завершеним, коли зустрінеться новий тег. Можна записувати будь-яку кількість тегів **@param**, по одному для кожного параметра методу.
 
**@return**
 
Форма використання:
 
```
@return опис
```
 
де опис пояснює, що саме повертає метод. Опис може складатися з декількох рядків.
 
**@throws**
 
Виключення будуть розглядатися в розділі 9. У двох словах це об'єкти, які можна «порушити» (**throw**) в методі, якщо його виконання зазнає невдачі. Хоча при виклику методу створюється завжди один об'єкт виключення, певний метод може створювати будь-яку кількість виключень, і всі вони вимагають опису. Відповідно, форма тега виключення така:
 
```
@throws повне-ім'я-класу опис
```
 
де повне-ім'я-класу дає унікальне ім'я класу виключення, яке десь визначено, а опис (розташоване на довільній кількості рядків) пояснює, чому даний метод здатний створювати це виключення при своєму виклику.
 
**@deprecated**
 
Тег використовується для позначення застарілих можливостей, заміщених новими та поліпшеними. Він повідомляє про те, що певні кошти програми не слід використовувати, так як в майбутньому вони, швидше за все, будуть прибрані. В *Java SE5* тег **@deprecated** був замінений директивою **@Deprecated** (див. далі).
 
### Приклад документації
 
Повернемося до нашої першої програми на *Java*, але на цей раз додамо в неї коментарі з вбудованою документацією:
 
``` java
//: Object/HelloDate.java 
import java.util.*;
/ ** Перша програма-приклад книги.
*    Виводить рядок і поточне число.
*    @author Брюс Еккель
*    @author www.MindView.net
*    @version 4.0 */
public class HelloDate {
/** Точка входу в клас і додаток
*    @param Масив строкових аргументів
*    @throws exceptions Винятки не видаються
*/
	public static void main(String[] args) {
		System.out.println("Привіт, сьогодні:");
		System.out.println(new Date());
	}
}
/* Output: (55% match)
Привіт, сьогодні: Wed Oct 05 14:39:36 MDT 2005
*///:~
```
 
У першому рядку файлу використана моя особиста методика приміщення спеціального маркера **//:** в коментар як ознаки того, що в цьому рядку коментаря міститься ім'я файлу з вихідним текстом. Тут вказується шлях до файлу (**object** означає цей розділ) з подальшим ім'ям файлу. Останній рядок також завершується коментарем (**///:\~**), що означає кінець вихідного тексту програми. Він допомагає автоматично отримувати з тексту книги програми для перевірки компілятором і виконання.
 
Тег **/\* Output**: позначає початок вихідних даних, згенерованих даним файлом. У цій формі їх можна автоматично перевірити на точність.
 
В даному випадку значення **(55% match)** повідомляє системі тестування, що результати будуть помітно відрізнятися при різних запусках програми. У більшості прикладів книги результати наводяться в коментарях такого виду, щоб ви могли перевірити їх на правильність.
 
# Стиль оформлення програм
 
Згідно з правилами стилю, описаним в керівництві *Code Conventions for the Java Programming Language* імена класів повинні записуватися з великої літери. Якщо ім'я складається з декількох слів, вони об'єднуються (тобто символи підкреслення не використовуються для поділу), і кожне слово в імені починається з великої літери:
 
``` java
class АllTheColorsOfTheRainbow { 
	//...
}
```

Практично для всього іншого: методів, полей і посилань на об'єкти - використовується такий же спосіб запису за одним винятком - ідентифікатор починається з маленької букви. Наприклад:
 
``` java
class AllTheColorsOfTheRainbow {
	int anIntegerRepresentingColors;
	void changeTheHueOfTheColor (int newHue) {
		// ...
	}
	// ...
}
```
 
Пам'ятайте, що користувачеві ваших класів і методів доведеться вводити всі ці довгі імена, так що будьте милосердні.
 
У вихідних текстах *Java*, які можна побачити в бібліотеках фірми *Sun*, також використовується схема розміщення відкриття і закриття фігурних дужок, яка зустрічається в прикладах даної книги.
 
# Резюме
 
У цьому розділі я постарався надати інформацію про програмуванні на *Java*, достатню для написання найпростішої програми. Також був представлений огляд мови та деяких її основних властивостей. Однак приклади досі мали форму «спочатку це, потім це, а після щось ще». У наступних двох розділах будуть представлені основні оператори, які використовуються при програмуванні на *Java*, а також способи передачі управління в вашій програмі.
 
 