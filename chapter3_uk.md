# Оператори
 
На нижньому рівні операції з даними в *Java* здійснюються за допомогою операторів. Мова *Java* створювалася на основі *C++*, тому більшість цих операторів і конструкцій знайомі програмістам на *C* і *C++*. Також в *Java* були додані деякі поліпшення і спрощення. Якщо ви знайомі з синтаксисом *C*, або *C++*, побіжно перегляньте цей і наступний розділ, зупиняючись на тих місцях, в яких *Java* відрізняється від цих мов. Якщо читання дається вам важко, спробуйте звернутися до мультимедійного семінару **Thinking in С**, як можна безкоштовно завантажити з сайту www.MindView.net. Він містить аудіолекції, слайди, вправи і рішення, спеціально розроблені для швидкого ознайомлення з синтаксисом *C*, необхідним для успішного оволодіння мовою *Java*.
 
## Прості команди друку
 
У попередньому розділі була представлена команда друку *Java*
 
``` java
System.out.println("Яка довга команда ...");
```
 
Ймовірно, ви помітили, що команда не тільки виходить занадто довгою, але і погано читається. У багатьох мовах до і після *Java* використовується більш простий підхід до виконання настільки поширеною операції. У розділі 6 представлена концепція статичного імпорту, що з'явилася в *Java SE5*, а також крихітна бібліотека, яка спрощує написання команд друку. Проте для використання бібліотеки не обов'язково знати всі подробиці. Програму з попередньої глави можна переписати в наступному вигляді:
 
``` java
//: Operators/HelloDate.java
import java.util. *;
import static net.mindview.util.Print. *;
 
public class HelloDate {
	public static void main(String [] args) {
	print("Hello, it's:");
	print(new Date());
	}
} /* Результат:(55% match)
Hello, it's:
Wed Oct 05 14:39:05 MDT 2005
*///: ~
```
 
Результат виглядає набагато приємніше. Зверніть увагу на ключове слово **static** в другій команді **import**.
 
Щоб використовувати цю бібліотеку, необхідно завантажити архів з прикладами коду. Розпакуйте його і включіть кореневий каталог дерева в змінну оточення **CLASSPATH** вашого комп'ютера. Хоча використання **net.mindview.util.Print** спрощує програмний код, воно виправдано не скрізь. Якщо програма містить невелику кількість команд друку, я відмовляюся від **import** і записую повний виклик **System.out.println()**.
 
## Оператори *Java*
 
Оператор отримує один, або кілька аргументів і створює на їх основі нове значення. Форма передачі аргументів дещо інша, ніж при виклику методу, але ефект той же самий. Додавання(**+**), віднімання і унарний мінус(**-**), множення(**\***), ділення(**/**) і присвоєння(**=**) працюють однаково практично у всіх мовах програмування.
 
Всі оператори працюють з операндами і видають якийсь результат. До того ж деякі оператори можуть змінити значення операнда. Це називається побічним ефектом. Як правило, оператори, що змінюють значення своїх операндів, використовуються саме заради побічного ефекту, але ви повинні пам'ятати, що отримане значення може бути використано в програмі і звичайним чином, незалежно від побічних ефектів.
 
Майже всі оператори працюють тільки з примітивами. Винятками є **=, ==, !=**, Які можуть бути застосовані до об'єктів(і створюють чимало труднощів). Крім того, клас **String** підтримує операції **+** і **+=**.
 
## Пріоритет
 
Пріоритет операцій визначає порядок обчислення виразів з декількома операторами. В *Java* існують конкретні правила для визначення черговості обчислень. Найлегше запам'ятати, що ділення і множення виконуються раніше додавання і віднімання. Програмісти часто забувають правила черговості, тому для явного завдання порядку обчислень слід використовувати круглі дужки. Наприклад, погляньте на команди(1) і(2):
 
``` java
//: Operators/Precedence.java 
public class Precedence {
	public static void main(String [] args) {
		int x = 1, y = 2, z = 3;
		int a = x + y - 2/2 + z; //(1)
		int b = x +(y - 2)/(2 + z); //(2)
		System.out.println("a =" + a + "b =" + b);
	}
} /* Результат:
a = 5 b = 1
*///: ~
```
 
Команди схожі одна на одну, але з результатів добре видно, що вони мають різний зміст в залежності від присутності круглих дужок. Зверніть увагу на оператор * +** в команді **System.out.println**. В даному контексті + означає конкатенацію рядків, а не сумовування. Коли компілятор зустрічає об'єкт String, за яким слідує **+** і об'єкт, відмінний від **String**, він намагається перетворити останній об'єкт в **String**. Як видно з вихідних даних, для **а** і **b** тип **int** був успішно перетворений в **String**.
 
## Присвоєння
 
Присвоєння виконується оператором **=**
 
Трактується він так: «взяти значення з правої частини виразу(часто зване просто значенням) і скопіювати його в ліву частину(часто звану іменованим виразом)». Значенням може бути будь-яка константа, змінна, або вираз, але в якості іменованого виразу обов'язково повинна використовуватися іменована змінна(тобто для зберігання значення має виділятися фізична пам'ять). Наприклад, ви можете привласнити постійне значення змінній:
 
``` java
а = 4;
```
 
але не можна привласнити щось константі - вона не може використовуватися в якості іменованного виразу(наприклад, запис **4 = а** неприпустимий).
 
Для примітивів привласнення виконується тривіально. Так як примітивний тип зберігає дані, а не посилання на об'єкт, то привласнення зводиться до простого копіювання даних з одного місця в інше. Наприклад, якщо команда **а = b** виконується для примітивних типів, то вміст **b** просто копіюється в **а**. Природно, наступні зміни **а** ніяк не відбиваються на **b**. Для програміста саме така поведінка виглядає найбільш логічно.
 
При присвоєнні об'єктів все змінюється. При виконанні операцій з об'єктом ви насправді працюєте з посиланням, тому присвоєння «одного об'єкта іншому» насправді означає копіювання посилання з одного місця в інше. Це означає, що при виконанні команди **c = d** для об'єктів в кінцевому підсумку **c** і **d** вказують на один об'єкт, якому спочатку відповідало тільки посилання **d**. Сказане демонструє наступний приклад:
 
``` java
//: Operators/Assignment.java
// Присвоєння об'єктів має ряд хитростей
import static net.mindview.util.Print.*;
 
class Tank {
	int level;
}
 
public class Assignment {
	public static void main(String [] args) {
		Tank t1 = new Tank();
		Tank t2 = new Tank();
		t1.level = 9;
		t2.level = 47;
		print("1: t1.level:" + t1.level + ", T2.level:" + t2.level);
		t1 = t2;
		print("2: t1.level:" + t1.level + ", T2.level:" + t2.level);
		t1.level = 27;
		print("3: t1.level:" + t1.level + ", T2.level:" + t2.level);
	}
} /* Результат:
1: t1.level: 9, t2.level: 47
2: t1.level: 47, t2.level: 47
3: t1.level: 27, t2.level: 27
*///: ~
```
 
Клас **Tank** гранично простий, і два його примірники(**t1** і **t2**) створюються всередині методу **main()**. Змінній **level** для кожного екземпляра надаються різні значення, а потім посиланню **t2** присвоюється **t1**, в результаті чого **t1** змінюється.
 
У багатьох мовах програмування можна було очікувати, що **t1** і **t2** будуть незалежні весь час, але через присвоєння посилань зміна об'єкта **t1** відбивається на об'єкті **t2**! Це відбувається через те, що **t1** і **t2** містять однакові посилання, що вказують на один об'єкт.(Початкове посилання, яка містилося в **t1** і вказувало на об'єкт зі значенням *9*, було переписане під час присвоєння і фактично втрачено; його об'єкт буде незабаром видалений збирачем сміття.)
 
Цей феномен поєднання імен часто називають аліасингом(*aliasing*), і саме він є основним способом роботи з об'єктами в *Java*. Але що робити, якщо суміщення імен небажано? Тоді можна припустити присвоєння і записати
 
``` java
t1.level = t2.level;
```
 
При цьому програма збереже два різних об'єкта, а не «викине» один з них, «прив'язавши» посилання **t1** і **t2** до єдиного об'єкту. Незабаром ви зрозумієте, що пряма робота з полями даних всередині об'єктів суперечить принципам об'єктно-орієнтованої розробки. Втім, це непросте питання, так що поки вам досить запам'ятати, що присвоєння об'єктів може таїти в собі чимало сюрпризів.
 
### Поєднання імен під час виклику методів
 
Поєднання імен також може відбуватися при передачі об'єкта методу:
 
``` java
//: Operators/PassObject.java
// Передача об'єктів методам може працювати
// не так, як ви звикли
import static net.mindview.util.Print. *;
 
class Letter {
	char c;
}
 
public class PassObject {
	static void f(Letter y) {
		yc = 'z';
	}
	public static void main(String [] args) {
		Letter x = new Letter();
		xc = 'a';
		print("1: xc:" + xc);
		f(x);
		print("2: xc:" + xc);
	}
} /* Результат:
1: xc: a
2: xc: z
*///: ~
```
 
У багатьох мовах програмування метод **f()** створив би копію свого параметра **Letter** всередині своєї області дії. Але через передачу посилання рядок
  
``` java
у.с = 'z';
```
 
насправді змінює об'єкт за межами методу **f()**.
 
Поєднання імен та рішення цієї проблеми - складні теми. Будьте дуже уважними в таких випадках, щоб уникнути пасток.
 
## Математичні оператори
 
### Основні математичні оператори
 
Основні математичні оператори залишаються незмінними майже у всіх мовах програмування:
 
- додавання(**+**); 
- віднімання(**-**); 
- ділення(**/**); 
- множення(**\***);
- залишок від ділення націло(**%**);
 
Ділення націло обрізає, а не округлює результат.
 
В *Java* також використовується скорочена форма запису для того, щоб одночасно провести операцію і присвоєння. Вона позначається оператором з подальшим знаком рівності і працює однаково для всіх операторів(коли в цьому є сенс). Наприклад, щоб додати *4* до змінної **х** і привласнити результат **х**, можна використати команду **х + = 4**.
 
Наступний приклад демонструє використання арифметичних операцій:
 
``` java
//: Operators/MathOps.java
// Демонстрація математичних операторів.
import java.util. *;
import static net.mindview.util.Print. *;
 
public class MathOps {
	public static void main(String [] args) {
		// Create a seeded random number generator:
		Random rand = new Random(47);
		int i, j, k;
		// Choose value from 1 to 100:
		j = rand.nextInt(100) + 1;
		print("j:" + j);
		k = rand.nextInt(100) + 1;
		print("k:" + k);
		i = j + k;
		print("j + k:" + i);
		i = j - k;
		print("j - k:" + i);
		i = k/j;
		print("k/j:" + i);
		i = k * j;
		print("k * j:" + i);
		i = k% j;
		print("k% j:" + i);
		j% = k;
		print("j% = k:" + j);
		// Floating-point number tests:
		float u, v, w; // Applies to doubles, too
		v = rand.nextFloat();
		print("v:" + v);
		w = rand.nextFloat();
		print("w:" + w);
		u = v + w;
		print("v + w:" + u);
		u = v - w;
		print("v - w:" + u);
		u = v * w;
		print("v * w:" + u);
		u = v/w;
		print("v/w:" + u);
		// The following also works for char,
		// Byte, short, int, long, and double:
		u + = v;
		print("u + = v:" + u);
		u - = v;
		print("u - = v:" + u);
		u * = v;
		print("u * = v:" + u);
		u/= v;
		print("u/= v:" + u);
	}
} /* Результат:
j: 59
k: 56
j + k: 115
j - k: 3
k/j: 0
k * j: 3304
k% j: 56
j% = k: 3
v: 0.5309454
w: 0.0534122
v + w: 0.5843576
v - w: 0.47753322
v * w: 0.028358962
v/w: 9.940527
u + = v: 10.471473
u - = v: 9.940527
u * = v: 5.2778773
u/= v: 9.940527
*///: ~
```
 
Для отримання випадкових чисел створюється об'єкт **Random**. Якщо він створюється без параметрів, *Java* використовує поточний час для розкрутки генератора, щоб при кожному запуску програми видавалися різні числа.
 
Програма генерує різні типи випадкових чисел, викликаючи відповідні методи об'єкта **Random**: **nextInt()** і **nextFloat()**(також можна використовувати **nextLong()** і **nextDouble()**). Аргумент **nextInt()** задає верхню межу генерації чисел. Нижня межа дорівнює *0*, але для запобігання можливого ділення на *0* результат зміщується на *1*.
 
### Унарні оператори плюс і мінус
 
Унарні мінус(**-**) і плюс(**+**) зовні не відрізняються від аналогічних бінарних операторів. Компілятор вибирає потрібний оператор відповідно до контексту використання. Наприклад, команда

``` java
х = -а;
```

має очевидний сенс. Компілятор без зусиль розбереться, що означає
 
``` java
х = а * -b;
```

але той хто буде читати код може заплутатися, так що ясніше буде написати так:

``` java
х = а *(-b);
```

Унарний мінус змінює знак числа на протилежний. Унарний плюс існує «для симетрії», хоча і не робить ніяких дій.
 
## Автозбільшення і функція автоматичного зменшення
 
В *Java*, як і в *C*, існує безліч різних скорочень. Скорочення можуть спростити написання коду, а також спростити, або ускладнити його читання.
 
Два найбільш корисних скорочення - це оператори збільшення(інкременту) і зменшення(декременту)(також часто звані операторами автоматичного збільшення і зменшення). Оператор декременту записується у вигляді **--** і означає «зменьшити на одиницю».
 
Оператор інкременту позначається символами **++** і дозволяє «збільшити на одиницю». Наприклад, якщо змінна **а** є цілим числом, то вираз **++а** буде еквівалентним(**а = а + 1**). Оператори інкремента і декремента не тільки змінюють змінну, а й встановлюють їй в якості результату нове значення.
 
Кожен з цих операторів існує в двох версіях: *префіксної* і *постфіксної*. Префіксний інкремент значить, що оператор **++** записується перед змінною, або виразом, а в постфіксному інкременті оператор слідує після змінної, або виразу. Аналогічно, при префіксному декременті оператор **--** вказується перед змінною, або виразом, а при постфіксному - після змінної, або виразу.
 
Для префіксного інкремента і декремента(тобто **++а** і **--а**) спочатку виконується операція, а потім видається результат. Для постфіксного(**а++** і **а--**) спочатку видається значення, і лише потім виконується операція. Наприклад:
 
 
``` java
//: Operators/AutoInc.java
// Демонстрація ++ і -- операторів.
import static net.mindview.util.Print. *;
 
public class AutoInc {
	public static void main(String [] args) {
		int i = 1;
		print("i:" + i);
		print("++ i:" + ++ i); // Pre-increment
		print("i ++:" + i ++); // Post-increment
		print("i:" + i);
		print("- i:" + --i); // Pre-decrement
		print("i--:" + i--); // Post-decrement
		print("i:" + i);
	}
} /* Результат:
i: 1
++ i: 2
i ++: 2
i: 3
--i: 2
i--: 2
i: 1
*///: ~
```
 
Ви бачите, що при використанні префіксної форми результат отримується після виконання операції, тоді як з постфікснох форми він доступний до виконання операції. Це єдині оператори(крім операторів присвоєння), які мають побічний ефект.(Інакше кажучи, вони змінюють свій операнд замість простого використання його значення.)
 
Оператор інкременту пояснює походження назви мови *C++*; мається на увазі «крок вперед в порівнянні з *C*». В одній з перших промов, присвячених *Java*, Білл Джой(один з його творців) сказав, що «*Java* = C++--»(«Сі плюс плюс мінус мінус»). Він мав на увазі, що *Java* - це *C++*, з якого прибрано все, що ускладнює програмування, і тому мова стала набагато простішою. Просуваючись вперед, ви побачите, що окремі аспекти мови, звичайно, простіші, і все ж *Java* не настільки простіша *C++*.
 
## Оператори порівняння і логічні оператори
 
Оператори порівняння видають логічний(**boolean**) результат. Вони перевіряють, в якому відношенні знаходяться значення їх операндів. Якщо умова перевірки істинна, оператор видає **true**, а якщо ні - **false**. До операторів порівняння відносяться наступні: «менше ніж»(**<**), «більше ніж»(**>**), «менше ніж, або дорівнює»(**<=**), «більше ніж, або дорівнює»(**>=**), «дорівнює»(**==**) і «не дорівнює»(**!=**). «Не дорівнює» і «не дорівнює» працюють для всіх примітивних типів даних, проте інші порівняння не прийнятні для типу **boolean**.
 
### Перевірка об'єктів на рівність
 
Операції відносин **==** і **!=** Також працюють з будь-якими об'єктами, але їх зміст нерідко спантеличує початкових програмістів на *Java*. приклад:
 
 
``` java
//: Operators/Equivalence.java 
public class Equivalence {
	public static void main(String [] args) {
		Integer n1 = new Integer(47);
		Integer n2 = new Integer(47);
		System.out.println(n1 == n2);
		System.out.println(n1 != n2);
	}
} /* Результат:
false
true
*///: ~
```
 
Вираз **System.out.println(n1 == n2)** виведе результат логічного порівняння, що міститься в дужках. Здавалося б, що в першому випадку результат повинен бути істинним(**true**), а в другому - хибним(**false**), так як обидва об'єкти типу **Integer** мають однакові значення. Але в той час як вміст об'єктів однаковий, посилання на них різні, а оператори **!=** і **==** порівнюють саме посилання. Тому результатом першого виразу буде **false**, а другого - **true**. Природно, такі результати спочатку приголомшують.
 
А якщо знадобиться порівняти дійсно вміст об'єктів? Доведеться використовувати спеціальний метод **equals()**, що підтримується всіма об'єктами(але не примітивами, для яких більш ніж достатньо операторів **==** і **!=**). Ось як це робиться:
 
 
``` java
//: Operators/EqualsMethod.java
 
public class EqualsMethod {
	public static void main(String [] args) {
		Integer n1 = new Integer(47);
		Integer n2 = new Integer(47);
		System.out.println(n1.equals(n2));
	}
} /* Результат:
true
*///: ~
```
 
На цей раз результат виявиться «істиною»(**true**), як і передбачалося. Але все не так просто, як здається. Якщо ви створите свій власний клас на зразок такого:
 
 
``` java
//: Operators/EqualsMethod2.java
// equals() по замовченню не порівнює вміст.

class Value {
	int i;
}
 
public class EqualsMethod2 {
	public static void main(String [] args) {
		Value v1 = new Value();
		Value v2 = new Value();
		v1.i = v2.i = 100;
		System.out.println(v1.equals(v2));
	}
} /* Результат:
false
*///: ~
```
 
ми повернемося до того, з чого почали: результатом буде **false**. Справа в тому, що метод **equals()** по замовченню порівнює посилання. Отже, поки ви не перевизначите цей метод в вашому новому класі, не отримаєте бажаного результату. На жаль, перевизначення буде розглядатися тільки в главі 8, а поки обережність і загальне розуміння принципу роботи **equals()** дозволить уникнути деяких неприємностей.
 
Більшість класів бібліотек *Java* реалізують метод **equals()** по-своєму, порівнюючи вміст об'єктів, а не посилання на них.
 
## Логічні оператори
 
Логічні оператори *І*(**&&**), *АБО*(**||**) і *НЕ*(**!**) повертають логічні значення **true** * і **false**, засновані на логічних відносинах своїх аргументів. У наступному прикладі використовуються як оператори порівняння, так і логічні оператори:
 
 
``` java
//: Operators/Bool.java
// Оператори порівняння і логічні оператори.
import java.util. *;
import static net.mindview.util.Print. *;
 
public class Bool {
	public static void main(String [] args) {
		Random rand = new Random(47);
		int i = rand.nextInt(100);
		Operators 71   int j = rand.nextInt(100);
		print("i =" + i);
		print("j =" + j);
		print("i> j is" +(i> j));
		print("i <j is" +(i <j));
		print("i> = j is" +(i> = j));
		print("i <= j is" +(i <= j));
		print("i == j is" +(i == j));
		print("i! = j is" +(i! = j));
		// Treating an int as a boolean is not legal Java :
		//! print("i && j is" +(i && j));
		//! print("i || j is" +(i || j));
		//! print("! i is" +! i);
		print("(i <10) &&(j <10) is"
			+((I <10) &&(j <10)));
		print("(i <10) ||(j <10) is"
			+((I <10) ||(j <10)));
	}
} /* Результат:
i = 58
j = 55
i> j is true
i <j is false
i> = j is true
i <= j is false
i == j is false
i! = j is true
(i <10) &&(j <10) is false
(i <10) ||(j <10) is false
*///: ~
```
 
Операції *І*, *АБО* і *НЕ* застосовуються тільки до логічних(**boolean**) значень. Не можна використовувати в логічних виразах ні - **boolean** - типи як булевих, як це дозволяється в *C* і *C++*. Невдалі спроби такого роду видно в рядках, позначених особливим коментарем **//!**(Цей синтаксис дозволяє автоматично видаляти коментарі для зручності тестування). Наступні вирази виробляють логічні результати, використовуючи оператори порівнянь, після чого до отриманих значеннь застосовують логічні операції.
 
Зауважте, що значення **boolean** автоматично перетворюється в підходяще строкове представлення там, де передбачається використання строкового типу **String**.
 
Визначення **int** в цій програмі можна замінити будь-яким примітивним типом, за винятком **boolean**. Втім, будьте обережні з дійсними числами, оскільки їх порівняння проводиться з високою точністю. Число, хоча б трохи відрізняється від іншого, вже вважається нерівним йому. Число, на тисячну частку більше нуля, вже не є нулем.
 
### Прискорене обчислення
 
При роботі з логічними операторами можна зіткнутися з феноменом, який називають «прискореним обчисленням». Це означає, що вираз обчислюється тільки до тих пір, поки не стане очевидно, що воно приймає значення «істина», або «брехня». В результаті, деякі частини логічного виразу можуть бути проігноровані у процесі порівняння. Наступний приклад демонструє прискорене обчислення:

``` java
//: Operators/ShortCircuit.java
// Демонстрація прискоренного обчислення
// з логічними операторами.
import static net.mindview.util.Print. *;
 
public class ShortCircuit {
	static boolean test1(int val) {
		print("test1(" + val + ")");
		print("result:" +(val <1));
		return val <1;
	}
	static boolean test2(int val) {
		print("test2(" + val + ")");
		print("result:" +(val <2));
		return val <2;
	}
	static boolean test3(int val) {
		print("test3(" + val + ")");
		print("result:" +(val <3));
		return val <3;
	}
	public static void main(String [] args) {
		boolean b = test1(0) && test2(2) && test3(2);
		print("expression is" + b);
	}
} /* Результат:
test1(0)
result: true
test2(2)
result: false
expression is false
*///: ~
```
 
Кожен з методів **test()** проводить порівняння свого аргументу і повертає, або **true**, або **false**. Також вони виводять інформацію про факт свого виклику. Ці методи використовуються в виразі:
 
``` java
test1(0) && test2(2) && test3(2)
```
 
Природно було б очікувати, що всі три методи повинні виконуватися, але результат програми показує інше. Перший метод повертає результат **true**, тому обчислення виразу триває. Однак другий метод видає результат **false**. Так як це автоматично означає, що весь вираз дорівнюватиме **false**, то навіщо продовжувати обчислення? Тільки зайва трата часу. Саме це і стало причиною введення в мову прискореного обчислення; відмова від зайвих обчислень забезпечує потенційний виграш в продуктивності.
 
## Літерали
 
Зазвичай, коли ви записуєте в програмі будь-яке значення, компілятор точно знає, до якого типу воно відноситься. Однак в деяких ситуаціях однозначно визначити тип не вдається. У таких випадках слід допомогти компілятору визначити точний тип, додавши додаткову інформацію у вигляді певних символьних позначень, пов'язаних з типами даних. Ці позначення використовуються в наступній програмі:
 
 
``` java
//: Operators/Literals.java
import static net.mindview.util.Print. *;
 
public class Literals {
	public static void main(String [] args) {
		int i1 = 0x2f; // Hexadecimal(lowercase)
		print("i1:" + Integer.toBinaryString(i1));
		int i2 = 0X2F; // Hexadecimal(uppercase)
		print("i2:" + Integer.toBinaryString(i2));
		int i3 = 0177; // Octal(leading zero)
		print("i3:" + Integer.toBinaryString(i3));
		char c = 0xffff; // Max char hex value
		Operators 73   print("c:" + Integer.toBinaryString(c));
		byte b = 0x7f; // Max byte hex value
		print("b:" + Integer.toBinaryString(b));
		short s = 0x7fff; // Max short hex value
		print("s:" + Integer.toBinaryString(s));
		long n1 = 200L; // Long suffix
		long n2 = 200l; // Long suffix(but can be confusing)
		long n3 = 200;
		float f1 = 1;
		float f2 = 1F; // Float suffix
		float f3 = 1f; // Float suffix
		double d1 = 1d; // Double suffix
		double d2 = 1D; // Double suffix
		//(Hex and Octal also work with long)
	}
} /* Результат:
i1: 101111
i2: 101111
i3: 1111111
c: 1111111111111111
b: 1111111
s: 111111111111111
*///: ~
```
 
Останній символ позначає тип записаного літерала. Велика, або мала літера **L** визначає тип **long**(втім, мала **l** може створити проблеми, тому що вона схожа на цифру *1*); Велика, або мала **F** відповідає типу **float**, а велика, або мала **D** має на увазі тип **double**.
 
Шістнадцяткове подання (основа 16) працює з усіма вбудованими типами даних і починається з префікса **0x**, або **0X** з подальшим числовим значенням з цифр **0-9** і букв **af**, великих, або малих. Якщо при визначенні змінної задається значення, яке переважає максимально для неї можливе (незалежно від числової форми), компілятор повідомить вас про помилку. У програмі вказані максимальні значення для типів **char, byte** і **short**. При виході за ці межі компілятор автоматично зробить значення типом **int** і повідомить вам, що для присвоєння знадобиться звужуюче приведення.
 
Вісімкове подання (основа 8) позначається початковим нулем в записі числа, що складається з цифр **0 - 7**. Для літерального запису чисел в двійковому поданні в *Java*, *C* і *C++* підтримки немає. Втім, при роботі з шістнадцятерічними і вісімковими числами часто потрібно отримати двійкове подання результату. Завдання легко вирішується методами **static toBinaryString()** класів **Integer** і **Long**.
 
### Експоненціальний запис
 
Експонентні значення записуються, як на мене, дуже невдало: **1.39e-43f**. В науці і інженерній справі символом **е** позначається основа натурального логарифма, рівна приблизно *2.718*.(Більш точне значення цієї величини в Java можна отримати як **Math.E**.)
 
Воно використовується в експоненційних виразах, таких як *1.39 \* е<sup>-43</sup>*, що фактично означає *1.39 \* 2.718<sup>-43</sup>*. Однак під час винаходу мови FORTRAN було вирішено, що **e** означатиме «десять в ступені», що досить дивно, оскільки FORTRAN розроблявся для науки і техніки і можна було припустити, що його творці звернуть увагу на подібну неоднозначність.
 
Так чи інакше, цей звичай був перейнятий в *C*, *C++*, а потім перейшов в *Java*. Таким чином, якщо ви звикли бачити в **е** основу натурального логарифма, вам доведеться кожного разу робити перетворення в думці: якщо ви побачили в *Java* вираз **1.39e-43f**, насправді воно означає *1.39 \* 10 <sup>-43</sup>*.
 
Якщо компілятор може визначити тип автоматично, наявність завершального суфікса типу не обов'язкова. У записі
 
``` java
long n3 = 200;
```
 
не існує ніяких неясностей, і тому використання символу **L** після значення *200* було б зайвим. Однак у записі
 
``` java
float f4 = 1e-43f; // Десять в ступені
```
 
компілятор зазвичай трактує експоненціальні числа як **double**. Без завершального символа **f** він повідомить вам про помилку і необхідності використання приведення для перетворення **double** до типу **float**.
 
## Порозрядні оператори
 
### Порозрядні логічні оператори
 
Порозрядні оператори маніпулюють окремими бітами в цілочисельних примітивних типах даних. Результат визначається діями булевої алгебри з відповідними бітами двохоперандів. Ці бітові оператори походять від низкорівневої спрямованості мови *C*, де часто доводиться безпосередньо працювати з обладнанням і встановлювати біти в апаратних регістрах. *Java* спочатку розроблявся для управління телевізійними приставками, тому ця низкорівнева орієнтація все ще була потрібна. Втім, вам навряд чи доведеться часто використовувати ці оператори.
 
-    Порозрядний оператор *І* (**&**) заносить *1* у вихідний біт, якщо обидва вхідних біта були рівні *1*; в іншому випадку результат дорівнює *0*.
-    Порозрядний оператор *АБО* (**|**) заносить *1* у вихідний біт, якщо хоча б один з бітів операндів дорівнює *1*; результат дорівнює *0* тільки в тому випадку, якщо обидва біта операндів були нульовими.
-    Оператор *ВИКЛЮЧЕННЯ АБО, XOR* (**^**) має результатом одиницю тоді, коли один з вхідних бітів був одиницею, але не обидва разом.
-    Порозрядний оператор *НІ* (**~**), також званий оператором довічного доповнення, є унарним оператором, тобто має тільки один операнд. Порозрядне *НІ* виробляє біт, «протилежний» до вихідного - якщо вхідний біт є нулем, то в результуючому біті буду одиниця, якщо вхідний біт одиниця, то отримаємо нуль.
 
Порозрядні оператори і логічні оператори записуються за допомогою одних і тих же символів, тому корисно запам'ятати мнемонічне правило: так як біти «маленькі», в порозрядних операторах використовується всього один символ.
 
Порозрядні оператори можуть комбінуватися зі знаком рівності **=**, щоб поєднати операцію і привласнення: **&=**, **|=** і **^=** є допустимими поєднаннями. (Так як ** ~** є унарним оператором, він не може використовуватися разом зі знаком "**=**".)
 
Тип **boolean** трактується як однобітовий, тому операції з ним виглядають по-іншому. Ви маєте право виконати порозрядні *І, АБО* і *ВИКЛЮЧАЮЧЕ АБО*, але *НІ* використовувати заборонено (мабуть, щоб запобігти плутанині з логічним *НІ*). Для типу **boolean** порозрядні оператори створюють той же ефект, що і логічні, за одним винятком - вони не підтримують прискореного обчислення.
 
Крім того, в число порозрядних операторів для **boolean** входить оператор *ВИКЛЮЧАЮЧЕ АБО*, відсутній в списку логічних операторів. Для булевих типів не дозволяється використання операторів зсуву, описаних в наступному розділі.
 
## Оператори зсуву
 
Оператори зсуву також маніпулюють битами і використовуються тільки з примітивними цілочисельними типами. Оператор зсуву вліво (**&lt;&lt;**) зсуває вліво операнд, що знаходиться зліва від оператора, на кількість бітів, що вказане після оператора. Оператор зсуву вправо (**&gt;&gt;**) зсуває вправо операнд, що знаходиться зліва від оператора, на кількість бітів, що вказане після оператора. При зсуві вправо використовується заповнення знаком: при позитивному значенні нові біти заповнюються нулями, а при негативному - одиницями.
 
В *Java* також підтримується беззнаковий зсув вправо (**&gt;&gt;&gt;**), який використовує заповнення нулями: незалежно від знака старші біти заповнюються нулями. Такий оператор не має аналогів в *C* і *C++*.
 
Якщо зсуване значення відноситься до типу **char, byte**, або **short**, ці типи перетворюються до **int** перед виконанням зсуву, і результат також вийде **int** . При цьому використовується тільки п'ять молодших бітів з «правої» сторони. Таким чином, не можна зсунути бітів більше, ніж взагалі існує для цілого числа **int**. Якщо ви проводите операції з числами **long**, то отримаєте результати типу **long**. При цьому буде задіяно лише шість молодших бітів з «правої» сторони, що запобігає використанню зайвого числа бітів.
 
Зсунення можна поєднувати зі знаком рівності(**&lt;&lt;=**, або **&gt;&gt;=**, або **&gt;&gt;&gt;=**). Іменований вираз замінюється ним же, але з проведеними над ним операціями зсуву. Однак при цьому виникає проблема з оператором беззнакового правого зсуву, поєднаного з присвоєнням. При використанні його з типом **byte**, або **short** ви не отримаєте правильних результатів. Замість цього вони спочатку будуть перетворені до типу **int** і зсунені вправо, а потім обрізані при поверненні до вихідного типу, і результатом стане *-1*. Наступний приклад демонструє це:
 
 
``` java
//: Operators/URShift.java
// Перевірка беззнакового правого зсуву.

import static net.mindview.util.Print.*;

public class URShift {
    public static void main(String[] args) {
        int i = -1;
        print(Integer.toBinaryString(i));
        i >>> = 10;
        print(Integer.toBinaryString(i));
        long l = -1;
        print(Long.toBinaryString(l));
        l >>> = 10;
        print(Long.toBinaryString(l));
        short s = -1;
        print(Integer.toBinaryString(s));
        s >>> = 10;
        print(Integer.toBinaryString(s));
        byte b = -1;
        print(Integer.toBinaryString(b));
        b >>> = 10;
        print(Integer.toBinaryString(b));
        b = -1;
        print(Integer.toBinaryString(b));
        print(Integer.toBinaryString(b >>> 10));
    }
} /* Результат:
11111111111111111111111111111111
+1111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111
111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
11111111111111111111111111111111
+1111111111111111111111
*///: ~
```
 
В останній команді програми отримане значення не приводиться назад до **b**, тому получається правильна дія.
 
Наступний приклад демонструє використання всіх операторів, так чи інакше пов'язаних з порозрядною операцією:
 
 
``` java
//: Operators/BitManipulation.java
// Використання операцій зсуву.
import java.util. *;
import static net.mindview.util.Print. *;

public class BitManipulation {
    public static void main(String [] args) {
        Random rand = new Random(47);
        int i = rand.nextInt();
        int j = rand.nextInt();
        printBinaryInt("- 1", -1);
        printBinaryInt("+ 1", +1);
        int maxpos = 2147483647;
        printBinaryInt("maxpos", maxpos);
        int maxneg = -2147483648;
        printBinaryInt("maxneg", maxneg);
        printBinaryInt("i", i);
        printBinaryInt("~ i", ~ i);
        printBinaryInt("- i", -i);
        printBinaryInt("j", j);
        printBinaryInt("i & j", i & j);
        printBinaryInt("i | j", i | j);
        printBinaryInt("i ^ j", i ^ j);
        printBinaryInt("i << 5", i << 5);
        printBinaryInt("i >> 5", i >> 5);
        printBinaryInt("(~ i) >> 5",(~ i) >> 5);
        printBinaryInt("i >>> 5", i >>> 5);
        printBinaryInt("(~ i) >>> 5",(~ i) >>> 5);

        long l = rand.nextLong();
        long m = rand.nextLong();
        printBinaryLong("- 1L", -1L);
        printBinaryLong("+ 1L", + 1L);
        long ll = 9223372036854775807L;
        printBinaryLong("maxpos", ll);
        long lln = -9223372036854775808L;
        printBinaryLong("maxneg", lln);
        printBinaryLong("l", l);
        printBinaryLong("~ l", ~ l);
        printBinaryLong("- l", -l);
        printBinaryLong("m", m);
        printBinaryLong("l & m", l & m);
        printBinaryLong("l | m", l | m);
        printBinaryLong("l ^ m", l ^ m);
        printBinaryLong("l << 5", l << 5);
        printBinaryLong("l >> 5", l >> 5);
        printBinaryLong("(~ l) >> 5",(~ l) >> 5);
        printBinaryLong("l >>> 5", l >>> 5);
        printBinaryLong("(~ l) >>> 5",(~ l) >>> 5);
    }
    static void printBinaryInt(String s, int i) {
        print(s + ", int:" + i + ", binary: \ n" +
                Integer.toBinaryString(i));
    }
    static void printBinaryLong(String s, long l) {
        print(s + ", long:" + l + ", binary: \ n" +
                Long.toBinaryString(l));
    }
} /* Результат:
-    1, int: -1, binary:
11111111111111111111111111111111
+1, Int: 1, binary:
1
maxpos, int: 2147483647, binary:
1111111111111111111111111111111
maxneg, int: -2147483648, binary:
10000000000000000000000000000000
i, int: -1172028779, binary:
10111010001001000100001010010101
~ I, int: 1172028778, binary:
1000101110110111011110101101010
-    i, int: 1172028779, binary:
1000101110110111011110101101011
j, int: 1717241110, binary:
1100110010110110000010100010110
i & j, int: 570425364, binary:
+100010000000000000000000010100
i | j, int: -25213033, binary:
11111110011111110100011110010111
i ^ j, int: -595 638 397, binary:
11011100011111110100011110000011
i << 5, int: 1149784736, binary:
1000100100010000101001010100000
i >> 5, int: -36625900, binary:
11111101110100010010001000010100
(~ I) >> 5, int: 36625899, binary:
+10001011101101110111101011
i >>> 5, int: 97591828, binary:
+101110100010010001000010100
(~ I) >>> 5, int: 36625899, binary:
+10001011101101110111101011
...
*///: ~
```
 
Два методи в кінці, **printBinaryInt()** і **printBinaryLong()**, отримують в якості параметрів, відповідно, числа **int** і **long** і виводять їх в двійковому форматі разом з супровідним текстом. Разом з демонстрацією порозрядних операцій для типів **int** і **long** цей приклад також виводить мінімальне і максимальне значення, *+1* і *-1* для цих типів, щоб ви краще розуміли, як вони виглядають в двійковому поданні. Зауважте, що старший біт позначає знак: *0* відповідає позитивному і *1* - негативному числам. Результат роботи для типу **int** наведено в кінці лістингу.
 
## Тернарний умовний оператор **if-else**
 
Тернарний оператор незвичайний тим, що він використовує три операнда. І все ж це дійсно оператор, так як він повертає значення, на відміну від звичайної конструкції вибору **if-else**, описаної в наступному розділі. Вираз записується в такій формі:
 
	логічна-умова?вираз0:вираз1
 
Якщо **логічна-умова** істинна (**true**), то потім обчислюється **вираз0**, і саме його результат стає результатом виконання всього оператора. Якщо ж логічна-умова помилкова (**false**), то обчислюється **вираз1**, і його значення стає результатом роботи оператора. Приклад використання тернарного оператора:
 
 
``` java
//: Operators/TernaryIfElse.java
import static net.mindview.util.Print. *;

public class TernaryIfElse {
    static int ternary(int i) {
        return i <10? i * 100: i * 10;
    }
    static int standardIfElse(int i) {
        if(i <10)
            return i * 100;
        else
            return i * 10;
    }
    public static void main(String [] args) {
        print(ternary(9));
        print(ternary(10));
        print(standardIfElse(9));
        print(standardIfElse(10));
    }
} /* Результат:
900
100
900
100
*///: ~
```
 
Звичайно, тут можна було б використати стандартну конструкцію **if-else** (описувану трохи пізніше), але тернарний оператор набагато компактніший. Хоча *C* (де цей оператор вперше з'явився) претендує на звання лаконічного мови, і тернарний оператор вводився частково для досягнення цієї мети, будьте розсудливі і не використовуйте його всюди і постійно - він може погіршити читабельність програми.
 
## Оператори + і += для **String**
 
В *Java* існує особливий випадок використання оператора: оператори **+** і **+ =** можуть застосовуватися для конкатенації (об'єднання) рядків, і ви вже це бачили. Така дія для цих операторів виглядає цілком природно, хоча вонf і не відповідає традиційним принципам їх використання.
 
При створенні *C++* в мову була додана можливість перевантаження операторів, що дозволяє програмістам *C++* змінювати і розширювати зміст майже будь-якого оператора. На жаль, перевантаження операторів, в поєднанні з деякими обмеженнями *C++*, створилj чимало проблем при проектуванні класів. Хоча реалізацію перевантаження операторів в *Java* можна було здійснити простіше, ніж в *C++* (це продемонстровано в мові *C#*, де існує простий механізм перевантаження), цю можливість все ж порахували зайво складною, і тому програмістам на *Java* не дано реалізувати свої власні перевантажені оператори, як це роблять програмісти на *C++*.
 
Використання **+** і **+=** для рядків (**String**) має цікаві особливості. Якщо вираз починається рядком, то всі наступні операнди також будуть попередньо перетворені в рядкове подання! (Пам'ятаєте, що компілятор перетворює символи в лапках в об'єкт **String**).
 
 
``` java
int х = 0; у = 1; z = 2;
String s = "х, у, z";
System.out.println(s + x + у + z);
```
 
В даному випадку компілятор *Java* перетворить змінні **х, у** і **z** до їх рядкового подання, замість того щоб спочатку арифметично скласти їх. А якщо ви запишете
 
 
``` java
System.out.println(x + s);
```
 
то і тут *Java* перетворює **x** в рядок.
 
 
## Типові помилки при використанні операторів
 
Багато програмістів схильні поспіхом записувати вираз без дужок, навіть коли вони не впевнені в послідовності обчислення виразу. Це вірно і для *Java*.
 
Ще одна поширена помилка в *C* і *C++* виглядає наступним чином:
 
``` java
while(x = у) {
// ...
}
```
 
Програміст хотів виконати порівняння(**==**), а не привласнення. В *C* і *C++* результат цього виразу завжди буде істинним, якщо **у** не рівне нулю; ймовірно, виникне нескінченний цикл. У мові *Java* результат такого виразу не буде логічним типом (**boolean**), а компілятор очікує в цьому виразі саме **boolean** і не дозволяє використовувати цілочисельний тип **int**, тому вчасно повідомить вам про помилку часу компіляції, виявивши проблему ще перед запуском програми. Тому подібна помилка в *Java* ніколи не відбувається. (Програма відкомпілюйте тільки в одному випадку: якщо **х** і **у** одночасно є типами **boolean**, і тоді вираз **х = у** буде допустимим, що може призвести до помилки.)
 
Схожа проблема виникає в *C* і *C++* при використанні порозрядних операторів *І* і *АБО* замість їх логічних аналогів. Порозрядні *І* і *АБО* записуються одним символом (**&** і **|**), в той час як логічні *І* і *АБО* вимагають в написанні двох символів (**&&** і **||**). Так само, як і в випадку з операторами **=** і **==**, легко помилитися і набрати один символ замість двох. В *Java* компілятор запобігає і таким помилкам, так як він не дозволяє використовувати тип даних в невідповідному контексті.
 
 
## Оператори приведення
 
Слово приведення використовується в сенсі «приведення до іншого типу». У певних ситуаціях *Java* самостійно перетворює дані до інших типів. Наприклад, якщо дійсній змінній присвоюється ціле значення, компілятор автоматично виконує відповідні перетворення (**int** перетворюється на **float**). Приведення дозволяє зробити заміну типу більш явною, або виконати її примусово у випадках, де це не відбувається в звичайному порядку.
 
Щоб виконати приведення явно, запишіть необхідний тип даних (включаючи всі модифікатори) в круглих дужках зліва від перетворюваного значення. приклад:
 
 
``` java
//: Operators/Casting.java

public class Casting {
    public static void main(String [] args) {
        int i = 200;
        long lng =(long) i;
        lng = i; // "Widening," so cast not really required
        long lng2 =(long) 200;
        lng2 = 200;
// A "narrowing conversion":
        i =(int) lng2; // Cast required
    }
} ///: ~
```
 
Як бачите, приведення може виконуватися і для чисел, і для змінних. Втім, в зазначених прикладах приведення є зайвим, оскільки компілятор при необхідності автоматично перетворює ціле **int** до типу **long**. Однак це не заважає вам виконувати необов'язкові приведення. Наприклад, щоб підкреслити якусь обставину, або просто для того, щоб зробити програму більш зрозумілою. В інших ситуаціях приведення може бути необхідне для нормальної компіляції програми.
 
В *C* і *C++* приведення могло стати джерелом помилок і неоднозначності. В *Java* приведення безпечно, за одним винятком: при виконанні так званого звужено приведення (тобто від типу даних, здатного зберігати більше інформації, до менш вмістовного типу даних), тобто при небезпеці втрати даних. В такому випадку компілятор змушує вас виконати явне приведення; фактично він говорить: «це може бути небезпечно, але, якщо ви впевнені у своїй правоті, опишіть дію явно». У випадку з розширюваним приведенням явний опис не знадобиться, так як новий тип даних здатний зберігати більше інформації, ніж колишній, і тому втрата даних виключена.
 
В *Java* дозволяється приводити будь-який найпростіший тип даних до будь-якого іншого найпростішого типу, але це не відноситься до типу **boolean**, який взагалі не підлягає приведенню. Класи також не підтримують довільне приведення. Щоб перетворити один клас в інший, потрібні спеціальні методи. (Як буде показано пізніше, об'єкти можна перетворювати в рамках сімейства типів; об'єкт **Дуб** можна перетворити в **Дерево** і навпаки, але не до стороннього типу на зразок **Каменя**.)
 
### Округлення і усічення
 
При виконанні звужуючих приведень необхідно звертати увагу на усічення і округлення даних. Наприклад, як повинен діяти компілятор *Java* при перетворенні реального числа в ціле? Скажімо, якщо значення *29.7* приводиться до типу **int**, що вийде - *29*, чи *30*?
 
Відповідь на це питання може дати наступний приклад:
 
 
``` java
//: Operators/CastingNumbers.java
// Що трапиться коли привести дійсне значення
// до цілого?
import static net.mindview.util.Print. *;

public class CastingNumbers {
    public static void main(String [] args) {
        double above = 0.7, below = 0.4;
        float fabove = 0.7f, fbelow = 0.4f;
        print("(int) above:" +(int) above);
        print("(int) below:" +(int) below);
        print("(int) fabove:" +(int) fabove);
        print("(int) fbelow:" +(int) fbelow);
    }
} /* Результат:
(Int) above: 0
(Int) below: 0
(Int) fabove: 0
(Int) fbelow: 0
*///: ~
```
 
Звідси і відповідь на наше питання - приведення з типів з підвищеною точністю **double** і **float** до цілочисельних значеннь завжди здійснюється з урізанням до цілої частини. Якщо ви хочете щоб результат округлявся, то використовуйте метод **round()** з **java.lang.Math**. Так як цей метод є частиною **java.lang**, додаткове імпортування не буде потрібно.
 
### Підвищення
 
Ви можете виявити, що при проведенні будь-яких математичних і порозрядних операцій примітивні типи даних, менші **int** (тобто **char, byte** і **short**), приводяться до типу **int** перед виконанням операцій, і одержуваний результат має тип **int**. Тому, якщо вам знову потрібно привласнити його меншому типу, доведеться використовувати приведення типу. (І тоді можлива втрата інформації.) В основному найбільш ємний тип даних, присутній у виразі, і визначає величину результату цього виразу; так, при перемноженні **float** і **double** результатом стане **double**, а при додаванні **long** і **int** ви отримаєте в результаті **long**.
 
## В *Java* відсутній оператор sizeof()
 
В *C* і *C++* оператор *sizeof()* повертає кількість байтів, виділених для зберігання даних. Головна причина для використання sizeof() - переносимість програм. Різним типам даних може відводитися різна кількість пам'яті на різних комп'ютерах, тому для програміста важливо визначити розмір цих типів перед проведенням операцій, що залежать від цих величин. Наприклад, один комп'ютер виділяє під цілі числа 32 біта, а інший - всього лише 16 біт. В результаті на першій машині програма може зберігати в цілочисленному поданні числа з більшого діапазону. Звичайно, апаратна сумісність створює чимало клопоту для програмістів на *C* і *C++*. В *Java* оператор *sizeof()* не потрібен, так як всі типи даних мають однакові розміри на всіх машинах. Вам не потрібно турбуватися про переносимість на низькому рівні - вона вбудована в мову.
 
## Збірник операторів
 
Наступний приклад показує, які примітивні типи даних використовуються з тими чи іншими операторами. Взагалі-то це один і той же приклад, повторений багато разів, але для різних типів даних. Файл повинен компілюватися без помилок, оскільки всі рядки, що містять невірні операції починаються символами **//!**:
 
 
``` java
//: Operators/AllOps.java
// Тест всіх операторів на всіх примітивних типах даних
// для показу які викоритовуються компілятором Java.

public class AllOps {
    // To accept the results of a boolean test:
    void f(boolean b) {}
    void boolTest(boolean x, boolean y) {
// Arithmetic operators:
//! x = x * y;
//! x = x/y;
//! x = x% y;
//! x = x + y;
//! x = x - y;
//! x ++;
//! x--;
//! x = + y;
//! x = -y;
// Relational and logical:
//! f(x> y);
//! f(x> = y);
//! f(x <y);
//! f(x <= y);
        f(x == y);
        f(x! = y);
        f(! y);
        x = x && y;
        x = x || y;
// Bitwise operators:
//! x = ~ y;
        x = x & y;
        x = x | y;
        x = x ^ y;
//! x = x << 1;
//! x = x >> 1;
//! x = x >>> 1;
// Compound assignment:
//! x + = y;
//! x - = y;
//! x * = y;
//! x/= y;
//! x% = y;
//! x << = 1;
//! x >> = 1;
//! x >>> = 1;
        x & = y;
        x ^ = y;
        x | = y;
// Casting:
//! char c =(char) x;
//! byte b =(byte) x;
//! short s =(short) x;
//! int i =(int) x;
//! long l =(long) x;
//! float f =(float) x;
//! double d =(double) x;
    }
    void charTest(char x, char y) {
// Arithmetic operators:
        x =(char)(x * y);
        x =(char)(x/y);
        x =(char)(x% y);
        x =(char)(x + y);
        x =(char)(x - y);
        x ++;
        x--;
        x =(char) + y;
        x =(char) -y;
// Relational and logical:
        f(x> y);
        f(x> = y);
        f(x <y);
        f(x <= y);
        f(x == y);
        f(x! = y);
//! f(! x);
//! f(x && y);
//! f(x || y);
// Bitwise operators:
        x =(char) ~ y;
        x =(char)(x & y);
        x =(char)(x | y);
        x =(char)(x ^ y);
        x =(char)(x << 1);
        x =(char)(x >> 1);
        x =(char)(x >>> 1);
// Compound assignment:
        x + = y;
        x - = y;
        x * = y;
        x/= y;
        x% = y;
        x << = 1;
        x >> = 1;
        x >>> = 1;
        x & = y;
        x ^ = y;
        x | = y;
// Casting:
//! boolean bl =(boolean) x;
        byte b =(byte) x;
        short s =(short) x;
        int i =(int) x;
        long l =(long) x;
        float f =(float) x;
        double d =(double) x;
    }
    void byteTest(byte x, byte y) {
// Arithmetic operators:
        x =(byte)(x * y);
        x =(byte)(x/y);
        x =(byte)(x% y);
        x =(byte)(x + y);
        x =(byte)(x - y);
        x ++;
        x--;
        x =(byte) + y;
        x =(byte) - y;
// Relational and logical:
        f(x> y);
        f(x> = y);
        f(x <y);
        f(x <= y);
        f(x == y);
        f(x! = y);
//! f(! x);
//! f(x && y);
//! f(x || y);
// Bitwise operators:
        x =(byte) ~ y;
        x =(byte)(x & y);
        x =(byte)(x | y);
        x =(byte)(x ^ y);
        x =(byte)(x << 1);
        x =(byte)(x >> 1);
        x =(byte)(x >>> 1);
// Compound assignment:
        x + = y;
        x - = y;
        x * = y;
        x/= y;
        x% = y;
        x << = 1;
        x >> = 1;
        x >>> = 1;
        x & = y;
        x ^ = y;
        x | = y;
// Casting:
//! boolean bl =(boolean) x;
        char c =(char) x;
        short s =(short) x;
        int i =(int) x;
        long l =(long) x;
        float f =(float) x;
        double d =(double) x;
    }
    void shortTest(short x, short y) {
// Arithmetic operators:
        x =(short)(x * y);
        x =(short)(x/y);
        x =(short)(x% y);
        x =(short)(x + y);
        x =(short)(x - y);
        x ++;
        x--;
        x =(short) + y;
        x =(short) -y;
// Relational and logical:
        f(x> y);
        f(x> = y);
        f(x <y);
        f(x <= y);
        f(x == y);
        f(x! = y);
//! f(! x);
//! f(x && y);
//! f(x || y);
// Bitwise operators:
        x =(short) ~ y;
        x =(short)(x & y);
        x =(short)(x | y);
        x =(short)(x ^ y);
        x =(short)(x << 1);
        x =(short)(x >> 1);
        x =(short)(x >>> 1);
// Compound assignment:
        x + = y;
        x - = y;
        x * = y;
        x/= y;
        x% = y;
        x << = 1;
        x >> = 1;
        x >>> = 1;
        x & = y;
        x ^ = y;
        x | = y;
// Casting:
//! boolean bl =(boolean) x;
        char c =(char) x;
        byte b =(byte) x;
        int i =(int) x;
        long l =(long) x;
        float f =(float) x;
        double d =(double) x;
    }
    void intTest(int x, int y) {
// Arithmetic operators:
        x = x * y;
        x = x/y;
        x = x% y;
        x = x + y;
        x = x - y;
        x ++;
        x--;
        x = + y;
        x = -y;
// Relational and logical:
        f(x> y);
        f(x> = y);
        f(x <y);
        f(x <= y);
        f(x == y);
        f(x! = y);
//! f(! x);
//! f(x && y);
//! f(x || y);
// Bitwise operators:
        x = ~ y;
        x = x & y;
        x = x | y;
        x = x ^ y;
        x = x << 1;
        x = x >> 1;
        x = x >>> 1;
// Compound assignment:
        x + = y;
        x - = y;
        x * = y;
        x/= y;
        x% = y;
        x << = 1;
        x >> = 1;
        x >>> = 1;
        x & = y;
        x ^ = y;
        x | = y;
// Casting:
//! boolean bl =(boolean) x;
        char c =(char) x;
        byte b =(byte) x;
        short s =(short) x;
        long l =(long) x;
        float f =(float) x;
        double d =(double) x;
    }
    void longTest(long x, long y) {
// Arithmetic operators:
        x = x * y;
        x = x/y;
        x = x% y;
        x = x + y;
        x = x - y;
        x ++;
        x--;
        x = + y;
        x = -y;
// Relational and logical:
        f(x> y);
        f(x> = y);
        f(x <y);
        f(x <= y);
        f(x == y);
        f(x! = y);
//! f(! x);
//! f(x && y);
//! f(x || y);
// Bitwise operators:
        x = ~ y;
        x = x & y;
        x = x | y;
        x = x ^ y;
        x = x << 1;
        x = x >> 1;
        x = x >>> 1;
// Compound assignment:
        x + = y;
        x - = y;
        x * = y;
        x/= y;
        x% = y;
        x << = 1;
        x >> = 1;
        x >>> = 1;
        x & = y;
        x ^ = y;
        x | = y;
// Casting:
//! boolean bl =(boolean) x;
        char c =(char) x;
        byte b =(byte) x;
        short s =(short) x;
        int i =(int) x;
        float f =(float) x;
        double d =(double) x;
    }
    void floatTest(float x, float y) {
// Arithmetic operators:
        x = x * y;
        x = x/y;
        x = x% y;
        x = x + y;
        x = x - y;
        x ++;
        x--;
        x = + y;
        x = -y;
// Relational and logical:
        f(x> y);
        f(x> = y);
        f(x <y);
        f(x <= y);
        f(x == y);
        f(x! = y);
//! f(! x);
//! f(x && y);
//! f(x || y);
// Bitwise operators:
//! x = ~ y;
//! x = x & y;
//! x = x | y;
//! x = x ^ y;
//! x = x << 1;
//! x = x >> 1;
//! x = x >>> 1;
// Compound assignment:
        x + = y;
        x - = y;
        x * = y;
        x/= y;
        x% = y;
//! x << = 1;
//! x >> = 1;
//! x >>> = 1;
//! x & = y;
//! x ^ = y;
//! x | = y;
// Casting:
//! boolean bl =(boolean) x;
        char c =(char) x;
        byte b =(byte) x;
        short s =(short) x;
        int i =(int) x;
        long l =(long) x;
        double d =(double) x;
    }
    void doubleTest(double x, double y) {
// Arithmetic operators:
        x = x * y;
        x = x/y;
        x = x% y;
        x = x + y;
        x = x - y;
        x ++;
        x--;
        x = + y;
        x = -y;
// Relational and logical:
        f(x> y);
        f(x> = y);
        f(x <y);
        f(x <= y);
        f(x == y);
        f(x! = y);
//! f(! x);
//! f(x && y);
//! f(x || y);
// Bitwise operators:
//! x = ~ y;
//! x = x & y;
//! x = x | y;
//! x = x ^ y;
//! x = x << 1;
//! x = x >> 1;
//! x = x >>> 1;
// Compound assignment:
        x + = y;
        x - = y;
        x * = y;
        x/= y;
        x% = y;
//! x << = 1;
//! x >> = 1;
//! x >>> = 1;
//! x & = y;
//! x ^ = y;
//! x | = y;
// Casting:
//! boolean bl =(boolean) x;
        char c =(char) x;
        byte b =(byte) x;
        short s =(short) x;
        int i =(int) x;
        long l =(long) x;
        float f =(float) x;
    }
} ///: ~
```
 
Зауважте, що дії з типом **boolean** досить обмежені. Йому можна привласнити значення **true**, або **false**, перевірити на істинність, або хибність, але не можна додати логічні змінні до інших типів, або зробити з ними будь-які інші операції.
 
У випадку з типами **char, byte** і **short** можна помітити ефект підвищення при використанні арифметичних операторів. Будь-яка арифметична операція з цими типами дає результат типу **int**, який потім потрібно явно приводити до початкового типу (звужуюче приведення, при якому можлива втрата інформації). При використанні значень типу **int** приведення здійснювати не доведеться, тому що всі значення вже мають цей тип.
 
Однак не робіть помилки щодо безпечності, того що відбувається. При перемноженні двох досить великих цілих чисел **int** відбудеться переповнення. Наступний приклад демонструє сказане:
 
 
``` java
//: Operators/Overflow.java
// Сюрприз! Java дозволяє переповнення.

public class Overflow {
    public static void main(String [] args) {
        int big = Integer.MAX_VALUE;
        System.out.println("big =" + big);
        int bigger = big * 4;
        System.out.println("bigger =" + bigger);
    }
} /* Результат:
big = 2147483647
bigger = -4
*///: ~
```
 
Компілятор не видає ніяких помилок, або попереджень, і під час виконання не виникне виключень. Мова *Java* хороша, але хороша не настільки.
 
Суміщене присвоювання не вимагає приведення для типів **char, byte, short**, хоча для них і проводиться підвищення, як і в випадку з арифметичними операціями. З іншого боку, відсутність приведення в таких випадках, без сумніву, спрощує програму.
 
Можна легко помітити, що за винятком типу **boolean**, будь-який примітивний тип може бути перетворений до іншого примітиву. Як згадувалося раніше, необхідно остерігатися звуженого приведення при перетвореннях до меншого типу, так як при цьому виникає ризик втрати інформації.
 
## Резюме
 
Читачі з досвідом роботи на будь-якій мові сімейства *C* могли переконатися, що оператори *Java* майже нічим не відрізняються від класичних. Якщо ж матеріал цієї глави здався важким, звертайтеся до мультимедійної презентації «Thinking in *C*» (www.MindView.net).
 
 