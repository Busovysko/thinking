# Управляючі конструкції
 
Подібно будь-якій живій істоті, програма повинна управляти своїм світом і приймати рішення під час виконання. У мові *Java* для прийняття рішень використовуються управляючі конструкції. В *Java* задіяні всі управляючі конструкції мови *C*, тому читачам з досвідом програмування на мові *C*, або *C++* основна частина матеріалу буде знайома. Майже у всіх процедурних мовах підтримуються стандартні команди управління, і в багатьох мовах вони збігаються. В *Java* до їх числа відносяться ключові слова ***if-else, while, do-while, for,*** а також команда вибору ***switch***. Однак в *Java* не підтримується часто критикований оператор ***goto***(який, втім, все ж є найбільш компактним рішенням в деяких ситуаціях). Безумовні переходи «в стилі» ***goto*** можливі, але набагато більш обмежені в порівнянні з класичними переходами ***goto***.
 
## ***true*** і ***false***
 
Всі конструкції з умовою обчислюють істинність, або хибність умовного виразу, щоб визначити спосіб виконання. Приклад умовного виразу - ***А == В***. Оператор порівняння ***==*** перевіряє, чи дорівнює значення ***А*** значенню ***В***. Результат перевірки може бути істинним(***true***), або хибним(***false***). Будь-який з описаних в цьому розділі операторів порівняння може застосовуватися в умовному виразі. Зауважте, що *Java* не дозволяє використовувати числа в якості логічних значень, хоча це дозволено в *C* і *C++*(де не-нуль вважається «істинним», а нуль - «помилковим»). Якщо вам буде потрібно використовувати числовий тип там, де потрібно ***boolean***(скажімо, в умови ***if (a)***), спочатку доведеться його перетворити до логічного типу оператором порівняння в умовному вираженні - наприклад, ***if (а ! = 0)***.
 
## If-else
 
Команда ***if-else*** є, напевно, найбільш поширеним способом передачі управління в програмі. Присутність ключового слова ***else*** не обов'язково, тому конструкція ***if*** існує в двох формах:
 
    if (логічне вираз) команда
 
і
 
    if (логічне вираз) команда else команда
 
Умова має дати результат типу ***boolean***. У секції команди розташовується, або проста команда, завершена крапкою з комою, або складова конструкція з команд, згрупована в фігурні дужки. Як приклад застосування ***if-else*** представлено метод ***test()***, який видає інформацію про порівняння між двома числами - «більше», «менше», або «дорівнює»:
 
 
``` java
//: Control/IfElse.java
import static net.mindview.util.Print.*;
 
public class IfElse {static int result = 0;
    static void test(int testval, int target) {
        if (testval> target)
            result = +1;
        else if (testval <target)
            result = -1;
        else
            result = 0; // Match
    }
    public static void main(String[] args) {
        test(10, 5);
        print(result);
        test(5, 10);
        print(result);
        test(5, 5);
        print(result);
    }
} /* Результат:
1
-1
0
*///: ~
```
 
Всередині методу ***test()*** зустрічається конструкція ***else if***; це не нове ключове слово, a ***else***, за яким слід початок іншої команди - ***if***. *Java*, як і *C* з *C++*, відноситься до мов з вільним форматом. Проте в командах управління рекомендується робити відступи, завдяки чому читачеві програми буде легше зрозуміти, де починається і закінчується управляюча конструкція.
 
## Цикли
 
### while
 
Конструкції ***while, do-while*** і ***for*** управляють циклами і іноді називаються циклічними командами. Команда повторюється до тих пір, поки контрольний логічний вираз не стане хибним. Формат циклу ***while*** наступний:
 
    while(логічний вираз) команда
 
логічний вираз обчислюється перед початком циклу, а потім кожен раз перед виконанням чергового повторення оператора. Наступний простий приклад генерує випадкові числа до тих пір, поки не буде виконано певну умову:
 
 
``` java
//: Control/WhileTest.java
// Демонстрація циклу while.
public class WhileTest {
    static boolean condition() {
        boolean result = Math.random() < 0.99;
        System.out.print(result + ",");
        return result;
    }
    public static void main(String[] args) {
        while(condition())
            System.out.println("Inside 'while'");
            System.out.println("Exited 'while'");
    }
} /*(Виконайте, щоб переглянути результат) *///: ~
```
 
 
У прикладі використовується статичний метод ***random()*** з бібліотеки ***Math***, який генерує значення ***double***, що знаходиться між *0* і *1* (включаючи *0*, але не *1*). Умова ***while*** означає: «повторювати, поки ***condition()*** повертає ***true***». При кожному запуску програми буде виводитись різна кількість чисел.
 
### do-while
 
Форма конструкції ***do-while*** така:
 
    do команда while(логічне вираз);
 
Єдина відмінність циклу ***do-while*** від ***while*** полягає в тому, що цикл ***do-while*** виконується принаймні один раз, навіть якщо умова спочатку помилкова. У циклі ***while***, якщо умова спочатку помилкова, тіло циклу ніколи не відпрацьовує. На практиці конструкція ***do-while*** вживається рідше, ніж ***while***.
 
### for
 
Мабуть, конструкції ***for*** складають найбільш поширений різновид циклів. Цикл ***for*** проводить ініціалізацію перед першим кроком циклу. Потім виконується перевірка умови циклу, і в кінці кожної ітерації здійснюється якесь «прирощення» (зазвичай зміна управляючої змінної). Цикл ***for*** записується в такий спосіб:
 
    for (ініціалізація; логічний вираз; крок)
        команда
 
Будь-який з трьох частин циклу (ініціалізація, логічний вираз, або крок) можна пропустити. Перед виконанням кожного кроку циклу перевіряється умова циклу; якщо воно виявиться помилковим, виконання триває з інструкції, наступної за конструкцією ***for***. В кінці кожної ітерації виконується секція крок. Цикл ***for*** зазвичай використовується для «розрахункових» завдань:
  
``` java
//: Control/ListCharacters.java
// Демонстрація циклу "for" для виведення
// всіх символів ASCII в нижньому регістрі.
public class ListCharacters {
    public static void main(String[] args) {
        for (char c = 0; c <128; c ++)
            if (Character.isLowerCase(c))
                System.out.println("value:" +(int) c +
                   "Character:" + c);
    }
} /* Результат:
value: 97 character: a
value: 98 character: b
value: 99 character: c
value: 100 character: d
value: 101 character: e
value: 102 character: f
value: 103 character: g
value: 104 character: h
value: 105 character: i
value: 106 character: j
...
Controlling Execution 95   *///: ~
```
 
Зверніть увагу, що змінна ***c*** визначається в точці її використання, в управляючому виразі циклу ***for***, а не на початку блоку, позначеного фігурними дужками. Область дії для ***c*** - всі вирази, що належать циклу. У програмі також використовується клас-«обгортка» ***java.Lang.Character***, який не тільки дозволяє представити найпростіший тип ***char*** у вигляді об'єкта, а й містить ряд додаткових можливостей. У нашому прикладі використовується статичний метод цього класу ***isLowerCase()***, який перевіряє, чи є деяка буква в нижньому регістрі. Традиційні процедурні мови(такі, як *C*) вимагали, щоб всі змінні визначалися на початку блоку циклу, щоб компілятор при створенні блоку міг виділити пам'ять під ці змінні. В *Java* і *C++* змінні дозволено оголошувати в тому місці блоку циклу, де це необхідно. Це дозволяє програмувати в більш зручному стилі і спрощує розуміння коду.
 
### Оператор-кома
 
Раніше в цьому розділі вже згадувалося про те, що оператор «кома» (але не кома-роздільник, яка розмежовує визначення і аргументи функцій) може використовуватися в *Java* тільки в управляючому виразі циклу ***for***. І в секції ініціалізації циклу, і в його управляючому виразі можна записати кілька команд, розділених комами; вони будуть оброблені послідовно. Оператор «кома» дозволяє визначити кілька змінних в циклі ***for***, але всі ці змінні повинні належати до одного типу:
 
 
``` java
//: Control/CommaOperator.java 
public class CommaOperator {
    public static void main(String[] args) {
        for (int i = 1, j = i + 10; i <5; i ++, j = i * 2) {
            System.out.println("i =" + i + "j =" + j);
        }
    }
} /* Результат:
i = 1 j = 11
i = 2 j = 4
i = 3 j = 6
i = 4 j = 8
*///: ~
```
 
Визначення ***int*** в заголовку ***for*** відноситься як до ***i***, так і до ***j***. Ініціалізаційна частина може містити будь-яку кількість визначень змінних одного типу. Визначення змінних в управляючих виразах можливо тільки в циклі ***for***. На інші команди вибору, або циклів цей підхід не поширюється.
 
## Синтаксис foreach
 
В *Java* *SE5* з'явилася нова, більш компактна форма ***for*** для перебору елементів масивів і контейнерів (див. далі). Ця спрощена форма, яка називається синтаксисом ***foreach***, не вимагає ручної зміни службової змінної для перебору послідовності об'єктів - цикл автоматично представляє черговий елемент. Наступна програма створює масив ***float***, після чого перебирає всі його елементи:
 
 
``` java
//: Control/ForEachFloat.java
import java.util. *;
 
public class ForEachFloat {
    public static void main(String[] args) {
        Random rand = new Random(47);
        float f[] = new float[10];
        for (int i = 0; i <10; i ++)
           f[i] = rand.nextFloat();
        for (float x: f)
            System.out.println(x);
    }
} /* Результат:
0.72711575
0.39982635
0.5309454
0.0534122
0.16020656
0.57799757
0.18847865
0.4170137
0.51660204
0.73734957
*///: ~
```
 
Масив заповнюється вже знайомим циклом ***for***, тому що для його заповнення повинні використовуватися індекси. Спрощений синтаксис використовується в наступній команді:
 
    for (float x: f)
 
Ця конструкція визначає змінну ***х*** типу ***float***, після чого послідовно присвоює їй елементи ***f***. Будь-який метод, який повертає масив, може використовуватися з даним різновидом ***for***. Наприклад, клас ***String*** містить метод ***toCharArray()***, який повертає масив ***char***; отже, перебір символів рядка може здійснюватися так:
 
``` java
//: Control/ForEachString.java
 
public class ForEachString {
    public static void main(String[] args) {
        for (char c: "An African Swallow".toCharArray())
           System.out.print(c + "");
    }
} /* Результат:
A n A frican S wallow
*///: ~
```
 
Як буде показано далі, «синтаксис ***foreach***» також працює для будь-якого об'єкта, що підтримує інтерфейс ***Iterable***. Багато команд ***for*** засновані на переборі серії цілочисельних значень:
 
``` java
for (int i = 0; i < 100; i++)
```
 
У таких випадках «синтаксис ***foreach***» працювати не буде, якщо тільки ви попередньо не створите масив ***int***. Для спрощення цього завдання я включив в бібліотеку ***net.mindview.util.Range*** метод ***range()***, який автоматично генерує відповідний масив:
 
``` java
//: Control/ForEachInt.java
import static net.mindview.util.Range. *;
import static net.mindview.util.Print. *;
 
public class ForEachInt {
    public static void main(String[] args) {
        for (int i: range(10)) // 0..9
            printnb(i + "");
        print();
        for (int i: range(5, 10)) // 5..9
            printnb(i + "");
        print();
        for (int i: range(5, 20, 3)) // 5..20 step 3
            printnb(i + "");
        print();
    }
} /* Результат:
0 1 2 3 4 5 6 7 8 9
5 6 7 8 9
5 8 11 14 17
*///: ~
```
 
Зверніть увагу на використання ***printnb()*** замість ***print()***. Метод ***printnb()*** не виводить символ нового рядка, що дозволяє побудувати рядок за фрагментами.
 
## return
 
Наступна група ключових слів забезпечує безумовний перехід, тобто передачу управління без перевірки будь-яких умов. До їх числа відносяться команди ***return, break*** і ***continue***, а також конструкція переходу по мітці, аналогічна ***goto*** в інших мовах. У ключового слова ***return*** є два призначення: воно вказує, яке значення повертається методом (якщо тільки він не повертає тип ***void***), а також використовується для негайного виходу з методу. Метод ***test()*** з попереднього прикладу можна переписати так, щоб він скористався новими можливостями:
 
 
``` java
//: Control / IfElse2.java
import static net.mindview.util.Print. *;
 
public class IfElse2 {
    static int test(int testval, int target) {
        if (testval> target)
           return +1;
        else if (testval <target)
            return -1;
        else
            return 0; // Match
    }
    public static void main(String[] args) {
        print(test(10, 5));
        print(test(5, 10));
        print(test(5, 5));
    }
} /* Результат:
1
-1
0
*///: ~
```
 
В даному випадку секція ***else*** не потрібна, оскільки робота методу не триває після виконання інструкції ***return***.
 
Якщо метод, який повертає ***void***, не містить команди ***return***, така команда неявно виконується в кінці методу. Проте, якщо метод повертає будь-який тип, крім ***void***, простежте за тим, щоб кожна логічна гілка повертала конкретне значення.
 
## break і continue
 
У тілі будь-якого з циклів ви можете управляти потоком програми, використовуючи спеціальні ключові слова ***break*** і ***continue***. Команда ***break*** завершує цикл, при цьому решта операторів циклу не виконуються. Команда ***continue*** зупиняє виконання поточної ітерації циклу і переходить до початку циклу, щоб почати виконання нового кроку. Наступна програма показує приклад використання команд ***break*** і ***continue*** всередині циклів ***for*** і ***while***:
 
 
``` java
//: Control / BreakAndContinue.java
// Demonstrates break and continue keywords.
import static net.mindview.util.Range. *;
 
public class BreakAndContinue {
    public static void main(String[] args) {
        for (int i = 0; i <100; i ++) {
            if (i == 74) break; // Out of for loop
            if (i%9 != 0) continue; // Next iteration
            System.out.print(i + "");
        }
        System.out.println();
        // Using foreach:
        for (int i: range(100)) {
            if (i == 74) break; // Out of for loop
            if (i%9 != 0) continue; // Next iteration
            System.out.print(i + "");
        }
        System.out.println();
        int i = 0;
        // An "infinite loop":
        while(true) {
            i++;
            int j = i * 27;
            if (j == 1269) break; // Out of loop
            if (i%10 != 0) continue; // Top of loop
            System.out.print(i + "");
        }
    }
} /* Результат:
0 9 18 27 36 45 54 63 72
0 9 18 27 36 45 54 63 72
10 20 30 40
*///: ~
```
 
У циклі ***for*** змінна ***i*** ніколи не досягає значення *100* - команда ***break*** перериває цикл, коли значення змінної стає рівним *74*. Зазвичай ***break*** використовується тільки тоді, коли ви точно знаєте, що умова виходу з циклу дійсно досягнута. Команда ***continue*** переводить виконання в початок циклу (і таким чином збільшує значення ***i***), коли ***i*** не ділиться без залишку на *9*. Якщо ділення відбувається без залишку, значення виводиться на екран.
 
Другий цикл ***for*** демонструє використання «синтаксису ***foreach***» з тим же результатом.
 
Остання частина програми демонструє «нескінченний цикл», який теоретично повинен виконуватися вічно. Однак в тілі циклу викликається команда ***break***, яка і завершує цикл. Команда ***continue*** переводить виконання до початку циклу, і при цьому залишок циклу не виконується. (Таким чином, вивід на екран в останньому циклі відбувається тільки в тому випадку, якщо значення ***i*** ділиться на *10* без залишку.) Значення *0* виводиться, так як ***0%9*** дає в результаті *0*.
 
Інша форма нескінченного циклу - ***for(;;)***. Компілятор реалізує конструкції ***while(true)*** і ***for(;;)*** однаково, так що вибір є справою смаку.
 
## Погана команда goto
 
Ключове слово ***goto*** з'явилося одночасно з мовами програмування. Дійсно, безумовний перехід заклав основи прийняття рішень в мові асемблера: «якщо умова А, перейти туди, а інакше перейти сюди». Якщо вам доводилося читати код на асемблері, який генерують фактично всі компілятори, напевно ви помічали численні переходи, які керують виконанням програми (компілятор *Java* виробляє свій власний «асемблерний» код, але останній виконується віртуальною-машиною *Java*, а не апаратним процесором ). Команда ***goto*** реалізує безумовний перехід на рівні початкового тексту програми, і саме ця обставина принесло їй погану славу. Якщо програма постійно «стрибає» з одного місця в інше, то чи немає способу реорганізувати її код так, щоб управління програмою перестало бути таким «стрибучий»? Команда ***goto*** впала в справжню немилість з опублікуванням знаменитої статті Едгара Дейкстри «Команда GOTO шкідлива» (*Goto considered harmful*), і тих пір осуд команди ***goto*** стало мало не спортом, а захисники репутації багатостраждального оператора розбіглися по затишних кутах. Як завжди в ситуаціях такого роду, існує «золота середина». Проблема полягає не у використанні ***goto*** взагалі, а в зловживанні - все ж іноді саме оператор ***goto*** дозволяє найкраще організувати управління програмою. Хоча слово ***goto*** зарезервовано в мові *Java*, воно там не використовується; *Java* не має команди ***goto***. Однак існує механізм, чимось схожий на безумовний перехід і здійснюваний командами ***break*** і ***continue***. Це більше спосіб перервати ітерацію циклу, а не передати управління в іншу точку програми. Причина його обговорення разом з ***goto*** полягає в тому, що він використовує той же механізм - мітки.
 
### Мітка
 
Мітка є ідентифікатор з подальшою двокрапкою:
 
    label1:
 
Єдине місце, де в *Java* мітка може виявитися корисною, - прямо перед тілом циклу. Причому ніяких додаткових команд між міткою і тілом циклу бути не повинно. Причина розміщення мітки перед тілом циклу може бути лише одна - вкладення всередині циклу іншого циклу, або конструкції вибору. Звичайні версії ***break*** і ***continue*** переривають тільки поточний цикл, в той час як їх версії з мітками здатні достроково завершувати цикли і передавати виконання в точку, що адресується міткою:
 
```
label1:
outer-iteration {
    inner-iteration {
        // ...
        break; //(1)
        // ...
        continue; //(2)
        // ...
        continue label1; //(3)
        // ...
        break label1; //(4)
    }
}
```
 
У першому випадку (1) команда ***break*** перериває виконання внутрішнього циклу, і управління переходить до зовнішнього циклу. У другому випадку (2) оператор ***continue*** передає управління до початку внутрішнього циклу. Але в третьому варіанті (3) команда ***continue label1*** викликає вихід з внутрішнього і зовнішнього циклів, і повернення до мітки ***label1***. Далі виконання циклу фактично триває, але з зовнішнього циклу. У четвертому випадку (4) команда ***break label1*** також викликає перехід до мітки ***label1***, але на цей раз повторний вхід в ітерацію не відбувається. Ця дія зупиняє виконання обох циклів. Приклад використання циклу ***for*** з мітками:
 
 
``` java
//: Control / LabeledFor.java
// For loops with "labeled break" and "labeled continue."
import static net.mindview.util.Print. *;

public class LabeledFor {
    public static void main(String[] args) {
        int i = 0;
        outer: // Can not have statements here
        for (; true;) {// infinite loop
            inner: // Can not have statements here
            for (; i <10; i ++) {
                print("i =" + i);
                if (i == 2) {
                    print("continue");
                    continue;
                }
                if (i == 3) {
                    print("break");
                    i ++; // Otherwise i never
                    // Gets incremented.
                    break;
                }
                if (i == 7) {
                    print("continue outer");
                    i ++; // Otherwise i never
                    // Gets incremented.
                    continue outer;
                }
                if (i == 8) {
                    print("break outer");
                    break outer;
                }
                for (int k = 0; k <5; k ++) {
                    if (k == 3) {
                        print("continue inner");
                        continue inner;
                    }
                }
            }
        }
        // Can not break or continue to labels here
    }
} /* Результат:
i = 0
continue inner
i = 1
continue inner
i = 2
continue
i = 3
break
i = 4
continue inner
i = 5
continue inner
i = 6
continue inner
i = 7
continue outer
i = 8
break outer
*///: ~
```
 
Зауважте, що оператор break завершує цикл ***for***, внаслідок цього вираз з інкрементом не виконується до завершення чергового кроку. Тому через пропуск операції інкремента в циклі змінна безпосередньо збільшується на одиницю, коли ***і == 3***. При виконанні умови ***і == 7*** команда ***continue outer*** переводить виконання на початок циклу; інкремент знову пропускається, тому і в цьому випадку змінна збільшується явно.
 
Без команди ***break outer*** програмі не вдалося б покинути зовнішній цикл з внутрішнього циклу, так як команда ***break*** сама по собі завершує виконання тільки поточного циклу (це справедливо і для ***continue***).
 
Звичайно, якщо завершення циклу також призводить до завершення роботи методу, можна просто застосувати команду ***return***.
 
Тепер розглянемо приклад, в якому використовуються команди ***break*** і ***continue*** з мітками в циклі ***while***:
 
 
``` java
//: Control / LabeledWhile.java
// While loops with "labeled break" and "labeled continue."
import static net.mindview.util.Print. *;

public class LabeledWhile {
    public static void main(String[] args) {
        int i = 0;
        outer:
        while(true) {
            print("Outer while loop");
            while(true) {
                i ++;
                print("i =" + i);
                if (i == 1) {
                    print("continue");
                    continue;
                }
                if (i == 3) {
                    print("continue outer");
                    continue outer;
                }
                if (i == 5) {
                    print("break");
                    break;
                }
                if (i == 7) {
                    print("break outer");
                    break outer;
                }
            }
        }
    }
} /* Результат:
Outer while loop
i = 1
continue
i = 2
i = 3
continue outer
Outer while loop
i = 4
i = 5
break
Outer while loop
Controlling Execution 103   i = 6
i = 7
break outer
*///: ~
```
 
Ті ж правила вірні і для циклу while:
 
-    Звичайна команда ***continue*** переводить виконання до початку поточного внутрішнього циклу, програма продовжує роботу.
-    Команда ***continue*** з міткою викликає перехід до мітці і повторний вхід в цикл, наступний прямо за цією позначкою.
-    Команда ***break*** завершує виконання поточного циклу.
-    Команда ***break*** з міткою завершує виконання внутрішнього циклу і циклу, який знаходиться після зазначеної мітки.
 
Важливо пам'ятати, що єдина причина для існування міток в *Java* - наявність вкладених циклів і необхідність виходу з ***break*** і продовження по ***continue*** не тільки для внутрішніх, але і для зовнішніх циклів.
 
У статті Дейкстри особливо критикуються мітки, а не сам оператор ***goto***. Дейкстра відзначає, що, як правило, кількість помилок в програмі зростає зі збільшенням кількості міток в цій програмі. Мітки ускладнюють аналіз програмного коду. Зауважте, що мітки *Java* не страждають цими вадами, бо їх місце розташування обмежене і вони не можуть використовуватися для безладної передачі управління. В даному випадку від обмеження можливостей функціональність мови тільки виграє.
 
## switch
 
Команду ***switch*** часто називають командою вибору. За допомогою конструкції ***switch*** здійснюється вибір з кількох альтернатив, в залежності від значення цілочисельного виразу. Форма команди виглядає так:
 
```
switch(целочисленное-вираз) {
    case ціле-значення1: команда; break;
    case ціле-значення2: команда; break;
    case ціле-значеніє3: команда; break;
    case ціле-значеніе4: команда; break;
    case ціле-значеніеб: команда; break;
    // ..
    default: оператор;
}
```
 
Цілочислений-вираз - вираз, в результаті обчислення якого отримуємо ціле число. Команда ***switch*** порівнює результат цілочисленного-виразу з кожним наступним цілим-значенням. Якщо буде виявлено збіг, виконається відповідна команда (проста, або складна). Якщо ж збіг не знайдено, виповнюється команда після ключового слова ***default***.
 
Неважко помітити, що кожна секція case закінчується командою ***break***, яка передає управління до кінця команди ***switch***. Такий синтаксис побудови конструкції ***switch*** вважається стандартним, але команда ***break*** не є строго обов'язковою.
 
Якщо вона відсутня, при виході з секції буде виконуватися код наступних секцій ***case***, поки в програмі не зустрінеться чергова команда ***break***. Необхідність в подібній поведінці виникає досить рідко, але досвідченому програмісту воно може стати в нагоді.
 
Зауважте, що остання секція ***default*** не містить команди ***break***; виконання триває в кінці конструкції ***switch***, тобто там, де воно виявилося б після виклику ***break***. Втім, ви можете використовувати ***break*** і в реченні ***default***, без практичної користі, просто заради «єдності стилю».
 
Команда ***switch*** забезпечує компактний синтаксис реалізації множинного вибору (тобто вибору з декількох шляхів виконання програми), але для неї потрібен контрольний вираз, результатом якого є цілочисельне значення, таке як ***int***, або ***char***. Якщо, наприклад, критерієм вибору є рядок, або дійсне число, то команда ***switch*** не підійде. Доведеться використовувати серію команд ***if-else***.
 
Наступний приклад випадковим чином генерує англійські букви. Програма визначає, голосні вони, чи приголосні:
 
``` java
//: Control/VowelsAndConsonants.java
// Демонстрація використання switch
import java.util. *;
import static net.mindview.util.Print. *;

public class VowelsAndConsonants {
    public static void main(String[] args) {
        Random rand = new Random(47);
        for (int i = 0; i <100; i ++) {
            int c = rand.nextInt(26) + 'a';
            printnb((char) c + "," + c + ":");
            switch(c) {
                case 'a':
                case 'e':
                case 'i':
                case 'o':
                case 'u': print("vowel");
                    break;
                case 'y':
                case 'w': print("Sometimes a vowel");
                    break;
                default: print("consonant");
            }
        }
    }
} /* Результат:
y, 121: Sometimes a vowel
n, 110: consonant
z, 122: consonant
b, 98: consonant
r, 114: consonant
n, 110: consonant
y, 121: Sometimes a vowel
g, 103: consonant
c, 99: consonant
f, 102: consonant
o, 111: vowel
w, 119: Sometimes a vowel
z, 122: consonant
...
*///: ~
```
 
Так як метод ***Random.nextInt(26)*** генерує значення між *0* і *26*, то для отримання символу нижнього регістра залишається додати зміщення ***'а'***. Символи одинарних лапок в секціях ***case*** також представляють собою цілочисельні значення, які використовуються для порівняння.
 
Зверніть увагу на «стопки» секцій ***case***, що забезпечують можливість множинного порівняння для однієї частини коду. Будьте напоготові і не забувайте додавати команду ***break*** після кожної секції ***case***, інакше програма просто перейде до виконання наступної секції ***case***. В команді
 
``` java
int c = rand.nextInt(26) + 'а'
```

метод ***rand.nextInt()*** видає випадкове число ***int*** від *0* до *25*, до якого потім додається значення ***'а'***. Це означає, що символ 'а' автоматично перетвориться до типу ***int*** для виконання додавання. Щоб вивести ***c*** в символьному вигляді, його необхідно перетворити до типу ***char***; в іншому випадку значення буде виведено в числовому вигляді.
 
## Резюме
 
В цьому розділі завершується опис основних конструкцій, присутніх майже у всіх мовах програмування: обчислень, пріоритету операторів, приведення типів, умовних конструкцій і циклів. Тепер можна зробити наступний крок на шляху до світу об'єктно-орієнтованого програмування. Наступна глава відповість на важливі питання про ініціалізації об'єктів і завершення їх життєвого циклу, після чого ми перейдемо до найважливішої концепції приховування реалізації.
 