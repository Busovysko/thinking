# Ініціалізація і очистка
 
В ході комп'ютерної революції з'ясувалося, що основною причиною надмірних витрат в програмуванні є «небезпечне» програмування. Основні проблеми з безпекою відносяться до ініціалізації і очистки. Дуже багато помилок при програмуванні на мові *C* обумовлені неправильною ініціалізацією змінних. Це особливо часто відбувається при роботі з бібліотеками, коли користувачі не знають, як потрібно форматувати компонент бібліотеки, або забувають це зробити. Очистка - дуже актуальна проблема; занадто легко забути про елемент, коли ви закінчили з ним роботу і його подальша доля вас не хвилює. У цьому випадку ресурси, які займає елементом, не звільняються, і в програмі може виникнути нестача ресурсів (перш за все пам'яті).
 
В *C++* з'явилося поняття конструктора - спеціального методу, який викликається при створенні нового об'єкта. Конструктори використовуються і в *Java*; до того ж в *Java* є збирач сміття, який автоматично звільняє ресурси, коли об'єкт перестає використовуватися. В цьому розділі розглядаються питання ініціалізації і очистки, а також їх підтримка в *Java*.
 
## Конструктор гарантує ініціалізацію
 
Звичайно, можна створити особливий метод, назвати його ***initialize()*** і включити в усі ваші класи. Ім'я методу підказує користувачеві, що він повинен викликати цей метод, перш ніж працювати з об'єктом. На жаль, це означає, що користувач повинен постійно пам'ятати про необхідність виклику даного методу. В *Java* розробник класу може в обов'язковому порядку виконати ініціалізацію кожного об'єкта за допомогою спеціального методу, званого конструктором. Якщо у класу є конструктор, *Java* автоматично викликає його при створенні об'єкта, перед тим як користувачі зможуть звернутися до цього об'єкта. Таким чином, ініціалізація об'єкта гарантована.
 
Як повинен називатися конструктор? Тут є дві тонкощі. По-перше, будь-яке ім'я, яке ви використовуєте, може бути задіяно при визначенні членів класу; так виникає потенційний конфлікт імен. По-друге, за виклик конструктора відповідає компілятор, тому він завжди повинен знати, який саме метод слід викликати. Реалізація конструктора в *C++* здається найбільш простим і логічним рішенням, тому воно використано і в *Java*: ім'я конструктора збігається з ім'ям класу. Сенс такого рішення очевидний - саме такий метод здатний автоматично викликатися при ініціалізації. Розглянемо визначення простого класу з конструктором:
 
``` java
//: Initialization/SimpleConstructor.java
// Demonstration of a simple constructor.

class Rock {
    Rock() {// This is the constructor
        System.out.print("Rock");
    }
}

public class SimpleConstructor {
    public static void main(String [] args) {
        for(int i = 0; i <10; i ++)
            new Rock(); }
}/* Результат:
Rock Rock Rock Rock Rock Rock Rock Rock Rock Rock
*///: ~
```
 
Тепер при створенні об'єкта:
 
``` java
new Rock();
```
 
виділяється пам'ять і викликається конструктор. Тим самим гарантується, що об'єкт буде ініціалізований, перш ніж програма зможе працювати з ним.
 
Зауважте, що стиль програмування, при якому імена методів починаються з малої літери, до конструкторів не відноситься, оскільки ім'я конструктора має точно збігатися з ім'ям класу. Подібно будь-якому методу, у конструктора можуть бути аргументи, для того щоб дозволити вам вказати, як створити об'єкт. Попередній приклад легко змінити так,
щоб конструктору при виклику передавався аргумент:
 
``` java
//: Initialization/SimpleConstructor2.java
// Constructors can have arguments.

class Rock2 {
    Rock2(int i) {
        System.out.print("Rock" + i + "");
    }
}

public class SimpleConstructor2 {
    public static void main(String [] args) {
        for(int i = 0; i <8; i ++)
            new Rock2(i);
    }
}/* Результат:
Rock 0 Rock 1 Rock 2 Rock 3 Rock 4 Rock 5 Rock 6 Rock 7
*///: ~
```
 
В аргументах конструктору передаються параметри для ініціалізації об'єкта. Наприклад, якщо у класу ***Tree***(дерево) є конструктор, який отримує в якості аргументу ціле число, що позначає висоту дерева, то об'єкти ***Tree*** будуть створюватися таким чином:
 
``` java
Tree t = new Тrее(12); // 12-метрове дерево
```
 
Якщо ***Tree(int initialHeight)*** є єдиним конструктором класу, то компілятор не дозволить створювати об'єкти ***Tree*** будь-яким іншим способом. Конструктори усувають великий пласт проблем і спрощують читання коду. У попередньому фрагменті коду невідомі явні виклики методу, подібного ***initialize()***, який концептуально відділений від створення. В *Java* створення і ініціалізація є нероздільними поняттями - одне без іншого неможливо.
 
Конструктор - не зовсім звичайний метод, так як у нього відсутне повертанна значення. Це відчутно відрізняється навіть від випадку з поверненням значення ***void***, коли метод нічого не повертає, але при цьому все ж можна змусити його повернути що-небудь інше. Конструктори не повертають ніколи і нічого (оператор ***new*** повертає посилання на новостворений об'єкт, але самі конструктори не мають вихідного значення). Якби у них існувало повертаєме значення і його можна було б вибирати, то компілятор довелося б якось пояснювати, що ж робити з цим значенням.
 
## Перевантаження методів
 
Одним з найважливіших аспектів будь-якої мови програмування є використання імен. Створюючи об'єкт, ви фактично привласнюєте ім'я області пам'яті. Метод - ім'я для дії. Використання імен при описі системи спрощує її розуміння і модифікацію. Робота програміста схожа на роботу письменника; в обох випадках завдання полягає в тому, щоб донести свою думку до читача.
 
Проблеми виникають при перенесенні нюансів людського мови в мови програмування. Часто одне і те ж слово має кілька різних значень - воно перевантажено. Це корисно, особливо щодо простих відмінностей. Ви говорите «вимити посуд», «вимити машину» і «вимити собаку». Було б нерозумно натомість говорити «посудомоєч посуд», «МашіноМить машину» і «собакоМить собаку» тільки для того, щоб слухач не обтяжував себе виявленням різниці між цими діями.
Більшість людських мов несе надмірність, і навіть при пропуску деяких слів визначити сенс не так складно. Унікальні імена не обов'язкові - сказане можна зрозуміти з контексту.
 
Більшість мов програмування (і особливо *C*) вимагали використання унікальних імен для всіх функцій. Інакше кажучи, програма не могла містити функцію ***print()*** для роздруківки цілих чисел і однойменну функцію для виведення дійсних чисел - кожна функція повинна була мати унікальне ім'я.
 
В *Java* (і в *C++*) також існує інший фактор, який змушує використовувати перевантаження імен методів: наявність конструкторів. Так як ім'я конструктора зумовлено ім'ям класу, воно може бути тільки єдиним. Але що, якщо ви захочете створювати об'єкти різними способами? Припустимо, ви створюєте клас з двома варіантами ініціалізації: або стандартно, або на підставі деякого файлу. У цьому випадку необхідність двох конструкторів очевидна: один з них не має аргументів (конструктор за замовчуванням, також званий конструктором без аргументів (*no-arg*)), а інший отримує в якості аргументу рядок з ім'ям файлу. Обидва вони є повноцінними конструкторами, і тому повинні називатися однаково - ім'ям класу.
 
Тут перевантаження методів (*overloading*) однозначно необхідне, щоб ми могли використовувати методи з однаковими іменами, але з різними аргументами. І хоча перевантаження методів обов'язкове тільки для конструкторів, вона зручне в принципі і може бути застосоване до будь-якого методу. Наступна програма показує приклад перевантаження як конструктора, так і звичайного методу:
 
``` java
//: Initialization/Overloading.java
// Демонстрація двох конструкторів
// і перевантаження звичайних методів.
import static net.mindview.util.Print. *;

class Tree {
    int height;
    Tree() {
        print("Planting a seedling");
        height = 0;
    }
    Tree(int initialHeight) {
        height = initialHeight;
        print("Creating new Tree that is" +
                height + "feet tall");
        Initialization & Cleanup 109   }
    void info() {
        print("Tree is" + height + "feet tall");
    }
    void info(String s) {
        print(s + ": Tree is" + height + "feet tall");
    }
}

public class Overloading {
    public static void main(String [] args) {
        for(int i = 0; i <5; i ++) {
            Tree t = new Tree(i);
            t.info();
            t.info("overloaded method");
        }
// Overloaded constructor:
        new Tree();
    }
}/* Результат:
Creating new Tree that is 0 feet tall
Tree is 0 feet tall
overloaded method: Tree is 0 feet tall
Creating new Tree that is 1 feet tall
Tree is 1 feet tall
overloaded method: Tree is 1 feet tall
Creating new Tree that is 2 feet tall
Tree is 2 feet tall
overloaded method: Tree is 2 feet tall
Creating new Tree that is 3 feet tall
Tree is 3 feet tall
overloaded method: Tree is 3 feet tall
Creating new Tree that is 4 feet tall
Tree is 4 feet tall
overloaded method: Tree is 4 feet tall
Planting a seedling
*///: ~
```
 
Об'єкт ***Tree*** (дерево) може бути створений, або в формі паростка(без аргументів), або у вигляді «дорослої рослини» з деякою висотою. Для цього в класі визначаються два конструктора; один використовується за замовчанням, а інший отримує аргумент з висотою дерева. Можливо, ви захочете викликати метод ***info()*** декількома способами. Наприклад, виклик з аргументом-рядком ***info(String)*** використовується при необхідності виведення додаткової інформації, а виклик без аргументів ***info()*** - коли доповнень до повідомлення методу не потрібно. Було б дивно давати два різних імена методам, коли їх схожість настільки очевидна. На щастя, перевантаження методів дозволяє використовувати одне і те ж ім'я для обох методів.
 
## Розрізнення перевантажених методів
 
Якщо у методів однакові імена, як *Java* дізнається, який саме з них викликаний? Відповідь проста: кожен перевантажений метод повинен мати унікальний список типів аргументів.
 
Якщо трохи подумати, такий підхід виявляється цілком логічним. Як ще розрізнити два однойменних методи, якщо не по типу аргументів?
 
Навіть різного порядку аргументів достатньо для того, щоб методи вважалися різними (хоча описаний далі підхід майже не використовується, так як він ускладнює супровід програмного коду):
 
``` java
//: Initialization/OverloadingOrder.java
// Overloading based on the order of the arguments.
import static net.mindview.util.Print. *;

public class OverloadingOrder {
    static void f(String s, int i) {
        print("String:" + s + ", int:" + i);
    }
    static void f(int i, String s) {
        print("int:" + i + ", String:" + s);
    }
    public static void main(String [] args) {
        f("String first", 11);
        f(99, "Int first");
    }
}/* Результат:
String: String first, int: 11
int: 99, String: Int first
*///: ~
```
 
Два методи ***f()*** мають однакові аргументи з різним порядком проходження, і ця різниця дозволяє ідентифікувати метод.
 
## Перевантаження з примітивами
 
Найпростіший тип може бути автоматично наведено від меншого типу до більшого, і це в змозі внести чималу плутанину в перевантаження.
Наступний приклад показує, що відбувається при передачі примітивного типу перевантаженому методу:
 
``` java
//: Initialization/PrimitiveOverloading.java
// Promotion of primitives and overloading.
// Підвищення примітивних типів і перевантаження
import static net.mindview.util.Print. *;

public class PrimitiveOverloading {
    void f1(char x) {printnb("f1(char)"); }
    void f1(byte x) {printnb("f1(byte)"); }
    void f1(short x) {printnb("f1(short)"); }
    void f1(int x) {printnb("f1(int)"); }
    void f1(long x) {printnb("f1(long)"); }
    void f1(float x) {printnb("f1(float)"); }
    void f1(double x) {printnb("f1(double)"); }

    void f2(byte x) {printnb("f2(byte)"); }
    void f2(short x) {printnb("f2(short)"); }
    void f2(int x) {printnb("f2(int)"); }
    void f2(long x) {printnb("f2(long)"); }
    void f2(float x) {printnb("f2(float)"); }
    void f2(double x) {printnb("f2(double)"); }

    void f3(short x) {printnb("f3(short)"); }
    void f3(int x) {printnb("f3(int)"); }
    void f3(long x) {printnb("f3(long)"); }
    void f3(float x) {printnb("f3(float)"); }
    void f3(double x) {printnb("f3(double)"); }

    void f4(int x) {printnb("f4(int)"); }
    void f4(long x) {printnb("f4(long)"); }
    void f4(float x) {printnb("f4(float)"); }
    void f4(double x) {printnb("f4(double)"); }

    void f5(long x) {printnb("f5(long)"); }
    void f5(float x) {printnb("f5(float)"); }
    void f5(double x) {printnb("f5(double)"); }

    void f6(float x) {printnb("f6(float)"); }
    void f6(double x) {printnb("f6(double)"); }

    void f7(double x) {printnb("f7(double)"); }

    void testConstVal() {
        printnb("5:");
        f1(5); f2(5); f3(5); f4(5); f5(5); f6(5); f7(5); print();
    }
    void testChar() {
        char x = 'x';
        printnb("char:");
        f1(x); f2(x); f3(x); f4(x); f5(x); f6(x); f7(x); print();
    }
    void testByte() {
        byte x = 0;
        printnb("byte:");
        f1(x); f2(x); f3(x); f4(x); f5(x); f6(x); f7(x); print();
    }
    void testShort() {
        short x = 0;
        printnb("short:");
        f1(x); f2(x); f3(x); f4(x); f5(x); f6(x); f7(x); print();
    }
    void testInt() {
        int x = 0;
        printnb("int:");
        f1(x); f2(x); f3(x); f4(x); f5(x); f6(x); f7(x); print();
    }
    void testLong() {
        long x = 0;
        printnb("long:");
        f1(x); f2(x); f3(x); f4(x); f5(x); f6(x); f7(x); print();
    }
    void testFloat() {
        float x = 0;
        printnb("float:");
        f1(x); f2(x); f3(x); f4(x); f5(x); f6(x); f7(x); print();
    }
    void testDouble() {
        double x = 0;
        printnb("double:");
        f1(x); f2(x); f3(x); f4(x); f5(x); f6(x); f7(x); print();
    }
    public static void main(String [] args) {
        PrimitiveOverloading p =
                new PrimitiveOverloading();
        p.testConstVal();
        p.testChar();
        p.testByte();
        p.testShort();
        p.testInt();
        p.testLong();
        p.testFloat();
        p.testDouble();
    }
}/* Результат:
5: f1(int) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double)
char: f1(char) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double)
byte: f1(byte) f2(byte) f3(short) f4(int) f5(long) f6(float) f7(double)
f1(short) f2(short) f3(short) f4(int) f5(long) f6(float)
f7(double)
int: f1(int) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double)
long: f1(long) f2(long) f3(long) f4(long) f5(long) f6(float) f7(double)
float: f1(float) f2(float) f3(float) f4(float) f5(float) f6(float)
f7(double)
double: f1(double) f2(double) f3(double) f4(double) f5(double)
f6(double) f7(double)
*///: ~
```
 
Якщо ви розглянете результат роботи програми, то побачите, що константа *5* трактується як ***int***, тому якщо є перевантажений метод, який приймає аргумент типу ***int***, то він і використовується. У всіх інших випадках, якщо є тип даних, «менший», ніж потрібно для існуючого методу, то цей тип даних підвищується відповідним чином. Тільки тип ***char*** поводиться трохи інакше з тієї причини, що, якщо методу з параметром ***char*** немає, цей тип приводиться відразу до типу ***int***, а не до проміжних типів ***byte*** або ***short***.
 
Що ж станеться, якщо ваш аргумент «більший», ніж аргумент, що очікується в перевантаженому методі? Відповідь можна знайти в модифікації розглянутої програми:
 
``` java
//: Initialization/Demotion.java
// Demotion of primitives and overloading.
// Зниження примітивів і перевантаження.
import static net.mindview.util.Print. *;

public class Demotion {
    void f1(char x) {print("f1(char)"); }
    void f1(byte x) {print("f1(byte)"); }
    void f1(short x) {print("f1(short)"); }
    void f1(int x) {print("f1(int)"); }
    void f1(long x) {print("f1(long)"); }
    void f1(float x) {print("f1(float)"); }
    void f1(double x) {print("f1(double)"); }

    void f2(char x) {print("f2(char)"); }
    void f2(byte x) {print("f2(byte)"); }
    void f2(short x) {print("f2(short)"); }
    void f2(int x) {print("f2(int)"); }
    void f2(long x) {print("f2(long)"); }
    void f2(float x) {print("f2(float)"); }

    void f3(char x) {print("f3(char)"); }
    void f3(byte x) {print("f3(byte)"); }
    void f3(short x) {print("f3(short)"); }
    void f3(int x) {print("f3(int)"); }
    void f3(long x) {print("f3(long)"); }

    void f4(char x) {print("f4(char)"); }
    void f4(byte x) {print("f4(byte)"); }
    void f4(short x) {print("f4(short)"); }
    void f4(int x) {print("f4(int)"); }

    void f5(char x) {print("f5(char)"); }
    void f5(byte x) {print("f5(byte)"); }
    void f5(short x) {print("f5(short)"); }

    void f6(char x) {print("f6(char)"); }
    void f6(byte x) {print("f6(byte)"); }

    void f7(char x) {print("f7(char)"); }

    void testDouble() {
        double x = 0;
        print("double argument:");
        f1(x); f2((float) x); f3((long) x); f4((int) x);
        f5((short) x); f6((byte) x); f7((char) x);
    }
    public static void main(String [] args) {
        Demotion p = new Demotion();
        p.testDouble();
    }
}/* Результат:
double argument:
f1(double)
f2(float)
f3(long)
f4(int)
f5(short)
f6(byte)
f7(char)
*///: ~
```
 
Тут методи вимагають звуження типів даних. Якщо ваш аргумент «ширший», необхідно явно привести його до потрібного типу. В іншому випадку компілятор виведе повідомлення про помилку.
 
## Перевантаження по повертаємих значеннях
 
Цілком логічно запитати, чому при перевантаженні використовуються тільки імена класів і списки аргументів? Чому не ідентифікувати методи по значеннях які вони повертають? Наступні два методи мають однакові імена і аргументи, але їх легко відрізнити один від одного:
 
``` java
void f() {}
int f() {}
```
 
Такий підхід чудово спрацює в ситуації, в якій компілятор може однозначно вибрати потрібну версію методу, наприклад: ***int х = f()***.
Однак значення, що повертається при виклику методу може бути проігноровано; це часто називається викликом методу для отримання побічного ефекту, так як метод викликається не для отримання результату, а для якихось інших цілей. Припустимо, метод викликається наступним способом:
 
``` java
f();
```
 
Як тут *Java* визначити, яка з версій методу ***f()*** повинна виконуватися? І чи зрозуміє читач програми, що відбувається при цьому виклику? Саме через такі проблеми перевантажені методи не дозволяється розрізняти по повертаємих значеннях.
 
# Конструктори за замовчуванням
 
Як згадувалося раніше, конструктором за замовчуванням називається конструктор без аргументів, застосовуваний для створення «типового» об'єкта. Якщо створений вами клас не має конструктора, компілятор автоматично додасть конструктор за замовчуванням. наприклад:
 
``` java
//: Initialization/DefaultConstructor.java
class Bird {}

public class DefaultConstructor {
    public static void main(String [] args) {
        Bird b = new Bird(); // Default!
    }
}
```
 
створює новий об'єкт і викликає конструктор за замовчуванням, хоча останній і не був явно визначений в класі. Без нього не існувало б методу для побудови об'єкта класу в даному прикладі. Але якщо ви вже визначили деякий конструктор (або кілька конструкторів, з аргументами, чи без), компілятор буде генерувати конструктор за замовчуванням:
 
``` java
//: Initialization/NoSynthesis.java
class Bird2 {
    Bird2(int i) {}
    Bird2(double d) {}
}

public class NoSynthesis {
    public static void main(String [] args) {
//! Bird2 b = new Bird2(); // No default
        Bird2 b2 = new Bird2(1);
        Bird2 b3 = new Bird2(1.0);
    }
}
```
 
Тепер при спробі виконання ***new Bird2()*** компілятор заявить, що не може знайти конструктор, підходящий за описом. Виходить так: якщо визначення конструкторів відсутні, компілятор скаже: «Хоча б один конструктор необхідний, дозвольте створити його за вас». Якщо ж ви записуєте конструктор явно, компілятор каже: «Ви написали конструктор, а отже, знаєте, що вам потрібно; і якщо ви не створили конструктор за замовчуванням, значить, він вам і не потрібен».
 
## Ключове слово this
 
Якщо у вас є два об'єкти однакового типу з іменами ***a*** і ***b***, ви, можливо, зацікавитесь, яким чином здійснюється виклик методу ***peel()*** для обох об'єктів:
 
``` java
//: Initialization/BananaPeel.java
class Banana {void peel(int i) {/* ... */}}

public class BananaPeel {
    public static void main(String [] args) {
        Banana a = new Banana(),
                b = new Banana();
        peel(1);
        peel(2);
    }
}
```
 
Якщо існує тільки один метод з ім'ям ***peel()***, як цей метод дізнається, для якого об'єкта він викликається - ***a***, або ***b***?
 
Щоб програма могла записуватися в об'єктно-орієнтованому стилі, заснованому на «відправці повідомлень об'єктам», компілятор виконує для вас деяку таємну роботу. При виклику методу ***peel()*** передається прихований перший аргумент - не що інше, як посилання на використовуваний об'єкт. Таким чином, виклики зазначеного методу насправді можна уявити як:
 
``` java
Banana.рееl(a, 1);
Banana.peel(b, 2);
```
 
Передача додаткового аргументу відноситься до внутрішнього синтаксису. При спробі явно скористатися нею компілятор видасть повідомлення про помилку, але ви приблизно будете уявляти суть того, що відбувається.
 
Припустимо, під час виконання методу ви хотіли б отримати посилання на поточний об'єкт. Так як це посилання передасться компілятором таємно, ідентифікатора для нього не існує. Але для вирішення цього завдання існує ключове слово - ***this***. Ключове слово ***this*** може використовуватися тільки всередині не-статичного методу і надає посилання на об'єкт, для якого був викликаний метод. Поводитися з ним можна точно так само, як і з будь-яким іншим посиланням на об'єкт. Пам'ятайте, що при виклику методу вашого класу з іншого методу цього класу ***this*** Вам не потрібно; просто вкажіть ім'я методу. Поточне посилання ***this*** буде автоматично використане в іншому методі. Таким чином, продовжуючи сказане:
 
``` java
//: Initialization/Apricot.java
public class Apricot {
    void pick() {/* ... */}
    void pit() {pick();/* ... */}
}
```
 
Усередині методу ***pit()*** можна використовувати запис ***this.pick()***, але в цьому немає необхідності. Компілятор зробить це автоматично. Ключове слово ***this*** вживається тільки в особливих випадках, коли вам необхідно явно послатися на поточний об'єкт. Наприклад, воно часто застосовується для повернення посилання на поточний об'єкт в команді ***return***:
 
``` java
//: Initialization/Leaf.java
// Simple use of the "this" keyword.

public class Leaf {
    int i = 0;
    Leaf increment() {
        i ++;
        return this;
    }
    void print() {
        System.out.println("i =" + i);
    }
    public static void main(String [] args) {
        Leaf x = new Leaf();
        x.increment(). increment(). increment(). print();
    }
}/* Результат:
i = 3
*///: ~
```
 
Так як метод ***increment()*** повертає посилання на поточний об'єкт за допомогою ключового слова ***this***, над одним і тим же об'єктом легко можна провести безліч операцій. Ключове слово ***this*** також може стати в нагоді для передачі поточного об'єкта іншому методу:
 
``` java
//: Initialization/PassingThis.java

class Person {
    public void eat(Apple apple) {
        Apple peeled = apple.getPeeled();
        System.out.println("Yummy");
    }
}

class Peeler {
    static Apple peel(Apple apple) {
// ... Remove peel
        return apple; // Peeled
    }
}

class Apple {
    Apple getPeeled() {return Peeler.peel(this); }
}

public class PassingThis {
    public static void main(String [] args) {
        new Person(). eat(new Apple());
    }
}/* Результат:
Yummy
*///: ~
```
 
Клас ***Apple*** викликає ***Peeler.peel()*** - допоміжний метод, який з якоїсь причини повинен бути оформлений як зовнішній по відношенню до ***Apple*** (може, він повинен обслуговувати кілька різних класів, і ви хочете уникнути дублювання коду). Для передачі поточного об'єкта зовнішньому методу використовується ключове слово ***this***.
 
## Виклик конструкторів з конструкторів
 
Якщо ви пишете для класу кілька конструкторів, іноді буває зручно викликати один конструктор з іншого, щоб уникнути дублювання коду. Така операція проводиться з використанням ключового слова ***this***. Зазвичай при вживанні ***this*** мається на увазі «цей об'єкт» або «поточний об'єкт», і саме слово є посиланням на поточний об'єкт. У конструкторі ключове слово ***this*** має інший зміст: при використанні його зі списком аргументів викликається конструктор, який відповідає цьому списку. Таким чином, з'являється можливість прямого виклику інших конструкторів:
 
``` java
//: Initialization/Flower.java
// Calling constructors with "this"
import static net.mindview.util.Print. *;

public class Flower {
    int petalCount = 0;
    String s = "initial value";
    Flower(int petals) {
        petalCount = petals;
        print("Constructor w/int arg only, petalCount ="
                + PetalCount);
    }
    Flower(String ss) {
        print("Constructor w/String arg only, s =" + ss);
        s = ss;
    }
    Flower(String s, int petals) {
        this(petals);
//! this(s); // Can not call two!
        this.s = s; // Another use of "this"
        print("String & int args");
    }
    Flower() {
        this("hi", 47);
        print("default constructor(no args)");
    }
    void printPetalCount() {
//! this(11); // Not inside non-constructor!
        print("petalCount =" + petalCount + "s =" + s);
    }
    public static void main(String [] args) {
        Flower x = new Flower();
        x.printPetalCount();
    }
}/* Результат:
Constructor w/int arg only, petalCount = 47
String & int args
default constructor(no args)
petalCount = 47 s = hi
*///: ~
```
 
Конструктор ***Flower(String s, int petals)*** показує, що при виклику одного конструктора через ***this*** викликати інший забороняється. До того ж виклик іншого конструктора повинен бути першою виконуваною операцією, інакше компілятор видасть повідомлення про помилку.
 
Приклад демонструє ще один спосіб використання ***this***. Так як імена аргументу ***s*** та поля даних класу ***s*** збігаються, виникає неоднозначність. Вирішити це складне становище можна за допомогою конструкції ***this.s***, що однозначно визначає поле даних класу. Ви ще не раз зустрінете такий підхід в різних *Java*-програмах, та й в цій книзі він практикується досить часто.
 
Метод ***printPetalCount()*** показує, що компілятор не дозволяє викликати конструктор зі звичайного методу; це дозволено тільки в конструкторах.
 
## Значення ключового слова static
 
Ключове слово ***this*** допоможе краще зрозуміти, що ж фактично означає оголошення статичного(***static***) методу. У таких методів не існує посилання ***this***. Ви не в змозі викликати нестатичні методи з статичних (хоча зворотне дозволено), і статичні методи можна викликати для імені класу, без будь-яких об'єктів. Статичні методи частково нагадують глобальні функції мови *C*, але з деякими винятками: глобальні функції не дозволені в *Java*, і створення статичного методу всередині класу дає йому право на доступ до інших статичних методів і полей.
 
Деякі люди стверджують, що статичні методи маючи семантику глобальної функції суперечать об'єктно-орієнтованій парадигмі; в разі використання статичного методу ви не посилаєте повідомлення об'єкту, оскільки відсутнє посилання ***this***. Можливо, що це справедливий докір, і якщо ви виявите, що використовуєте занадто багато статичних методів, то варто переглянути вашу стратегію розробки програм. Однак ключове слово ***static*** корисне на практиці, і в деяких ситуаціях воно безумовно необхідне. Суперечки ж про «чистоту ООП»
краще залишити теоретикам.
 
# Очищення: фіналізація та збирання сміття
 
Програмісти пам'ятають і знають про важливість ініціалізації, але часто забувають про важливість «прибирання». Та й навіщо, наприклад, «прибирати» після використання звичайної змінної ***int***? Але при використанні програмних бібліотек «просто забути» про об'єкт після закінчення його використання не завжди безпечно. Звичайно, в *Java* існує збирач сміття, який звільняє пам'ять від непотрібних об'єктів. Але уявімо собі незвичайну ситуацію. Припустимо, що об'єкт виділяє «спеціальну» пам'ять без використання оператора ***new***. Збирач сміття вміє звільняти пам'ять, виділену ***new***, але йому невідомо, як слід очищати специфічну пам'ять об'єкта.
 
Для таких ситуацій в *Java* передбачений метод ***finalize()***, який ви можете визначати в вашому класі. Ось як він повинен працювати: коли збирач сміття готовий звільнити пам'ять, використану вашим об'єктом, він для початку викликає метод ***finalize()***. А тільки після цього звільняє займану об'єктом пам'ять. Таким чином, метод
***finalize()*** дозволяє виконувати завершальні дії під час роботи збирача сміття.
 
Все це може створити чимало проблем для програмістів, особливо для програмістів на мові *C++*, так як вони можуть сплутати метод ***finalize()*** з деструкцією мови *C++* - функцією, яка завжди викликається перед руйнуванням об'єкту. Але тут дуже важливо зрозуміти різницю між *Java* і *C++*, оскільки в *C++* об'єкти руйнуються завжди (в правильно написаної програмі), в той час як в *Java* об'єкти видаляються збирачем сміття не у всіх випадках. Іншими словами:
 
**УВАГА**
<span style="color:#800000">**1. Ваші об'єкти можуть бути і не передані збирачеві сміття.**</span>
<span style="color:#800000">**2. Прибирання сміття не є видаленням.**</span>
 
Якщо програма завершує свою роботу і збирач сміття не вилучив жодного об'єкта і не звільнив займану пам'ять, то ця пам'ять буде повернута операційній системі після очистки роботи програми. Це добре, тому що збірка сміття супроводжується вагомими витратами, і якщо збирач не використовується, то, відповідно, ці витрати не виявляються.
 
## Для чого потрібен метод finalize()?
 
Отже, якщо метод ***finalize()*** не варто використовувати для проведення стандартних операцій очистки, то для чого ж він потрібен? Запам'ятайте третє правило:
 
**УВАГА**
<span style="color:#800000">** Процес збирання сміття відноситься тільки до пам'яті.**</span>
 
Єдина причина існування збирача сміття - звільнення пам'яті, яка перестала використовуватися вашою програмою. Тому всі дії, так чи інакше пов'язані зі збором сміття, особливо ті, що записані в методі ***finalize()***, повинні встановлюватися до управління і звільнення пам'яті.

Але чи означає це, що якщо ваш об'єкт містить інші об'єкти, то в ***finalize()*** вони повинні явно видалятися? Ні - збирач сміття займеться звільненням пам'яті і видаленням об'єктів незалежно від способу їх створення. Виходить, що використання методу ***finalize()*** обмежено особливими випадками, в яких ваш об'єкт розміщується в пам'яті незвичайним способом, не пов'язаним з прямим створенням екземпляра. Але, якщо в *Java* все є об'єктом, як же тоді такі особливі випадки відбуваються?
 
Схоже, що підтримка методу ***finalize()*** була введена в мову, щоб зробити можливими операції з пам'яттю в стилі *C*, із залученням нестандартних механізмів виділення пам'яті. Це може статися в основному при використанні методів, що надають спосіб виклику нe-*Java* коду з програми на *Java*. *C* і *C++* поки є єдиними підтримуваними мовами, але, так як для них таких обмежень немає, насправді програма *Java* може викликати будь-яку процедуру, або функцію на будь-якій мові. У зовнішньому коді можна виділити пам'ять викликом функцій *C*, що відносяться до сімейства *malloc()*. Якщо не скористатися потім функцією *free()*, відбудеться «витік» пам'яті. Звичайно, функція *free()* теж належить до *C* і *C++*, тому доведеться в методі ***finalize()*** провести виклик ще одного «зовнішнього» методу.
 
Після прочитання цього абзацу у вас, швидше за все, склалася думка, що метод ***finalize()*** використовується нечасто. І справді, це не те місце, де слід проводити рутинні операції очищення. Але де ж тоді ці звичайні операції будуть доречні?

## Очищення це ваша турбота

Для очищення об'єкту його користувачеві потрібно викликати відповідний метод в тій точці, де ці завершальні дії по відкріплення і повинні здійснюватися. Звучить просто, але трохи суперечить традиційним уявленням про деструктори *C++*. У цій мові всі об'єкти повинні знищуватися. Якщо об'єкт *C++* створюється локально (тобто в стеці, що неможливо в *Java*), то видалення і виклик деструктора відбувається при закритті фігурної дужки, що обмежує область дії такого об'єкта. Якщо ж об'єкт створюється оператором *new* (як в *Java*), то деструктор викликається при виконанні програмістом оператора *C++* *delete* (не має аналога в *Java*). А коли програміст на *C++* забуває викликати оператор *delete*, деструктор не викликається і відбувається «витік» пам'яті, до того ж інші частини об'єкта не проходять необхідного очищення. Такого роду помилки дуже складно знайти і знищити, але вони також є вагомим аргументом на користь переходу з *C++* на *Java*. *Java* не дозволяє створювати локальні об'єкти - всі об'єкти повинні бути результатом дії оператора *new*. Але в *Java* відсутній аналог оператора *delete*, що викликається для руйнування об'єкта, так як збирач сміття і без того виконає звільнення пам'яті. Значить, в дещо спрощеному викладі можна стверджувати, що деструкція в *Java* відсутня через присутність збирача сміття. Але в процесі читання книги ви ще не раз переконайтеся, що наявність збирача сміття не усуває необхідності в деструкції, або в аналогії. (І ніколи не варто викликати метод ***finalize()*** безпосередньо, так як цей підхід не вирішує проблему.) Якщо ж буде потрібно провести якісь завершальні дії, відмінні від звільнення пам'яті, все ж доведеться явно викликати відповідний метод, що виконає функцію деструктора *C++*, але це вже не так зручно, як вбудований деструктор. Пам'ятайте, що ні прибирання сміття, ні фіналізація не гарантовані. Якщо віртуальна машина *Java*(*Java Virtual Machine, JVM*) далека від критичної точки витрачання ресурсів, вона не стане витрачати час на вивільнення пам'яті з використанням збірки сміття.
 
## Умова «готовності»
 
Загалом, ви не повинні покладатися на виклик методу ***finalize()*** - створюйте окремі «функції очищення» і викликайте їх явно. Швидше за все, ***finalize()*** знадобиться тільки в особливих ситуаціях нестандартного звільнення пам'яті, з якими більшість програмістів ніколи не стикається. Проте існує дуже цікаве застосування методу ***finalize()***, яке залежить від того, чи викликає він кожен раз чи ні. Ця перевірка умови готовності об'єкта.
 
У тій точці, де об'єкт стає непотрібним - там, де він готовий до проведення очищення, - цей об'єкт повинен знаходитися в стані, коли звільнення закріпленої за ним пам'яті безпечно. Наприклад, якщо об'єкт являє собою відкритий файл, то він повинен бути відповідним чином закритий, перед тим як його «прибере» збирач сміття. Якщо якась частина об'єкта не буде готова до знищення, результатом стане помилка в програмі, яку потім дуже складно виявити. Цінність ***finalize()*** в тому і полягає, що він дозволяє вам виявити такі помилки, навіть якщо і не завжди викликається. Одного разу проведена фіналізація явно вкаже на помилку, а це все, що вам потрібно.
Простий приклад використання даного підходу:
 
``` java
//: Initialization/TerminationCondition.java
// Використання finalize() для виявлення об'єкта,
// Не здійснив необхідного фіналізації
class Book {
    boolean checkedOut = false;
    Book(boolean checkOut) {
        checkedOut = checkOut;
    }
    void checkIn() {
        checkedOut = false;
    }
    protected void finalize() {
        if(checkedOut)
            System.out.println("Error: checked out");
        // Зазвичай це робиться так-:
        // Super.finalize(); // Виклик версії базового класу
    }
}

public class TerminationCondition {
    public static void main(String [] args) {
        Book novel = new Book(true);
        // Правильна очистка-:
        novel.checkIn();
        // Втрачаємо посилання, забули про очистку:
        new Book(true);
        // Запит JVM на збірку сміття і фіналізація   :
        System.gc();
    }
}/* Результат:
Error: checked out
*///: ~
```
 
«Умова готовності» полягає в тому, що всі об'єкти ***Book*** повинні бути «зняті з обліку» перед наданням їх в розпорядження збирача сміття, але в методі ***main()*** програміст помилився і залишив поза увагою один з об'єктів ***Book***. Якби в методі ***finalize()*** не було перевірки на умову «готовності», таку помилку було б дуже складно виявити.
 
Зауважте, що для проведення примусової фіналізації був використаний метод ***System.gc()***. Але навіть якщо б його не було, з високим ступенем ймовірності можна сказати, що «загублений» об'єкт ***Book*** рано чи пізно буде виявлений в процесі виконання програми (в цьому випадку передбачається, що програмою буде виділено стільки пам'яті, скільки потрібно, щоб збирач сміття приступив до своїх обов'язків).
 
Зазвичай слід вважати, що версія ***finalize()*** базового класу робить щось важливе, і потрібно викликати її в синтаксисі ***super*** так, як показано в ***Book.finalize()***. В даному прикладі виклик закоментований, тому що він вимагає обробки винятків, а ця тема нами ще не розглядалася.
 
## Як працює збирач сміття
 
Якщо раніше ви працювали на мові програмування, в якому виділення місця для об'єктів в купі було пов'язано з великими витратами, то ви можете припустити, що і в *Java* механізм виділення пам'яті з купи для всіх даних (за винятком примітивів) також обходиться надто дорого. Однак в дійсності використання збирача сміття дає чималий ефект щодо прискорення створення об'єктів. Спочатку це може звучати трохи дивно - звільнення пам'яті позначається на її виділенні - але саме так працюють деякі *JVM*, і це значить, що резервування місця для об'єктів в купі *Java* не поступається за швидкістю виділення простору в стеці в інших мовах.

Уявіть купу мови *C++* у вигляді галявини, де кожен об'єкт «застовпив» свій власний ділянку. Пізніше майданчик звільняється для повторного використання. У деяких віртуальних машинах *Java* купа виглядає зовсім інакше; вона скоріше схожа на стрічку конвеєра, яка пересувається вперед при створенні нового об'єкта. А це означає, що швидкість виділення сховища для об'єкта виявляється досить високою. «Покажчик купи» просто пересувається вперед в «необроблену» територію, і по ефективності цей процес близький до виділення пам'яті в стеку *C++*. (Звичайно, облік виділеного простору пов'язаний з невеликими витратами, але їх аж ніяк не можна порівняти з витратами, що виникають при пошуку вільного блоку в пам'яті.)

Звичайно, використання купи в режимі «стрічки конвеєра» не може тривати нескінченно, і рано чи пізно пам'ять стане сильно фрагментована (що помітно знижує продуктивність), а потім і зовсім вичерпається. Якраз тут в дію вступає збирач сміття; під час своєї роботи він компактно розміщує об'єкти купи, як би зміщуючи «покажчик купи» ближче до початку «стрічки», тим самим запобігаючи фрагментації пам'яті. Збирач сміття реструктуризує внутрішнє розташування об'єктів в пам'яті і дозволить отримати високошвидкісну модель купи для резервування пам'яті.

Щоб зрозуміти, як працює прибирання сміття в *Java*, необхідно дізнатися, як реалізовані збирачі сміття в інших системах. Простий, але повільний механізм збирачів сміття називається підрахунком посилань. За кожним об'єктом зберігається лічильник посилань на нього, і всякий раз при приєднанні нового посилання до об'єкта цей лічильник збільшується. Кожен раз при виході посилання з області дії, або установці його значення в null лічильник посилань зменшується. Таким чином, підрахунок посилань створює невеликі, але постійні витрати під час роботи вашої програми. Збирач сміття перебирає об'єкт за об'єктом списку; виявивши об'єкт з нульовим лічильником, він звільняє ресурси, які займаються цим об'єктом. Але існує одна проблема - якщо об'єкти містять циклічні посилання один на одного, то їх лічильники посилань НЕ обнуляються, хоча насправді об'єкти вже є «сміттям». Виявлення таких «циклічних» груп є серйозною роботою і забирає у збирача сміття достатньо часу. Підрахунок посилань часто використовується для пояснення принципів процесу складання сміття, але, судячи з усього, він не використовується ні в одній з віртуальних машин *Java*.
 
У більш швидких схемах прибирання сміття не залежить від підрахунку посилань. Замість цього воно опирається на ідею, що будь-який існуючий об'єкт простежується до посилання, що знаходиться в стеці, або в статичній пам'яті. Ланцюжок перевірки проходить через кілька рівнів об'єктів. Таким чином, якщо почати з стека і статичного сховища, ми обов'язково доберемося до всіх використовуваних об'єктів. Для кожного знайденого посилання треба взяти об'єкт, на який воно вказує, і відстежити всі посилання цього об'єкта; при цьому виявляються інші об'єкти, на які ці посилання вказують, і так далі, поки не буде перевірена вся інфраструктура посилань, що бере початок в стеці і статичній пам'яті. Кожен об'єкт, виявлений в ході пошуку, все ще використовується в системі. Зауважте, що проблеми циклічних посилань не існує - такі посилання просто не виявляються, і тому стають здобиччю збирача сміття автоматично.
 
В описаному тут підході працює адаптивний механізм збору сміття, при якому *JVM* звертається зі знайденими використовуваними об'єктами згідно якогось варіанту дій. Один з таких варіантів називається зупинити-і-копіювати. Сенс терміна зрозумілий: робота програми тимчасово призупиняється (ця схема не підтримує збірку сміття у фоновому режимі). Потім всі знайдені «живі» (використовувані) об'єкти копіюються з однієї купи в іншу, а «сміття» залишається в першій. При копіюванні об'єктів в нову купу вони розміщуються в вигляді компактного безперервного ланцюжка, вивільняючи простір в купі (і дозволяючи задовольняти замовлення на нове сховище простим переміщенням покажчика).
 
Звичайно, коли об'єкт переміщується з одного місця в інше, всі посилання, що вказують на нього, повинні бути змінені. Посилання в стеці, або в статичному сховищі перевизначаються відразу, але можуть бути й інші посилання на цей об'єкт, які виправляються пізніше, під час чергового «проходу». Виправлення відбувається по мірі знаходження посилань.
 
Існує два фактора, через які «копіюючі збирачі» мають низьку ефективність. По-перше, в системі існує дві купи, і ви «перелопачуєте» пам'ять то туди, то сюди між двома окремими купами, при цьому половина пам'яті марнується. Деякі *JVM* намагаються вирішити цю проблему, виділяючи пам'ять для купи невеликими порціями по мірі необхідності, а потім просто копіюючи одну порцію в іншу.
 
Друге питання - копіювання. Як тільки програма перейде в фазу стабільної роботи, вона зазвичай, або стає «безвідходною», або виробляє зовсім небагато «сміття». Незважаючи на це, що «копіюючий збирач» все одно не перестане копіювати пам'ять з одного місця в інше, що марнотратно. Деякі *JVM* визначають, що нових «відходів» не виникає, і перемикаються на іншу схему («адаптивна» частина). Ця схема називається помітити-і-прибрати (видалити), і саме на ній працювали ранні версії віртуальних машин фірми *Sun*. Для повсюдного використання варіант «помітити-і-прибрати» надто повільний, але, коли відомо, що нового «сміття» мало або взагалі немає, він виконується швидко.
 
Схема «помітити-і-прибрати» використовує ту ж логіку - перевірка починається зі стека і статичного сховища, після чого поступово виявляються всі посилання на «живі» об'єкти. Проте кожного разу при знаходженні об'єкт позначається, але ще продовжує існування. «Прибирання» відбувається тільки після очистки процесу перевірки та позначки. Всі «мертві» об'єкти при цьому видаляються. Але копіювання не відбувається, і якщо складальник вирішить «упакувати» фрагментовану купу, то робиться це переміщенням об'єктів всередині неї.
 
Ідея «зупинитися-і-копіювати» несумісна з фоновим процесом складання сміття; на початку збирання програма зупиняється. У літературі фірми *Sun* можна знайти чимало заяв про те, що збірка сміття є фоновим процесом з низьким пріоритетом, але виявляється, що реалізації в такому вигляді (по крайній мірі в перших реалізаціях віртуальної машини *Sun*) в дійсності не існує. Замість цього збирач сміття від *Sun* починав виконання тільки при нестачі пам'яті. Схема «помітити-і-прибрати» також вимагає зупинки програми.
 
Як згадувалося раніше, в описуваної тут віртуальній машині пам'ять виділяється великими блоками. При створенні великого об'єкта йому виділяється власний блок. Сувора реалізація схеми «зупинитися-і-копіювати» вимагає, щоб кожен використовуваний об'єкт з вихідної купи копіювався в нову купу перед звільненням пам'яті старої купи, що пов'язано з великими переміщеннями пам'яті. При роботі з блоками пам'яті збирач сміття використовує незайняті блоки для копіювання у міру їх накопичення. У кожного блоку є лічильник поколінь, що стежить за використанням блоку. У звичайній ситуації «упаковуються» тільки ті блоки, які були створені після останньої збірки сміття; для всіх інших блоків значення лічильника збільшується при створенні зовнішніх посилань. Такий підхід підходить для стандартної ситуації - створення безлічі тимчасових об'єктів з коротким терміном життя. Періодично проводиться повне очищення - великі блоки не копіюються (тільки нарощуються їх лічильники), але блоки з маленькими об'єктами копіюються і «упаковуються». Віртуальна машина постійно стежить за ефективністю збірки сміття і, якщо вона стає неефективною, тому що в програмі залишилися тільки довгоживучі об'єкти, перемикається на схему 
«помітити-і-прибрати». Аналогічно *JVM* стежить за успішністю схеми «помітити-і-прибрати», і, коли купа стає надмірно фрагментованою, збирач сміття перемикається назад до схеми «зупинитися-і-копіювати». Це і є адаптивний механізм.
 
Існують і інші способи прискорення роботи в *JVM*. Найбільш важливі - це дії завантажувача і те, що називається компіляцією «на льоту» (*Just-In-Time, JIT*). Компілятор *JIT* частково або повністю конвертує програму в «рідний» машинний код, завдяки чому останній не потребує обробки віртуальною машиною і може виконуватися набагато швидше. При завантаженні класу (зазвичай це відбувається при першому створенні об'єкта цього класу) система знаходить файл .class, і байт-код з цього файлу переноситься в пам'ять. У цей момент можна просто провести компіляцію *JIT* для коду класу, але такий підхід має два недоліки: по-перше, це займе трохи більше часу, що разом з життєвим циклом програми може серйозно відбитися на продуктивності. По-друге, збільшується розмір файлу (байт-код займає набагато менше місця в порівнянні з розширеним кодом *JIT*), що може привести до підкачування пам'яті, і це теж уповільнить програму. Альтернативна схема відкладеного обчислення має на увазі, що код *JIT* компілюється тільки тоді, коли це стане необхідно. Інакше кажучи, код, який ніколи не виконується, що не компілюється *JIT*. Нова технологія *Java HotSpot*, вбудована в останні версії *JDK*, робить це схожим чином з застосуванням послідовної оптимізації коду при кожному його виконанні. Таким чином, чим частіше виконується код, тим швидше він працює.
 
## Ініціалізація членів класу
 
*Java* іноді порушує гарантії ініціалізації змінних перед їх використанням. У випадку з змінними, визначеними локально, в методі, ця гарантія надається у формі повідомлення про помилку. Скажімо, при спробі використання фрагмента
 
``` java
void f() {
    int i;
    i++, // Помилка - змінна i не ініціалізована
}
```
 
ви отримаєте повідомлення про помилку, яке вказує на те, що змінна ***i*** була проініціалізована. Звичайно, компілятор міг би привласнювати таким змінним значення за замовчуванням, але дана ситуація більше схожа на помилку програміста, і подібний підхід лише приховав би її. Змусити програміста привласнити змінної значення за замовчуванням - значить запобігти помилці в програмі.
 
Якщо примітивний тип є полем класу, то і спосіб поводження з ним дещо інший. Як було показано в розділі 2, кожному примітивного полю класу гарантовано присвоюється значення за замовчуванням. Наступна програма підтверджує цей факт і виводить значення:
 
``` java
//: Initialization/InitialValues.java
// Висновок початкових значень, що присвоюються за замовчуванням.
import static net.mindview.util.Print.*;
public class InitialValues {
    boolean t;
    char c;
    byte b;
    short s;
    int i;
    long l;
    float f;
    double d;
    InitialValues reference;
    void printInitialValues() {
        print("Data type Initial value");
        print("boolean " + t);
        print("char [" + c + "]");
        print("byte " + b);
        print("short " + s);
        print("int " + i);
        print("long " + l);
        print("float " + f);
        print("double " + d);
        print("reference " + reference);
    }
    public static void main(String[] args) {
        InitialValues iv = new InitialValues();
        iv.printInitialValues();
        /* Тут можливий такий варіант:
        new InitialValues().printInitialValues();
        */
    }
}/* Результат:
Data type Initial value
boolean false
char []
byte 0
short 0
int 0
long 0
float 0.0
double 0.0
reference null
*///: ~
```
 
Придивіться - навіть якщо значення явно не задано, то воно автоматично не ініціалізовано. (Символьній змінній ***char*** присвоюється значення нуль, яке відображається у вигляді пропуску.) Принаймні, немає небезпеки випадкового використання неініціалізованої змінної.
 
Якщо посилання на об'єкт, визначено всередині класу, не зв'язано з новим об'єктом, то їй автоматично присвоюється спеціальне значення ***null*** (ключове слово *Java*).
 
## Явна ініціалізація
 
Що робити, якщо вам знадобиться надати змінної початкове значення? Найпростіше зробити це прямим присвоєнням цій змінній значення в точці її оголошення в класі. (Зауважте, що в *C++* така дія заборонено, хоча її постійно намагаються виконати новачки.) У наступному прикладі полям вже знайомого класу InitialValues присвоєні початкові значення:
 
``` java
//: Initialization/InitialValues2.java
// Явна визначення початкових значень змінних.
public class InitialValues2 {
    boolean bool = true;
    char ch = 'x';
    byte b = 47;
    short s = 0xff;
    int i = 999;
    long lng = 1;
    float f = 3.14f;
    double d = 3.14159;
}
```

Аналогічним чином можна форматувати і не-примітивні типи. Якщо ***Depth*** є класом, ви можете додати змінну і форматувати її наступним чином:

``` java
//: Initialization/Measurement.java
class Depth {}

public class Measurement {
    Depth d = new Depth();
// ...
}
```
 
Якщо ви спробуєте використати посилання ***d***, якому не задано початкове значення, станеться помилка часу виконання, звана виключенням (виключення докладно описуються в главі 10). Початкове значення навіть може бути викликом методу:
 
``` java
//: Initialization/MethodInit.java
public class MethodInit {
    int i = f();
    int f() {return 11; }
}
```
 
Звичайно, метод може отримувати аргументи, але в якості останніх не повинні використовуватися неініціалізовані члени класу. Наприклад, так правильно:
 
``` java
//: Initialization/MethodInit2.java
public class MethodInit2 {
    int i = f();
    int j = g(i);
    int f() {return 11;}
    int g(int n) {return n * 10;}
}
```

a так ні:
 
``` java
//: Initialization/MethodInit3.java
public class MethodInit3 {
    //! int j = g(i); // Illegal forward reference
    int i = f();
    int f() {return 11; }
    int g(int n) {return n * 10; }
}
```
 
Це одне з місць, де компілятор на повній підставі висловлює невдоволення передчасний посиланням, оскільки помилка пов'язана з порядком ініціалізації, а не з компіляцією програми. Описаний підхід ініціалізації дуже простий і прямолінійний. У нього є обмеження - всі об'єкти типу ***InitialValues*** отримають одні і ті ж початкові значення. Іноді вам потрібно саме це, але в інших ситуаціях необхідна більша гнучкість.
 
## Ініціалізація конструктором
 
Для проведення ініціалізації можна використовувати конструктор. Це надає більшу гнучкість процесу програмування, так як з'являється можливість виклику методів і виконання дії з ініціалізації прямо під час роботи програми. Втім, при цьому необхідно враховувати ще одну обставину: воно не виключає автоматичної ініціалізації, що відбувається перед виконанням конструктора. Наприклад, в наступному фрагменті
 
``` java
//: Initialization/Counter.java
public class Counter {
    int i;
    Counter() {i = 7; }
// ...
}
```
 
змінній ***i*** спочатку буде присвоєно значення *0*, а потім вже *7*. Це вірно для всіх примітивних типів і посилань на об'єкти, включаючи ті, яким задають явні значення в точці визначення. З цих причин компілятор не намагається змусити вас форматувати елементи в конструкторі, або в іншому визначеному місці, або перед їх використанням - ініціалізація і так гарантована.
 
## Порядок ініціалізації
 
В середині класу черговість ініціалізації визначається порядком проходження змінних, оголошених в цьому класі. Визначення змінних можуть бути розкидані по різних визначеннях методів, але в будь-якому випадку змінні ініціалізуються перед викликом будь-якого методу - навіть конструктора.
Наприклад:
 
``` java
//: Initialization/OrderOfInitialization.java
// Демонструє порядок ініціалізації.
        import static net.mindview.util.Print.*;

// При виклику конструктора для створення об'єкта
// Window виводиться повідомлення:
class Window {
    Window(int marker) {print("Window(" + marker + ")"); }
}

class House {
    Window w1 = new Window(1); // Перед конструктором
    House() {
// Показує, що виконується конструктор:
        print("House()");
        w3 = new Window(33); // Повторна ініціалізація w3
    }
    Window w2 = new Window(2); // Після конструктора
    void f() {print("f()"); }
    Window w3 = new Window(3); // В кінці
}

public class OrderOfInitialization {
    public static void main(String [] args) {
        House h = new House();
        hf(); // Показує, що об'єкт сконструйований
    }
}/* Результат:
Window(1)
Window(2)
Window(3)
House()
Window(33)
f()
*///: ~
```
 
В класі ***House*** визначення об'єктів ***Window*** навмисно розкидані, щоб довести, що всі вони не ініціалізовані перед виконанням конструктора, або якоюсь іншою дією. До того ж посилання ***w3*** заново проходить ініціалізацію в конструкторі.
 
З результатів програми видно, що посилання ***w3*** оминає подвійну ініціалізацію, перед викликом конструктора і під час нього. (Перший об'єкт втрачається, і з часом його знищить збирач сміття.) Спочатку це може здатися неефективним, але такий підхід гарантує вірну ініціалізацію - що сталося б, якби в класі було визначено перевантажений конструктор, який не ініціалізував би посилання ***w3***, а воно при цьому не отримувало б значення за замовчуванням?
 
## Ініціалізація статичних даних
 
Дані статичних полів завжди існують в єдиному екземплярі, незалежно від кількості створених об'єктів. Ключове слово ***static*** не може застосовуватися до локальних-змінних, тільки до полів. Якщо під впливом статичності поле відноситься до примітивного типу, при відсутності явної ініціалізації йому присвоюється значення за замовчуванням. Якщо це посилання на об'єкт, то йому присвоюється значення ***null***. Якщо ви хочете провести ініціалізацію в місці визначення, воно виглядає точно так само, як і у нестатичних членів класу. Наступний приклад допомагає зрозуміти, коли ініціалізується статична пам'ять:
 
``` java
//: Initialization/StaticInitialization.java
// Вказання значень за замовчуванням у визначенні класу.
import static net.mindview.util.Print. *;

class Bowl {
    Bowl(int marker) {
        print("Bowl(" + marker + ")");
    }
    void f1(int marker) {
        print("f1(" + marker + ")");
    }
}

class Table {
    static Bowl bowl1 = new Bowl(1);
    Table() {
        print("Table()");
        bowl2.f1(1);
    }
    void f2(int marker) {
        print("f2(" + marker + ")");
    }
    static Bowl bowl2 = new Bowl(2);
}

class Cupboard {
    Bowl bowl3 = new Bowl(3);
    static Bowl bowl4 = new Bowl(4);
    Cupboard() {
        print("Cupboard()");
        bowl4.f1(2);
    }
    void f3(int marker) {
        print("f3(" + marker + ")");
    }
    static Bowl bowl5 = new Bowl(5);
}

public class StaticInitialization {
    public static void main(String [] args) {
        print("Creating new Cupboard() in main");
        new Cupboard();
        print("Creating new Cupboard() in main");
        new Cupboard();
        table.f2(1);
        cupboard.f3(1);
    }
    static Table table = new Table();
    static Cupboard cupboard = new Cupboard();
}/* Результат:
Bowl(1)
Bowl(2)
Table()
f1(1)
Bowl(4)
Bowl(5)
Bowl(3)
Cupboard()
f1(2)
Creating new Cupboard() in main
Bowl(3)
Cupboard()
f1(2)
Creating new Cupboard() in main
Bowl(3)
Cupboard()
f1(2)
f2(1)
f3(1)
*///: ~
```
 
Клас ***Bowl*** дозволяє простежити за процесом створення класів; класи ***Table*** і ***Cupboard*** містять визначення статичних об'єктів ***Bowl***. Зауважте, що в класі ***Cupboard*** створюється нестатичних змінна ***Bowl bowl3***, хоча всі інші визначення - статичні.
 
З вихідних даних програми видно, що статична ініціалізація відбувається тільки в разі потреби. Якщо ви не створюєте об'єктів ***Table*** і ніколи не звертаєтеся до ***Table.bowl1***, або ***Table.bowl2***, то відповідно, не буде і об'єктів ***static Bowl bowl1*** і ***static Bowl bowl2***. Вони ініціалізовані лише при створенні першого об'єкта ***Table***(або при першому зверненні до статичних даних). Після цього статичні об'єкти повторно не перевизначаються.
 
Спочатку ініціалізуються ***static***-члени, якщо вони ще не були проініціалізовані, і тільки потім нестатичні об'єкти. Доказ справедливості цього твердження легко знайти в результаті роботи програми. Для виконання ***main()*** (а це статичний метод!) завантажується клас ***StaticInitialization***; потім ініціалізуються статичні поля ***table*** і ***cupboard***, внаслідок чого завантажуються ці класи. І так як всі вони містять статичні об'єкти ***Bowl***, завантажується клас ***Bowl***. Таким чином, всі класи програми завантажуються до початку ***main()***. Втім, ця ситуація не є типовою, оскільки в типовій програмі не всі поля оголошуються як статичні, як в даному прикладі.
 
Непогано тепер узагальнити знання про процес створення об'єкта. Для прикладу візьмемо клас з ім'ям ***Dog***:
 
1. Хоча ключове слово ***static*** і не використовується явно, конструктор в дійсності є статичним методом. При створенні першого об'єкта типу ***Dog***, або під час першого виклику статичного методу, чи звернення до статичного полю класу ***Dog***, інтерпретатор *Java* повинен знайти ***Dog.class***. Пошук здійснюється у стандартних каталогах, перерахованих у змінній оточення ***СLASSPATH***.
 
2. Після завантаження файлу ***Dog.class*** (зі створенням особливого об'єкта ***Class***, про який ми дізнаємося пізніше) проводиться ініціалізація статичних елементів. Таким чином, ініціалізація статичних членів проводиться тільки один раз, при першому завантаженні об'єкта ***Class***.
 
3. При створенні нового об'єкта конструкцією ***new Dog()*** спочатку виділяється блок пам'яті, достатній для зберігання об'єкта ***Dog*** в купі.
 
4. Виділена пам'ять заповнюється нулями, при цьому всі примітивні поля об'єкта ***Dog*** автоматично ініціалізуються значеннями за замовчуванням (нуль для чисел, його еквіваленти для типів ***boolean*** і ***char***, ***null*** для посилань).
 
5. Виконуються всі дії по ініціалізації, що відбуваються в точці визначення полів класу.
 
6. Виконуються конструктори. Як ви дізнаєтеся з розділу 7, на цьому етапі виконується досить велика частина роботи, особливо при використанні успадкування.
 
## Явна ініціалізація статичних членів

Мова *Java* дозволяє згрупувати кілька дій з ініціалізації об'єктів ***static*** в спеціальній конструкції, іменованої статичним блоком. Виглядає це приблизно так:
 
``` java
//: Initialization/Spoon.java
public class Spoon {
    static int i;
    static {
        i = 47;
    }
}
```
 
Схоже на визначення методу, але насправді ми бачимо лише ключове слово ***static*** з подальшим блоком коду. Цей код, як і інша ініціалізація типу ***static***, виконується тільки один раз: при першому створенні об'єкта цього класу, або при першому зверненні до статичних членів цього класу (навіть якщо об'єкт класу ніколи не створюється).
Наприклад:
 
``` java
//: Initialization/ExplicitStatic.java
// Явна ініціалізація з використанням конструкції "static"
import static net.mindview.util.Print. *;

class Cup {
    Cup(int marker) {
        print("Cup(" + marker + ")");
    }
    void f(int marker) {
        print("f(" + marker + ")");
    }
}

class Cups {
    static Cup cup1;
    static Cup cup2;
    static {
        cup1 = new Cup(1);
        cup2 = new Cup(2);
    }
    Cups() {
        print("Cups()");
    }
}

public class ExplicitStatic {
    public static void main(String [] args) {
        print("Inside main()");
        Cups.cup1.f(99); //(1)
    }
// Static Cups cups1 = new Cups(); //(2)
// Static Cups cups2 = new Cups(); //(2)
}/* Результат:
Inside main()
Cup(1)
Cup(2)
f(99)
*///: ~
```
 
Статичний ініціалізатор класу ***Cups*** виконується, або при зверненні до статичного об'єкту ***cup1*** в рядку з позначкою (1), або якщо рядок (1) закоментований - в рядках (2) після зняття коментарів. Якщо ж і рядок (1), і рядки (2) закоментовані, ***static***-ініціалізація класу Cups ніколи не виконається. Також неважливо, чи будуть виконані один, або обидві рядки (2) програми - ***static***-ініціалізація все одно виконується тільки один раз.
 
## Ініціалізація нестатичних даних примірника
 
В *Java* є подібний синтаксис для ініціалізації нестатичних змінних для кожного об'єкта. Ось приклад:
 
``` java
//: Initialization/Mugs.java
// Ініціалізація примірника
import static net.mindview.util.Print. *;

class Mug {
    Mug(int marker) {
        print("Mug(" + marker + ")");
    }
    void f(int marker) {
        print("f(" + marker + ")");
    }
}

public class Mugs {
    Mug mug1;
    Mug mug2;
    {
        mug1 = new Mug(1);
        mug2 = new Mug(2);
        print("mug1 & mug2 initialized");
    }
    Mugs() {
        print("Mugs()");
    }
    Mugs(int i) {
        print("Mugs(int)");
    }
    public static void main(String [] args) {
        print("Inside main()");
        new Mugs();
        print("new Mugs() completed");
        new Mugs(1);
        print("new Mugs(1) completed");
    }
}/* Результат:
Inside main()
Mug(1)
Mug(2)
mug1 & mug2 initialized
Mugs()
new Mugs() completed
Mug(1)
Mug(2)
mug1 & mug2 initialized
Mugs(int)
new Mugs(1) completed
*///: ~
```
 
виглядає в точності так само, як і конструкція ***static***-ініціалізації, хіба що ключове слово ***static*** відсутнє. Такий синтаксис необхідний для підтримки ініціалізації анонімних внутрішніх класів (див. Розділ 9), але він також гарантує, що деякі операції будуть виконані незалежно від того, який саме конструктор був викликаний в програмі. З результатів видно, що секція ініціалізації екземпляра виконується раніше будь-яких конструкторів.
 
## Ініціалізація масивів
 
Масив являє собою послідовність об'єктів або примітивів, що відносяться до одного типу, що позначається одним ідентифікатором. Масиви визначаються і використовуються за допомогою оператора індексування ***\[\]***. Щоб оголосити масив, ви просто вказуєте слідом за типом порожні квадратні дужки:
 
int[] al;
 
Квадратні дужки також можуть розміщуватися після ідентифікатора, ефект буде точно таким же:
 
int al[];
 
Це відповідає очікуванням програмістів на *C* і *C++*, які звикли до такого синтаксису. Втім, перший стиль, мабуть, виглядає більш логічно - він відразу дає зрозуміти, що мається на увазі «масив значень типу ***int***». Саме він і буде використовуватися в книзі.
 
Компілятор не дозволяє вказати точний розмір масиву. Згадайте, що говорилося раніше про посилання. Все, що у вас зараз є, - це посилання на масив, для якого ще не було виділено пам'ять. Щоб зарезервувати пам'ять для масиву, необхідно записати деякий вираз ініціалізації. Для масивів такий вислів може перебувати в будь-якому місці програми, але існує і особливий різновид виразів ініціалізації, яка використовується тільки в точці оголошення масиву. Ця спеціальна ініціалізація виглядає як набір значень в фігурних дужках. Виділення пам'яті (еквівалентно дії оператора ***new***) в цьому випадку проводиться компілятором. Наприклад:
 
``` java
int[] a1 = {1, 2, 3, 4, 5};
```
 
Але навіщо тоді взагалі потрібно визначати посилання на масив без самого масиву?
 
``` java
int[] a2;
```
 
По-перше, в *Java* можна привласнити один масив іншому, записавши наступне:
 
``` java
a2 = a1;
```
 
В даному випадку ви насправді копіюєте посилання, як показано в прикладі:
 
``` java
//: Initialization/ArraysOfPrimitives.java
// Масиви найпростіших типів.
import static net.mindview.util.Print. *;

public class ArraysOfPrimitives {
    public static void main(String [] args) {
        int [] a1 = {1, 2, 3, 4, 5};
        int [] a2;
        a2 = a1;
        for(int i = 0; i <a2.length; i ++)
            a2 [i] = a2 [i] + 1;
        for(int i = 0; i <a1.length; i ++)
            print("a1 [" + i + "] =" + a1 [i]);
    }
}/* Результат:
a1 [0] = 2
a1 [1] = 3
a1 [2] = 4
a1 [3] = 5
a1 [4] = 6
*///: ~
```
 
Масив ***a1*** ініціалізується набором значень, в той час як масив ***a2*** немає ініціалізації; для ***a2*** присвоювання  виконується пізніше - в даному випадку йому присвоюється інший масив.
 
Всі масиви (як масиви примітивів, так і масиви об'єктів) містять внутрішнє поле; яке можна прочитати (але не змінити!) для отримання кількості елементів в масиві. Це поле називається ***length***. Так, як в масивах *Java*, *C* і *C++* нумерація елементів починається з нуля, останньому елементу масиву відповідає індекс ***length-1***.
Виходи за межі масиву *C* і *C++* не перешкоджають «прогулянкам в пам'яті» програми, що часто призводить до сумних наслідків. Але *Java* захищає вас від таких проблем - при виході за рамки масиву відбувається помилка часу виконання (виняток, тема глави 10).
 
А якщо під час написання програми ви не знаєте, скільки елементів вам знадобиться в новому масиві? Тоді просто використовуйте ***new*** для створення його елементів. У наступному прикладі ***new*** працює, хоча в програмі створюється масив примітивних типів(оператор ***new*** непридатний для створення примітивів поза масиву):
 
``` java
//: Initialization/ArrayNew.java
// Створення масивів оператором new.
import java.util. *;
import static net.mindview.util.Print. *;

public class ArrayNew {
    public static void main(String [] args) {
        int [] a;
        Random rand = new Random(47);
        a = new int [rand.nextInt(20)];
        print("length of a =" + a.length);
        print(Arrays.toString(a));
    }
}/* Результат:
length of a = 18
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
*///: ~
```
 
Розмір масиву вибирається випадковим чином, з використанням методу ***Random.nextInt()***, що генерує число від нуля до переданого в якості аргументу значення. Так як розмір масиву випадковий, очевидно, що створення масиву відбувається під час виконання програми. До того ж, результат роботи програми дозволяє переконатися в тому, що елементи масивів найпростіших типів автоматично не ініціалізовано «порожніми» значеннями. (Для чисел і символів це нуль, а для логічного типу ***boolean*** - ***false***.)
 
Метод ***Arrays.toString()***, що входить в стандартну бібліотеку ***java.util***, видає друковану версію одновимірного масиву.
 
Звичайно, в даному прикладі масив можна визначити і ініціалізувати в одному рядку:
 
``` java
int[] а = new int[rand.nextInt(20)];
```
 
Якщо можливо, рекомендується використовувати саме таку форму запису. При створенні масиву непрімітівних об'єктів ви фактично створюєте масив посилань. Для прикладу візьмемо клас-обгортку ***Integer***, який є саме класом, а не примітивом:
 
``` java
//: Initialization/ArrayClassObj.java
// Створення масиву непрімітівних об'єктів.
import java.util. *;
import static net.mindview.util.Print. *;

public class ArrayClassObj {
    public static void main(String [] args) {
        Random rand = new Random(47);
        Integer [] a = new Integer [rand.nextInt(20)];
        print("length of a =" + a.length);
        for(int i = 0; i <a.length; i ++)
            a [i] = rand.nextInt(500); // Автоматична упаковка
        print(Arrays.toString(a));
    }
}/* Результат:(Sample)
length of a = 18
[55, 193, 361, 461, 429, 368, 200, 22, 207, 288, 128, 51, 89, 309, 278,
498, 361, 20]
*///: ~
```
 
Тут навіть після виклику ***new*** для створення масиву
 
``` java
Integer[] а = new Integer[rand nextlnt(20)];
```
 
ми маємо лише масив з посилань - до тих пір, поки кожне посилання не буде ініціалізовано новим об'єктом ***Integer*** (в даному випадку це робиться за допомогою автоупаковки, ***autoboxing***, даних):
 
``` java
a [i] = rand.nextlnt(500);
```
 
Якщо ви забудете створити об'єкт, то отримаєте виключення під час виконання програми, при спробі читання неіснуючого елемента масиву. Масиви об'єктів також можна форматувати списком в фігурних дужках. Існує дві форми синтаксису:
 
``` java
//: Initialization/ArrayInit.java
// Ініціалізація масивів
import java.util. *;

public class ArrayInit {
    public static void main(String[] args) {
        Integer[] a = {
                new Integer(1),
                new Integer(2),
                3, // Автоматична упаковка
        };
        Integer[] b = new Integer [] {
                new Integer(1),
                new Integer(2),
                3, // Автоматична упаковка
        };
        System.out.println(Arrays.toString(a));
        System.out.println(Arrays.toString(b));
    }
}/* Результат:
[1, 2, 3]
[1, 2, 3]
*///: ~
```
 
В обох випадках завершальна кома в списку ініціалізаторів не обов'язкова(вона всього лише спрощує ведення довгих списків). Перша форма корисна, але вона більш обмежена, оскільки може використовуватися тільки в точці визначення масиву. Друга форма може використовуватися скрізь, навіть всередині виклику методу.
 
## Змінні списки аргументів
 
Синтаксис другої форми надає зручний синтаксис створення і виклику методів з ефектом, що нагадує змінні списки аргументів мови *C* (відомі як ***“varargs”*** в *C*). Такий список здатний утримувати заздалегідь невідому кількість аргументів невідомого типу. Так як абсолютно всі класи успадковані від загального кореневого класу ***Object***, можна створити метод, який приймає в якості аргументу масив ***Object***, і викликати його в такий спосіб:
 
``` java
//: Initialization/VarArgs.java
// Використання синтаксису масивів
// Для отримання змінного списку параметрів.
class A {}

public class VarArgs {
    static void printArray(Object [] args) {
        for(Object obj   : args)
            System.out.print(obj + "");
        System.out.println();
    }
    public static void main(String [] args) {
        printArray(new Object [] {
                new Integer(47), new Float(3.14), new Double(11.11)
        });
        printArray(new Object [] { "one", "two", "three"});
        printArray(new Object [] {new A(), new A(), new A()});
    }
}/* Результат:(Sample)
47 3.14 11.11
one two three
A @ 1a46e30 A @ 3e25a5 A @ 19821f
*///: ~
```
 
Видно, що метод ***print()*** приймає масив об'єктів типу ***Object***, перебирає всі його елементи і виводить їх. Класи з стандартної бібліотеки *Java* при друку виводять осмислену інформацію, проте об'єкти класів в даному прикладі виводять ім'я класу, потім символ ***@*** і кілька шістнадцяткових цифр. Таким чином, за замовчуванням клас виводить ім'я та адресу об'єкта (якщо тільки ви не перевизначите в класі метод ***toString()*** - див. далі).
 
До виходу *Java* *SE5* змінні списки аргументів реалізовувалися саме так. В *Java* *SE5* ця довгоочікувана можливість нарешті була додана в мову - тепер для визначення змінного списку аргументів можна використовуватися три крапки, як видно у визначенні методу ***printArray***:
 
``` java
//: Initialization/NewVarArgs.java
/ Створення списків аргументів змінної довжини
// З використанням синтаксису масивів.
public class NewVarArgs {
    static void printArray(Object ... args) {
        for(Object obj   : args)
            System.out.print(obj + "");
        System.out.println();
    }
    public static void main(String [] args) {
// Можна передати окремі елементи:
        printArray(new Integer(47), new Float(3.14),
                new Double(11.11));
        printArray(47, 3.14F, 11.11);
        printArray("one", "two", "three");
        printArray(new A(), new A(), new A());
// Або масив:
        printArray((Object []) new Integer [] {1, 2, 3, 4});
        printArray(); // Порожній список теж можливий
    }
}/* Результат:(75% match)
47 3.14 11.11
47 3.14 11.11
one two three
A @ 1bab50a A @ c3c749 A @ 150bd4d
2 3 4
*///: ~
```
 
## Резюме
 
Такий складний механізм ініціалізації, як конструктор, показує, наскільки важливу увагу в мові приділяється ініціалізації. Коли Бйорн Страуструп розробляв *C++*, в першу чергу він звернув увагу на те, що низька продуктивність *C* пов'язана з погано продуманою ініціалізацією, чим була обумовлена значна частка помилок. Аналогічні проблеми виникають і при некоректній фіналізації. Так як конструктори дозволяють гарантувати відповідні ініціалізацію і завершальні дії з очищення (компілятор не дозволить створити об'єкт без виклику конструктора), тим самим забезпечується повна керованість і захищеність програми.
 
У мові *C++* знищення об'єктів грає дуже важливу роль, тому що об'єкти, створені оператором ***new***, повинні бути відповідним чином знищені. В *Java* пам'ять автоматично звільняється збирачем сміття, і аналоги деструкторов зазвичай не потрібні. У таких випадках збирач сміття *Java* значно спрощує процес програмування і до того ж додає так необхідну безпеку при звільненні ресурсів. Деякі збирачі сміття можуть проводити завершальні дії навіть з такими ресурсами, як графічні та файлові дескриптори. Однак збирачі сміття додають витрати під час виконання програми, які поки важко реально оцінити через ситуацію, історичної повільності інтерпретаторів *Java*. І хоча останнім часом мова
*Java* набагато покращила свою продуктивність, проблема швидкодії все-таки наклала свій відбиток на можливість вирішення деякого класу задач цією мовою.
 
Так як для всіх об'єктів гарантовано використовуються конструктори, на останні покладаються додаткові обов'язки, не описані в цьому розділі. Зокрема, гарантія конструювання діє і при створенні нових класів з використанням композиції або успадкування, і для їх підтримки потрібні деякі доповнення до синтаксису мови. Композиція і успадкування, а також їх вплив на конструктори, розглядаються в наступних розділах.
 