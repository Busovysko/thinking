# Управління доступом
 
Найважливішим фактором об'єктно-орієнтованої розробки є відділення змінних складових від постійних. Це особливо важливо для бібліотек. Користувач, програміст-клієнт, бібліотеки залежить від незмінності деякого аспекту вашого коду. З іншого боку, творець бібліотеки повинен володіти достатньою свободою для проведення змін і поліпшень, але при цьому зміни не повинні порушити працездатний стан клієнтського коду.
Бажана мета може бути досягнута певними домовленостями:
 
Наприклад, програміст бібліотеки погоджується не вилучати вже існуючі методи класу, тому що це може порушити структуру коду програміста-клієнта. У той же час зворотна проблема набагато гостріша. Наприклад, як творець бібліотеки дізнається, які з полів даних використовуються програмістом-клієнтом? Це саме можна сказати і про методи, що є тільки частиною реалізації класу, тобто не призначеним для прямого використання програмістом-клієнтом. А якщо творцеві бібліотеки знадобиться видалити стару реалізацію і замінити її новою?
 
Зміна будь-якого з полів класу може порушити роботу коду програміста-клієнта. Виходить, у творця бібліотеки «зв'язані руки», і він взагалі нічого не має права змінювати.
 
Для вирішення проблеми в *Java* визначені специфікатори доступу (*access specifiers*), за допомогою яких автор бібліотеки вказує, що доступно програмісту-клієнту, а що ні. Рівні доступу (від повного до мінімального) задаються наступними ключовими словами: ***public***, ***protected***, доступ в межах пакету (не має ключового слова) і ***private***. З попереднього абзацу може виникнути враження, що творцеві бібліотеки найкраще зберігати все якомога «секретніше», а відкривати тільки ті методи, які, на вашу думку, повинен використовувати програміст-клієнт. І це абсолютно вірно, хоча і виглядає незвично для людей, чиї програми на інших мовах (особливо це стосується *C*) «звикли» до відсутності обмежень. До кінця цієї глави ви наочно переконаєтеся в корисності механізму контролю доступу в *Java*.
 
Однак концепція бібліотеки компонентів і контролю над доступом до цих компонентів - це ще не все. Залишається зрозуміти, як компоненти зв'язуються в об'єднану цілісну бібліотеку. В *Java* ця задача вирішується ключовим словом ***package*** (пакет), і специфікатор доступу залежать від того, чи знаходяться класи в одному, чи в різних пакетах. Тому для початку ми розберемося, як компоненти бібліотек розміщуються в пакетах. Після цього ви зможете в повній мірі зрозуміти сенс специфікаторів доступу. 

## Пакет як бібліотечний модуль
 
Пакет містить групу класів, об'єднаних в одному просторі імен. Наприклад, в стандартну поставку *Java* входить службова бібліотека, оформлена у вигляді простору імен ***java.util***. Один з класів ***java.util*** називається ***ArrayList***. Щоб використовувати цей клас у програмі, можна використовувати його повне ім'я ***java.util.ArrayList***. Втім, повні імена занадто громіздкі, тому в програмі зручніше використовувати ключове слово ***import***. Якщо ви збираєтеся використовувати всього один клас, його можна вказати прямо в директиві ***import***:
 
``` java
//: Access/SingleImport.java
import java.util.ArrayList;

public class SingleImport {
    public static void main (String [] args) {
        ArrayList list = new java.util.ArrayList ();
    }
}
```
 
Тепер до класу ***ArrayList*** можна звертатися без вказання повного імені, але інші класи пакету ***java.util*** залишаться недоступними. Щоб імпортувати всі класи, вкажіть ***\**** замість імені класу, як це робиться майже у всіх прикладах книги:
 
``` java
import java.util.*;
```
 
Механізм імпортування забезпечує можливість управління просторами імен. Імена членів класів ізолюються одна від одної. Метод ***f()*** класу ***А*** не конфліктує з методом ***f()*** з таким же визначенням (списком аргументів) класу ***В***. А як щодо імен класів? Припустимо, що клас ***Stack*** створюється на комп'ютері, де кимось іншим вже було визначено клас з ім'ям ***Stack***. Потенційні конфлікти імен - основна причина, по якій так важливо управління просторами імен в *Java* і можливість створення унікальних ідентифікаторів для всіх класів.

До цього моменту більшість прикладів книги записувалися в окремих файлах і призначалися для локального використання, тому на імена пакетів можна було не звертати уваги. (У такому випадку імена класів розміщуються в «пакеті за замовчуванням».) Звичайно, це теж рішення, і такий підхід буде застосовуватися в книзі, де тільки можливо. Але, якщо ви створюєте бібліотеку або програму, яка використовує інші програми *Java* на цій же машині, варто подумати про уникнення конфліктів імен.
 
Файл з вихідним текстом на *Java* часто називають компільованим модулем. Ім'я кожного скомпільованого модуля має завершуватися суфіксом ***. java***, а всередині нього може бути відкритий (***public***) клас, що має таке ж ім'я, що і файл (з великої літери, але без розширення ***.java***). Скомпільований модуль може містити не більше одного відкритого класу, інакше компілятор повідомить про помилку. Решта класів модуля, якщо вони там є, приховані від навколишнього світу - вони не є відкритими (***public***) і вважаються «допоміжними» по відношенню до головного відкритого класу.
 
### Організація коду

В результаті компіляції для кожного класу, визначеного в файлі ***.java***, створюється клас з тим же ім'ям але з розширенням ***.class***. Таким чином, при компіляції декількох файлів ***.java*** може з'явитися цілий ряд файлів з розширенням ***.class***. Якщо ви програмували на компільовані мови, то, напевно, звикли до того, що компілятор генерує проміжні файли (зазвичай з розширенням *obj*), які потім об'єднуються компоновщиком для отримання виконуваного файлу, або бібліотеки. *Java* працює не так. Робоча програма являє собою набір однорідних файлів ***.class***, які об'єднуються в пакет і стискаються в файл *jar* (утилітою *Java* ***jar***). Інтерпретатор *Java* відповідає за пошук, завантаження і інтерпретацію цих файлів.
 
Бібліотека також є набором файлів з класами. В кожному файлі є один ***рublіс*** - клас з будь-якою кількістю класів, які не мають специфікатор ***public***. Якщо ви хочете оголосити, що всі ці компоненти (які зберігаються в окремих файлах ***.java*** і ***.class***)
пов'язані один з одним, скористайтеся ключовим словом ***package***.
 
Директива ***package*** повинна знаходитися в першому незакоментованому рядку файлу. Так, команда
 
``` java
package access;
```
 
означає, що даний модуль входить в бібліотеку з ім'ям ***access***. Інакше кажучи, ви вказуєте, що відкритий клас в цьому модулі належить імені ***mypackage*** і, якщо хтось захоче використовувати його, йому доведеться повністю записати, або ім'я класу, або директиву ***import*** з ***access*** (конструкція, зазначена вище). Зауважте, що за правилами *Java* імена пакетів записуються тільки малими літерами.
 
Припустимо, файл називається ***MyClass.java***. Він може містити один і тільки один відкритий клас (***public***), причому останній повинен називатися ***MyClass*** (з урахуванням регістру символів):
 
``` java
//: Access/mypackage/MyClass.java
package access.mypackage;

public class MyClass {
// ...
}
```
 
Якщо тепер хтось захоче використовувати ***MyClass***, або будь-які інші відкриті класи з пакета ***access***, йому доведеться використовувати ключове слово ***import***, щоб імена з ***access*** стали доступними. Можливий і інший варіант - записати повне ім'я класу:
 
``` java
//: Access/QualifiedMyClass.java

public class QualifiedMyClass {
    public static void main (String [] args) {
        access.mypackage.MyClass m =
                new access.mypackage.MyClass ();
    }
}
```
 
З ключовим словом ***import*** рішення виглядає набагато акуратніше:
 
``` java
//: Access/ImportedMyClass.java
import access.mypackage.*;

public class ImportedMyClass {
    public static void main (String [] args) {
        MyClass m = new MyClass ();
    }
}
```
 
Ключові слова ***package*** і ***import*** дозволяють розробнику бібліотеки організувати логічний поділ глобального простору імен, що запобігає конфліктам імен незалежно від того, скільки людей підключиться до Інтернету і почне писати свої класи на *Java*. 

### Створення унікальних назв пакетів

Ви можете помітити, що, оскільки пакет насправді ніколи не «упаковується» в єдиний файл, він може складатися з безлічі файлів ***.class***, що здатне привести до безладу, може, навіть до хаосу. Для запобігання проблеми логічно було б розмістити всі файли ***.class*** конкретного пакета в одному каталозі, тобто скористатися ієрархічною структурою файлової системи. Це перший спосіб вирішення проблеми нагромадження файлів в *Java*; про другий ви дізнаєтеся при описі утиліти ***jar***.
 
Розміщення файлів пакета в окремому каталозі вирішує дві інші завдання: створення унікальних назв пакунків і виявлення класів, втрачених в «нетрях» структури каталогів. Як було згадано в розділі 2, проблема вирішується «кодуванням» шляху файлу в імені пакету. За загальноприйнятою схемою перша частина імені пакета повинна складатися з перевернутого доменного імені розробника класу. Так як доменні імена Інтернету унікальні, дотримання цього правила забезпечить унікальність імен пакетів і запобіжить конфліктам. (Тільки якщо ваше доменне ім'я не дістанеться комусь іншому, хто почне писати програми на *Java* під тим же ім'ям.) Звичайно, якщо у вас немає власного доменного імені, для створення унікальних назв пакунків доведеться придумати комбінацію з малою вірогідністю повторення (скажімо, ім'я та прізвище). Якщо ж ви вирішите публікувати свої програми на *Java*, варто трохи витратитися на отримання власного доменного імені.
 
Друга складова - перетворення імені пакета в каталог на диску комп'ютера. Якщо програмі під час виконання знадобиться завантажити файл ***.class*** (що робиться динамічно, в точці, де програма створює об'єкт певного класу, або при запиті доступу до статичних членів класу), вона може знайти каталог, в якому розташовується файл ***.class***.
 
Інтерпретатор *Java* діє за такою схемою. Спочатку він перевіряє змінну оточення ***CLASSPATH*** (її значення задається операційною системою, а іноді програмою установки *Java* або інструментарієм *Java*).***CLASSPATH*** містить список з одного або декількох каталогів, використовуваних як кореневих при пошуку файлів ***.class***. Починаючи з цих кореневих каталогів, інтерпретатор бере ім'я пакета і замінює точки на слеші для отримання повного шляху (таким чином, директива ***package foo.bar.baz*** перетворюється в ***foo\\bar\\baz, foo/bar/baz*** або щось ще в залежності від вашої операційної системи). Потім отримане ім'я приєднується до різних елементів ***CLASSPATH***. У зазначених місцях ведеться пошук файлів ***.class***, імена яких збігаються з ім'ям створюваного програмою класу. (Пошук також ведеться в стандартних каталогах, які визначаються місцезнаходженням інтерпретатора *Java*.)
 
Щоб зрозуміти все сказане, розглянемо моє доменне ім'я: ***MindView.net***. Обертаючи його, отримуємо унікальне глобальне ім'я для моїх класів: ***net.mindview***. (Розширення *com*, *edu*, *org* та інші в пакетах *Java* спочатку записувалися в верхньому регістрі, але починаючи з версії *Java 2* назви пакунків записуються тільки малими літерами.)
 
Якщо буде потрібно створити бібліотеку з ім'ям ***simple***, я отримую наступне ім'я пакета:
 
``` java
package net.mindview.simple;
```
 
Тепер отримане ім'я пакета можна використовувати в якості об'єднуючого простору імен для наступних двох файлів:
 
``` java
//: Net/mindview/simple/Vector.java
// Створення пакету 
package net.mindview.simple;

public class Vector {
    public Vector () {
        System.out.println ( "net.mindview.simple.Vector");
    }
}
```
 
Як згадувалося раніше, директива ***package*** повинна знаходитися в першому рядку вихідного коду. Другий файл виглядає майже так само:
 
``` java
//: Net/mindview/simple/List.java
// Створення пакету 
package net.mindview.simple;

public class List {
    public List () {
        System.out.println ("net.mindview.simple.List");
    }
}
```
 
У моїй системі обидва файли знаходяться в наступному підкаталозі:

    C:\DOC\JavaT\net\mindview\simple

Якщо ви подивіться на файли, то побачите ім'я пакета ***net.mindview.simple***, але що з першою частиною шляху? Про неї подбає змінна оточення ***CLASSPATH***, яка на моїй машині виглядає наступним чином:

    CLASSPATH=.;D:\JAVA\LIB;C:\DOC\JavaT

Як бачите, ***CLASSPATH*** може містити кілька альтернативних шляхів для пошуку. Однак для файлів *JAR* використовується інший підхід. Ви повинні записати ім'я файлу *JAR* в змінної ***CLASSPATH***, не обмежуючись зазначенням шляху до місця його розташування. Таким чином, для файлу *JAR* з ім'ям ***grape.jar*** змінна оточення повинна виглядати так:

    CLASSPATH=.;D:\JAVA\LIB;C:\flavors\grape.jar 

Після настройки ***CLASSPATH*** наступний файл можна розмістити в будь-якому каталозі:
 
``` java
//: Access/LibTest.java
// Використання бібліотеки. 
import net.mindview.simple.*;

public class LibTest {
    public static void main (String [] args) {
        Vector v = new Vector ();
        List l = new List ();
    }
} /* Output: 
net.mindview.simple.Vector 
net.mindview.simple.List 
*///:~
```
 
Коли компілятор зустрічає директиву ***import*** для бібліотеки ***simple***, він починає пошук в каталогах, перерахованих у змінній ***CLASSPATH***, шукає каталог ***net/mindview/simple***, а потім переходить до пошуку компілюваних файлів з відповідними іменами (***Vector.class*** для класу ***Vector*** і ***List.class*** для класу ***List***). Зауважте, що як класи, так і необхідні методи класів ***Vector*** і ***List*** повинні бути оголошені з специфікатором ***public***. 

#### Конфлікти імен

Що відбувається при імпортуванні конструкцією ***\**** двох бібліотек, що мають в своєму складі ідентичні імена? Припустимо, програма містить такі директиви:
 
``` java
import net.mindview.simple.*;
import java.util.*;
```
 
Так як пакет ***java.util.\**** Теж містить клас з ім'ям ***Vector***, це може привести до потенційного конфлікту. Але, поки ви не почнете писати код, що викликає конфлікти, все буде в порядку - і це добре, оскільки інакше вам довелося б витрачати зайві зусилля на запобігання конфліктів, яких насправді немає. Конфлікт дійсно станеться при спробі створити ***Vector***:
 
``` java
Vector v = new Vector ();
```
 
До якого з класів ***Vector*** відноситься ця команда? Цього не знають ні компілятор, ні читач програми. Тому компілятор видасть повідомлення про помилку і змусить явно визначити ім'я. Наприклад, якщо мені знадобиться стандартний клас *Java* з ім'ям ***Vector***, я повинен явно вказати цей факт:
 
``` java
java.util.Vector v = new java.util.Vector ();
```
 
Дана команда (разом зі змінною оточення ***CLASSPATH***) повністю описує місце розташування конкретного класу ***Vector***, тому директива ***import java.util.\**** Стає надмірною (по крайній мірі, якщо вам не будуть потрібні інші класи з цього пакета). 

## Призначені для користувача бібліотеки

Отримані знання дозволяють вам створювати власні бібліотеки, що скорочують або повністю виключають дублювання коду. Для прикладу можна взяти вже знайомий псевдонім для методу ***System.out.println()***, який скорочує кількість символів. Його можна включити в клас ***Print***:
 
``` java
//: Net/mindview/util/Print.java
// Методи-друку, які можуть використовуватися // без специфікаторів, завдяки конструкції package net.mindview.util;
import java.io.*;

public class Print {
    // Друк з перекладом рядка:
    public static void print (Object obj) {
        System.out.println (obj);
    }
    // Переклад рядка:
    public static void print () {
        System.out.println ();
    }
    // Друк без перекладу рядки:
    public static void printnb (Object obj) {
        System.out.print (obj);
    }
    // Нова конструкція Java SE5 printf () (from C):
    public static PrintStream
    printf (String format, Object ... args) {
        return System.out.printf (format, args);
    }
}
```
 
Нові методи можуть використовуватися для виведення будь-яких даних з нового рядка (***print()***), або в поточному рядку (***printnb()***).
Як неважко припустити, файл повинен розташовуватися в одному з каталогів, зазначених у змінній оточення ***CLASSPATH***, по шляху ***net/mindview***. Після компіляції методи ***static print()*** і ***printnb()*** можуть використовуватися де завгодно, для чого в програму досить включити директиву ***import static***:
 
``` java
//: Access/PrintTest.java
// Використання статичних методів друку з Print.java
import static net.mindview.util.Print.*;

public class PrintTest {
    public static void main (String [] args) {
        print ( "Available from now on!");
        print (100);
        print (100L);
        print (3.14159);
    }
} /* Output: 
Available from now on! 
100 
3.14159 
*///:~
```

Тепер, коли б ви не придумали новий цікавий інструмент, ви завжди можете додати його в свою бібліотеку.
 
**Застереження при роботі з пакетами**

Пам'ятайте, що створення пакету завжди неявно пов'язане з визначенням структури каталогів. Пакет повинен бути присутнім в однойменному каталозі, який, в свою чергу, визначається вмістом змінної ***CLASSPATH***. Перші експерименти з ключовим словом ***package***
можуть виявитися невдалими, поки ви твердо вирішив не засвоїте правило «ім'я пакета - його каталог». Інакше компілятор буде виводити безліч повідомлень про загадкових помилки виконання, про неможливість знайти клас, який знаходиться поруч в цьому ж каталозі. Якщо у вас виникають такі помилки, спробуйте закомментировать директиву ***package***; якщо все запуститься, ви знаєте, де шукати причини. 

## Специфікатори доступу *Java*

В *Java* специфікатор доступу ***public, protected*** і ***private*** розташовуються перед визначенням членів класів - як полів, так і методів. Кожен специфікатор доступу управляє тільки одним окремим визначенням.

Якщо специфікатор доступу невідомий, використовується «пакетний» рівень доступу. Виходить, що в будь-якому випадку діє та чи інша категорія доступу. У кількох найближчих підрозділах описані різні рівні доступу. 

### Доступ в межах пакету

У всіх розглянутих раніше прикладах специфікатор доступу не вказувалися. Доступ за замовчуванням не має ключового слова, але часто його називають доступом в межах пакету (***package access***, іноді «дружнім»). Це означає, що член класу доступний для всіх інших класів поточного пакета, але для класів за межами пакета він сприймається як приватний (private). Так як компільований модуль - файл - може належати лише одному пакету, всі класи одного компілюємого модуля автоматично відкриті один для одного в межах пакету.

Доступ в межах пакету дозволяє групувати взаємопов'язані класи в одному пакеті, щоб вони могли легко взаємодіяти один з одним. Розміщуючи класи в одному пакеті, ви берете код пакета під повний контроль. Таким чином, тільки ваш код буде мати пакетний доступ до іншого коду, що належить вам - і це цілком логічно. Можна сказати, що доступ в межах пакету і є основною причиною для групування класів в пакетах. У багатьох мовах визначення в класах організовуються абсолютно довільним чином, але в *Java* доведеться звикати до більш жорсткої логічної структури. До того ж класи, які не повинні мати доступ до класів поточного пакета, слід просто виключити з цього пакета.

Клас сам визначає, кому дозволено доступ до його членам. Не існує чарівного способу «увірватися» всередину нього. Код з іншого пакета не може запросто звернутися до пакету і розраховувати, що йому раптом стануть доступні всі члени: ***protected, private*** і доступні в пакеті. Отримати доступ можна лише кількома «законними» способами:

1. Оголосити член класу відкритим (***public***), тобто доступним для кого завгодно і звідки завгодно.
2. Зробити член класу доступним в пакеті, що не вказуючи інші специфікатори доступу, і розмістити інші класи в цьому ж пакеті.
3. Як ви побачите в розділі "Повторне використання класів", де розповідається про успадкування, похідний клас може отримати доступ до захищених (***protected***) членам базового класу разом з відкритими членами ***public*** (але не до приватних членам ***private***). Такий клас може користуватися доступом в межах пакету тільки в тому випадку, якщо другий клас належить тому ж пакету (втім, поки на успадкування та доступ protected можна не звертати уваги).
4. Надати «методи доступу», тобто методи для читання і модифікації значення. З точки зору ООП цей підхід є кращим, і саме він використовується в технології *JavaBeans*.
 
### Public
 
При використанні ключового слова ***public*** ви фактично оголошуєте, що наступне за ним оголошення члена класу доступне для всіх, і насамперед для клієнтських програмістів, що використовують бібліотеку. Припустимо, ви визначили пакет *** dessert ***, що містить наступний компільований модуль:
 
``` java
//: access/dessert/Cookie.java
// Створення бібліотеки.. 
package access.dessert; 
 
public class Cookie { 
  public Cookie() { 
   System.out.println("Cookie constructor"); 
  } 
  void bite() { System.out.println("bite"); } 
} ///:~
```

Пам'ятайте, що файл ***Cookie.java*** повинен розташовуватися в підкаталозі ***dessert*** каталогу з ім'ям ***access*** (що відповідає цьому розділу книги), а останній повинен бути включений в змінну ***CLASSPATH***. Не варто думати, ніби *Java* завжди починає пошук з поточного каталогу. Якщо ви не вкажете символ ***.*** (Точка) в змінній оточення ***CLASSPATH*** в якості одного з шляхів пошуку, то *Java* і не загляне в поточний каталог. Якщо тепер написати програму, яка використовує клас ***Cookie***:
 
``` java
//: access/Dinner.java 
// Використання бібліотеки.
import access.dessert.*; 
 
public class Dinner { 
  public static void main(String[] args) { 
    Cookie x = new Cookie(); 
    //! x.bite(); // Can’t access 
  } 
} /* Output: 
Cookie constructor 
*///:~ 
```
 
можна створити об'єкт ***Cookie***, оскільки конструктор цього класу оголошено відкритим (***public***) і сам клас також оголошений як ***public***. (Поняття відкритого класу ми пізніше розглянемо трохи докладніше.) Проте метод ***bite()*** цього класу недоступний в файлі ***Dinner.java***, оскільки доступ до нього надається тільки в пакеті ***dessert***. Так компілятор запобігає неправильному використанню методів. 

## Пакет за замовчуванням

З іншого боку, наступний код працює, хоча на перший погляд він начебто порушує правила:
 
``` java
//: access/Cake.java 
// Звернення до класу з іншого модуля.
class Cake {
    public static void main (String [] args) {
        Pie x = new Pie();
        xf ();
    }
} /* Output: 
Pie.f() 
*///:~
```

Інший файл в тому ж каталозі:
 
``` java
//: access/Pie.java 
// Інший клас.
class Pie {
    void f () {System.out.println ( "Pie.f ()"); }
}
```
 
Начебто ці два файли не мають нічого спільного, і все ж в класі ***Cake*** можна створити об'єкт ***Pie*** і викликати його метод ***f()*** (Щоб файли компілювалися, змінна ***CLASSPATH*** повинна містити символ точки.) Природно було б припустити, що клас ***Pie*** і метод ***f()*** мають доступ в межах пакету і тому закриті для ***Cake***. Вони дійсно мають доступ в межах пакету - тут все вірно. Однак їх доступність в класі ***Cake.java*** пояснюється тим, що вони знаходяться в одному каталозі і не мають явно заданого імені пакета. *Java* за замовчуванням включає такі файли в «пакет за замовчуванням» для поточного каталогу, тому вони мають доступ в межах пакету до інших файлів в цьому каталозі. 

## Private

Ключове слово ***private*** означає, що доступ до члена класу не надається нікому, крім методів цього класу. Інші класи того ж пакета також не можуть звертатися до ***private*** - членів. На перший погляд ви начебто ізолюєте клас навіть від самого себе. З іншого боку, цілком ймовірно, що пакет створюється цілою групою розробників; в цьому випадку private дозволяє змінювати члени класу, не побоюючись, що це відіб'ється на іншому класі даного пакету.

Пропонований за замовчуванням доступ в межах пакету часто виявляється достатнім для приховування даних; нагадаю, що такий член класу недоступний користувачеві пакету. Це зручно, так як зазвичай використовується саме такий рівень доступу (навіть в тому випадку, коли ви просто забудете додати специфікатор доступу). Таким чином, доступ ***public*** найчастіше використовується тоді, коли ви хочете зробити будь-які члени класу доступними для програміста-клієнта. Може скластися враження, що специфікатор доступу ***private*** застосовується рідко і можна обійтися і без нього. Однак розумне застосування ***private*** дуже важливо, особливо в умовах багатопоточного програмування (див. далі).

Приклад використання private:
 
``` java
//: Access/IceCream.java
// Демонстрація ключового слова private.
class Sundae {
    private Sundae () {}
    static Sundae makeASundae () {
        return new Sundae ();
    }
}

public class IceCream {
    public static void main (String [] args) {
    //! Sundae x = new Sundae ();
        Sundae x = Sundae.makeASundae ();
    }
}
```
 
<<<<<<< HEAD
Перед вами приклад ситуації, в якій *** private *** може бути дуже корисний: припустимо, ви хочете контролювати процес створення об'єкта, не дозволяючи стороннім викликати конкретний конструктор (або будь-які конструктори). В даному прикладі забороняється створювати об'єкти *** Sundae *** на конструктора; замість цього користувач повинен використовувати метод *** makeASundae () ***.
Всі «допоміжні» методи класів варто оголосити як *** private ***, щоб запобігти їх випадкові виклики в пакеті; тим самим ви фактично забороняєте зміна поведінки методу або його видалення.
Те ж вірно і до *** private *** - полях всередині класу. Якщо тільки ви не збираєтеся надати доступ користувачам до внутрішньої реалізації (а це відбувається набагато рідше, ніж можна собі уявити), оголошуйте всі поля своїх класів зі специфікатором *** private ***. # ## Protected
Щоб зрозуміти сенс специфікатор доступу *** protected ***, необхідно трохи забігти вперед. Відразу скажу, що розуміння цього розділу не обов'язково до знайомства зі спадщиною (глава 7). І все ж для отримання цілісного уявлення тут наводиться опис protected і приклади його використання.
Ключове слово *** protected *** тісно пов'язане з поняттям успадкування, при якому до вже існуючого класу (званому базовим класом)
додаються нові члени, причому вихідна реалізація залишається незмінною. Також можна змінювати поведінку вже існуючих членів класу. Для створення нового класу на базі існуючого використовується ключове слово *** extends ***:
=======
Перед вами приклад ситуації, в якій ***private*** може бути дуже корисним: припустимо, ви хочете контролювати процес створення об'єкта, не дозволяючи стороннім викликати конкретний конструктор (або будь-які конструктори). В даному прикладі забороняється створювати об'єкти ***Sundae*** через конструктор; замість цього користувач повинен використовувати метод ***makeASundae()***.

Всі «допоміжні» методи класів варто оголосити як ***private***, щоб запобігти їх випадковим викликам в пакеті; тим самим ви фактично забороняєте зміну поведінки методу або його видалення.

Те ж вірно і до ***private*** - полях всередині класу. Якщо тільки ви не збираєтеся надати доступ користувачам до внутрішньої реалізації (а це відбувається набагато рідше, ніж можна собі уявити), оголошуйте всі поля своїх класів зі специфікатором ***private***. 

## Protected

Щоб зрозуміти сенс специфікатор доступу ***protected***, необхідно трохи забігти вперед. Відразу скажу, що розуміння цього розділу не обов'язкове до знайомства зі успадкуванням (розділ "Повторне використання класів"). І все ж для отримання цілісного уявлення тут наводиться опис ***protected*** і приклади його використання.

Ключове слово ***protected*** тісно пов'язане з поняттям успадкування, при якому до вже існуючого класу (званому базовим класом)
додаються нові члени, причому початкова реалізація залишається незмінною. Також можна змінювати поведінку вже існуючих членів класу. Для створення нового класу на базі існуючого використовується ключове слово ***extends***:
 
``` java
class Foo extends Bar {}
```
 
Інша частина реалізації виглядає як завжди.

Якщо при створенні нового пакета використовується успадкування від класу, що знаходиться в іншому пакеті, новий клас отримує доступ тільки до відкритих (***public***) членів з вихідного пакета. (Звичайно, при успадкуванні в межах одного пакета можна отримати доступ до всіх членів з пакетним рівнем доступу.) Іноді творцеві базового класу необхідно надати доступ до конкретного методу похідних класів, але закрити його від всіх інших. Саме для цього завдання використовується ключове слово ***protected***. Специфікатор ***protected*** також надає доступ в межах пакету - тобто члени з цим специфікатором доступні для інших класів з того ж пакета. 

## Інтерфейс і реалізація

Контроль над доступом часто називають приховуванням реалізації. Розміщення даних і методів в класи в комбінації з приховуванням реалізації часто називають інкапсуляцією. В результаті з'являється тип даних, що володіє характеристиками і поведінкою.

Доступ до типів даних обмежується з двох причин. Перша причина - щоб програмісту-клієнту знати, що він може використовувати, а що не може. Ви вільні вбудувати в структуру реалізації свої внутрішні механізми, не побоюючись того, що програмісти-клієнти завдяки випадку використовують їх в якості частини інтерфейсу.

Це підводить нас безпосередньо до другої причини - поділу інтерфейсу і реалізації. Якщо в програмі використана певна структура, але програмісти-клієнти не можуть отримати доступ до її членів, крім відправки повідомлень ***рubliс*** - інтерфейсу, ви можете змінювати все, що не оголошено як ***public*** (члени з доступом в межах пакету, ***protected*** і ***private***), не порушуючи працездатності змін клієнтського коду.

Для більшої ясності при написанні класів можна використовувати такий стиль: спочатку записуються відкриті члени (***public***), потім слідують захищені члени (***protected***), потім - з доступом в межах пакету і нарешті закриті члени (***private***). Перевага такої схеми полягає в тому, що при читанні вихідного тексту користувач спочатку бачить те, що йому важливо (відкриті члени, доступ до яких можна отримати звідусіль), а потім зупиняється при переході до закритих членів, що є частиною внутрішньої реалізації:
 
``` java
//: access/OrganizedByAccess.java 
 
public class OrganizedByAccess { 
  public void pub1() { /* ... */ } 
  public void pub2() { /* ... */ } 
  public void pub3() { /* ... */ } 
  private void priv1() { /* ... */ } 
  private void priv2() { /* ... */ } 
  private void priv3() { /* ... */ } 
  private int i; 
  // ... 
} ///:~ 
```
 
Такий підхід лише частково спрощує читання коду, оскільки інтерфейс і реалізація все ще поєднані. Інакше кажучи, ви все ще бачите вихідний код - реалізацію - так, як він записаний прямо в класі. До того ж документація в коментарях, створювана за допомогою ***javadoc***, знижує необхідність в читанні вихідного тексту програмістом-клієнтом.

## Доступ до класів

В *Java* за допомогою специфікаторів доступу можна також вказати, які з класів всередині бібліотеки будуть доступні для її користувачів. Якщо ви хочете, щоб клас був відкритий програмісту-клієнту, то додаєте ключове слово ***public*** для класу в цілому. При цьому ви керуєте навіть самою можливістю створення об'єктів даного класу програмістом-клієнтом.

Для управління доступом до класу, специфікатор доступу записується перед ключовим словом ***class***:
 
``` java
public class Widget {}
```
 
Якщо ваша бібліотека називається, наприклад, ***access***, то будь-який програміст-клієнт зуміє звернутися ззовні до класу ***Widget***:
 
``` java
import access.Widget;
```
 
або
 
``` java
import access.*;
```
 
Втім, при цьому діють деякі обмеження:
- У кожному компільовані модулі може існувати **тільки один** відкритий (***public***) клас. Ідея в тому, що кожен модуль містить певний відкритий інтерфейс і реалізується цим відкритим класом. У модулі може міститися довільна кількість допоміжних класів з доступом в межах пакету. Якщо в модулі визначається більш одного відкритого класу, компілятор видасть повідомлення про помилку. 
- Ім'я відкритого класу має **в точності збігатися** з ім'ям файлу, в якому міститься модуль, включаючи регістр символів. Тому для класу ***Widget*** назва файлу має бути ***Widget.java***, але ніяк не ***widget.java*** або ***WIDGET.java***. В іншому випадку ви знову отримаєте повідомлення про помилку.
-  Модуль може взагалі не містити відкритих класів (хоча це і не типово). В цьому випадку файлу можна привласнити будь-яке ім'я на ваш розсуд. З іншого боку, вибір довільного імені створить труднощі у тих людей, які будуть читати і супроводжувати ваш код. 

Припустимо, в пакеті access є клас, який всього лише виконує деякі службові операції для класу ***Widget*** або для будь-якого іншого ***рublic*** - класу пакета. Звичайно, вам не захочеться возитися зі створенням зайвої документації для клієнта; можливо, коли-небудь ви просто зміните структуру пакета, приберете цей допоміжний клас і додасте нову реалізацію. Але для цього потрібно точно знати, що жоден програміст-клієнт не залежить від конкретної реалізації бібліотеки. Для цього ви просто опускаєте ключове слово ***public*** в визначенні класу; адже в такому разі він обмежується пакетним доступом, тобто може використовуватися тільки в межах свого пакету.

При створенні класу з доступом в межах пакету його поля все одно рекомендується позначати як ***private*** (завжди потрібно по максимуму перекривати доступ до полів класу), але методам варто давати той же рівень доступу, що має і сам клас (в межах пакету). Клас з пакетним доступом зазвичай використовується тільки в своєму пакеті, і робити методи такого класу відкритими (***public***) варто лише за крайньої необхідності - а про такі випадки вам повідомить компілятор.

Зауважте, що клас не можна оголосити як ***private*** (що зробить клас недоступним для оточуючих, використовувати він зможе тільки «сам себе»), або ***protected***. Тому у вас є лише такий вибір при завданні доступу до класу: в межах пакету або відкритий (***public***). Якщо ви хочете перекрити доступ до класу для всіх, оголосіть все його конструктори з специфікатором ***private***, відповідно, заборонивши кому б то не було створення об'єктів цього класу. Тільки ви самі, в статичному методі свого класу, зможете створювати такі об'єкти. Наприклад:
 
``` java
// Demonstrates class access specifiers. Make a class
// Специфікатори доступу для класів.
// Використання конструкторів, оголошених private,
// Робить клас недоступним при створенні об'єктів.
class Soup1 {
    private Soup1 () {}
    // (1) Дозволяємо створення об'єктів в статичному методі ::
    public static Soup1 makeSoup () {
        return new Soup1 ();
    }
}

class Soup2 {
    private Soup2 () {}
    // (2) Створюємо один статичний об'єкт і
// На вимогу повертаємо посилання на нього):
    private static Soup2 ps1 = new Soup2 ();
    public static Soup2 access () {
        return ps1;
    }
    public void f () {}
}

// У файлі може бути визначений тільки один public-клас:
public class Lunch {
    void testPrivate () {
// Заборонено, т.к конструктор оголошений приватним ::
//! Soup1 soup = new Soup1 ();
    }
    void testStatic () {
        Soup1 soup = Soup1.makeSoup ();
    }
    void testSingleton () {
        Soup2.access (). F ();
    }
}
```
 
До цього моменту більшість методів повертало, або ***void***, або один з примітивних типів, тому визначення:
 
``` java
public static Soupl makeSoup () {return new Soup1 ()}
```
 
на перший погляд виглядає трохи дивно. Слово ***Soup1*** перед ім'ям методу (***makeSoup***) показує, що повертається метод. У попередніх прикладах зазвичай використовувалося позначення ***void***, яке має на увазі, що метод не має значення, що повертається. Однак метод також може повертати посилання на об'єкт; в даному випадку повертається посилання на об'єкт класу ***Soup1***.

Класи ***Soup1*** і ***Soup2*** наочно показують, як запобігти прямому створенню об'єктів класу, оголосивши всі його конструктори з специфікатором ***private***. Пам'ятайте, що без явного визначення хоча б одного конструктора компілятор згенерує конструктор за замовчуванням (конструктор без аргументів). Визначаючи конструктор за замовчуванням в програмі, ви забороняєте його автоматичне створення. Якщо конструктор оголошений зі специфікатором ***private***, ніхто не зможе створювати об'єкти даного класу.

Але як же тоді використовувати цей клас? Розглянутий приклад демонструє два способи. У класі ***Soup1*** визначається статичний метод, який створює новий об'єкт ***Soup1*** і повертає посилання на нього. Це буває корисно в ситуаціях, де вам необхідно провести деякі операції над об'єктом перед поверненням посилання на нього, або при підрахунку загальної кількості створених об'єктів ***Soup1*** (наприклад, для обмеження їх максимальної кількості).

У класі ***Soup2*** використаний інший підхід - в програмі завжди створюється не більше одного об'єкта цього класу. Об'єкт ***Soup2***
створюється як статична приватна змінна, пoтому він завжди існує тільки в одному екземплярі і його неможливо отримати без виклику відкритого методу ***access()***. 

## Резюме

У будь-яких відносинах важливо встановити обмеження, які дотримуються усіма сторонами. При створенні бібліотеки ви встановлюєте стосунки з користувачем бібліотеки (програмістом-клієнтом), який створює програми, або бібліотеки вищого рівня з використанням ваших бібліотек.

Якщо програмісти-клієнти надані самі собі і не обмежені ніякими правилами, вони можуть робити все, що їм заманеться, з будь-якими членами класу - навіть тими, доступ до яких вам хотілося б обмежити. Всі деталі реалізації класу відкриті для навколишнього світу.

У цьому розділі розглядається процес побудови бібліотек з класів; по-перше, механізм груповання класів всередині бібліотеки і, по-друге, механізм управління доступом до членів класу.

За оцінками проекти на мові *C* починають «розсипатися» приблизно тоді, коли код досягає обсягу від 50 до 100 Кбайт, так як *C* має єдиний «простір імен»; в системі виникають конфлікти імен, що створюють масу незручностей. В *Java* ключове слово ***package***, схема іменування пакетів і ключове слово ***import*** забезпечують повний контроль над іменами, так що конфлікту імен можна легко уникнути.

Існує дві причини для обмеження доступу до членів класу. перша - запобігання використання клієнтами внутрішньої реалізації класу, що не входить у зовнішній інтерфейс. Оголошення полів і методів зі специфікатором ***private*** тільки допомагає користувачам класу, так як вони відразу бачать, які члени класу для них важливі, а які можна ігнорувати. Все це спрощує розуміння і використання класу. Друга, більш важлива причина для обмеження доступу - можливість зміни внутрішньої реалізації класу, що не зачіпає программістів-клієнтів. Наприклад, спочатку ви реалізуєте клас одним способом, а потім з'ясовується, що реструктуризація коду дозволить підвищити швидкість роботи. Відділення інтерфейсу від реалізації дозволить зробити це без порушення працездатності існуючого призначеного для користувача коду, в якому цей клас використовується.

Відкритий інтерфейс класу - це те, що фактично бачить його користувач, тому дуже важливо «довести до розуму» саме цю, найважливішу, частина класу в процесі аналізу і розробки. І навіть при цьому у вас залишається відносна свобода дій. Навіть якщо ідеальний інтерфейс не вдалося побудувати з першого разу, ви можете додати в нього нові методи - без видалення вже існуючих методів, які можуть використовуватися программістами-клієнтами.
 
